<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unicity WEB GUI Wallet</title>
    <!-- 
    Library: CryptoJS v4.1.1
    Description: JavaScript library of crypto standards
    Source: https://github.com/brix/crypto-js
    License: MIT License
    Downloaded from: https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js
    Last verified: April 23, 2025
    -->
    <script>
        !function(t,e){"object"==typeof exports?module.exports=exports=e():"function"==typeof define&&define.amd?define([],e):t.CryptoJS=e()}(this,function(){var n,o,s,a,h,t,e,l,r,i,c,f,d,u,p,S,x,b,A,H,z,_,v,g,y,B,w,k,m,C,D,E,R,M,F,P,W,O,I,U=U||function(h){var i;if("undefined"!=typeof window&&window.crypto&&(i=window.crypto),"undefined"!=typeof self&&self.crypto&&(i=self.crypto),!(i=!(i=!(i="undefined"!=typeof globalThis&&globalThis.crypto?globalThis.crypto:i)&&"undefined"!=typeof window&&window.msCrypto?window.msCrypto:i)&&"undefined"!=typeof global&&global.crypto?global.crypto:i)&&"function"==typeof require)try{i=require("crypto")}catch(t){}var r=Object.create||function(t){return e.prototype=t,t=new e,e.prototype=null,t};function e(){}var t={},n=t.lib={},o=n.Base={extend:function(t){var e=r(this);return t&&e.mixIn(t),e.hasOwnProperty("init")&&this.init!==e.init||(e.init=function(){e.$super.init.apply(this,arguments)}),(e.init.prototype=e).$super=this,e},create:function(){var t=this.extend();return t.init.apply(t,arguments),t},init:function(){},mixIn:function(t){for(var e in t)t.hasOwnProperty(e)&&(this[e]=t[e]);t.hasOwnProperty("toString")&&(this.toString=t.toString)},clone:function(){return this.init.prototype.extend(this)}},l=n.WordArray=o.extend({init:function(t,e){t=this.words=t||[],this.sigBytes=null!=e?e:4*t.length},toString:function(t){return(t||c).stringify(this)},concat:function(t){var e=this.words,r=t.words,i=this.sigBytes,n=t.sigBytes;if(this.clamp(),i%4)for(var o=0;o<n;o++){var s=r[o>>>2]>>>24-o%4*8&255;e[i+o>>>2]|=s<<24-(i+o)%4*8}else for(var c=0;c<n;c+=4)e[i+c>>>2]=r[c>>>2];return this.sigBytes+=n,this},clamp:function(){var t=this.words,e=this.sigBytes;t[e>>>2]&=4294967295<<32-e%4*8,t.length=h.ceil(e/4)},clone:function(){var t=o.clone.call(this);return t.words=this.words.slice(0),t},random:function(t){for(var e=[],r=0;r<t;r+=4)e.push(function(){if(i){if("function"==typeof i.getRandomValues)try{return i.getRandomValues(new Uint32Array(1))[0]}catch(t){}if("function"==typeof i.randomBytes)try{return i.randomBytes(4).readInt32LE()}catch(t){}}throw new Error("Native crypto module could not be used to get secure random number.")}());return new l.init(e,t)}}),s=t.enc={},c=s.Hex={stringify:function(t){for(var e=t.words,r=t.sigBytes,i=[],n=0;n<r;n++){var o=e[n>>>2]>>>24-n%4*8&255;i.push((o>>>4).toString(16)),i.push((15&o).toString(16))}return i.join("")},parse:function(t){for(var e=t.length,r=[],i=0;i<e;i+=2)r[i>>>3]|=parseInt(t.substr(i,2),16)<<24-i%8*4;return new l.init(r,e/2)}},a=s.Latin1={stringify:function(t){for(var e=t.words,r=t.sigBytes,i=[],n=0;n<r;n++){var o=e[n>>>2]>>>24-n%4*8&255;i.push(String.fromCharCode(o))}return i.join("")},parse:function(t){for(var e=t.length,r=[],i=0;i<e;i++)r[i>>>2]|=(255&t.charCodeAt(i))<<24-i%4*8;return new l.init(r,e)}},f=s.Utf8={stringify:function(t){try{return decodeURIComponent(escape(a.stringify(t)))}catch(t){throw new Error("Malformed UTF-8 data")}},parse:function(t){return a.parse(unescape(encodeURIComponent(t)))}},d=n.BufferedBlockAlgorithm=o.extend({reset:function(){this._data=new l.init,this._nDataBytes=0},_append:function(t){"string"==typeof t&&(t=f.parse(t)),this._data.concat(t),this._nDataBytes+=t.sigBytes},_process:function(t){var e,r=this._data,i=r.words,n=r.sigBytes,o=this.blockSize,s=n/(4*o),c=(s=t?h.ceil(s):h.max((0|s)-this._minBufferSize,0))*o,n=h.min(4*c,n);if(c){for(var a=0;a<c;a+=o)this._doProcessBlock(i,a);e=i.splice(0,c),r.sigBytes-=n}return new l.init(e,n)},clone:function(){var t=o.clone.call(this);return t._data=this._data.clone(),t},_minBufferSize:0}),u=(n.Hasher=d.extend({cfg:o.extend(),init:function(t){this.cfg=this.cfg.extend(t),this.reset()},reset:function(){d.reset.call(this),this._doReset()},update:function(t){return this._append(t),this._process(),this},finalize:function(t){return t&&this._append(t),this._doFinalize()},blockSize:16,_createHelper:function(r){return function(t,e){return new r.init(e).finalize(t)}},_createHmacHelper:function(r){return function(t,e){return new u.HMAC.init(r,e).finalize(t)}}}),t.algo={});return t}(Math);function K(t,e,r){return t&e|~t&r}function X(t,e,r){return t&r|e&~r}function L(t,e){return t<<e|t>>>32-e}function j(t,e,r,i){var n,o=this._iv;o?(n=o.slice(0),this._iv=void 0):n=this._prevBlock,i.encryptBlock(n,0);for(var s=0;s<r;s++)t[e+s]^=n[s]}function T(t){var e,r,i;return 255==(t>>24&255)?(r=t>>8&255,i=255&t,255===(e=t>>16&255)?(e=0,255===r?(r=0,255===i?i=0:++i):++r):++e,t=0,t+=e<<16,t+=r<<8,t+=i):t+=1<<24,t}function N(){for(var t=this._X,e=this._C,r=0;r<8;r++)E[r]=e[r];e[0]=e[0]+1295307597+this._b|0,e[1]=e[1]+3545052371+(e[0]>>>0<E[0]>>>0?1:0)|0,e[2]=e[2]+886263092+(e[1]>>>0<E[1]>>>0?1:0)|0,e[3]=e[3]+1295307597+(e[2]>>>0<E[2]>>>0?1:0)|0,e[4]=e[4]+3545052371+(e[3]>>>0<E[3]>>>0?1:0)|0,e[5]=e[5]+886263092+(e[4]>>>0<E[4]>>>0?1:0)|0,e[6]=e[6]+1295307597+(e[5]>>>0<E[5]>>>0?1:0)|0,e[7]=e[7]+3545052371+(e[6]>>>0<E[6]>>>0?1:0)|0,this._b=e[7]>>>0<E[7]>>>0?1:0;for(r=0;r<8;r++){var i=t[r]+e[r],n=65535&i,o=i>>>16;R[r]=((n*n>>>17)+n*o>>>15)+o*o^((4294901760&i)*i|0)+((65535&i)*i|0)}t[0]=R[0]+(R[7]<<16|R[7]>>>16)+(R[6]<<16|R[6]>>>16)|0,t[1]=R[1]+(R[0]<<8|R[0]>>>24)+R[7]|0,t[2]=R[2]+(R[1]<<16|R[1]>>>16)+(R[0]<<16|R[0]>>>16)|0,t[3]=R[3]+(R[2]<<8|R[2]>>>24)+R[1]|0,t[4]=R[4]+(R[3]<<16|R[3]>>>16)+(R[2]<<16|R[2]>>>16)|0,t[5]=R[5]+(R[4]<<8|R[4]>>>24)+R[3]|0,t[6]=R[6]+(R[5]<<16|R[5]>>>16)+(R[4]<<16|R[4]>>>16)|0,t[7]=R[7]+(R[6]<<8|R[6]>>>24)+R[5]|0}function q(){for(var t=this._X,e=this._C,r=0;r<8;r++)O[r]=e[r];e[0]=e[0]+1295307597+this._b|0,e[1]=e[1]+3545052371+(e[0]>>>0<O[0]>>>0?1:0)|0,e[2]=e[2]+886263092+(e[1]>>>0<O[1]>>>0?1:0)|0,e[3]=e[3]+1295307597+(e[2]>>>0<O[2]>>>0?1:0)|0,e[4]=e[4]+3545052371+(e[3]>>>0<O[3]>>>0?1:0)|0,e[5]=e[5]+886263092+(e[4]>>>0<O[4]>>>0?1:0)|0,e[6]=e[6]+1295307597+(e[5]>>>0<O[5]>>>0?1:0)|0,e[7]=e[7]+3545052371+(e[6]>>>0<O[6]>>>0?1:0)|0,this._b=e[7]>>>0<O[7]>>>0?1:0;for(r=0;r<8;r++){var i=t[r]+e[r],n=65535&i,o=i>>>16;I[r]=((n*n>>>17)+n*o>>>15)+o*o^((4294901760&i)*i|0)+((65535&i)*i|0)}t[0]=I[0]+(I[7]<<16|I[7]>>>16)+(I[6]<<16|I[6]>>>16)|0,t[1]=I[1]+(I[0]<<8|I[0]>>>24)+I[7]|0,t[2]=I[2]+(I[1]<<16|I[1]>>>16)+(I[0]<<16|I[0]>>>16)|0,t[3]=I[3]+(I[2]<<8|I[2]>>>24)+I[1]|0,t[4]=I[4]+(I[3]<<16|I[3]>>>16)+(I[2]<<16|I[2]>>>16)|0,t[5]=I[5]+(I[4]<<8|I[4]>>>24)+I[3]|0,t[6]=I[6]+(I[5]<<16|I[5]>>>16)+(I[4]<<16|I[4]>>>16)|0,t[7]=I[7]+(I[6]<<8|I[6]>>>24)+I[5]|0}return F=(M=U).lib,n=F.Base,o=F.WordArray,(M=M.x64={}).Word=n.extend({init:function(t,e){this.high=t,this.low=e}}),M.WordArray=n.extend({init:function(t,e){t=this.words=t||[],this.sigBytes=null!=e?e:8*t.length},toX32:function(){for(var t=this.words,e=t.length,r=[],i=0;i<e;i++){var n=t[i];r.push(n.high),r.push(n.low)}return o.create(r,this.sigBytes)},clone:function(){for(var t=n.clone.call(this),e=t.words=this.words.slice(0),r=e.length,i=0;i<r;i++)e[i]=e[i].clone();return t}}),"function"==typeof ArrayBuffer&&(P=U.lib.WordArray,s=P.init,(P.init=function(t){if((t=(t=t instanceof ArrayBuffer?new Uint8Array(t):t)instanceof Int8Array||"undefined"!=typeof Uint8ClampedArray&&t instanceof Uint8ClampedArray||t instanceof Int16Array||t instanceof Uint16Array||t instanceof Int32Array||t instanceof Uint32Array||t instanceof Float32Array||t instanceof Float64Array?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):t)instanceof Uint8Array){for(var e=t.byteLength,r=[],i=0;i<e;i++)r[i>>>2]|=t[i]<<24-i%4*8;s.call(this,r,e)}else s.apply(this,arguments)}).prototype=P),function(){var t=U,n=t.lib.WordArray,t=t.enc;t.Utf16=t.Utf16BE={stringify:function(t){for(var e=t.words,r=t.sigBytes,i=[],n=0;n<r;n+=2){var o=e[n>>>2]>>>16-n%4*8&65535;i.push(String.fromCharCode(o))}return i.join("")},parse:function(t){for(var e=t.length,r=[],i=0;i<e;i++)r[i>>>1]|=t.charCodeAt(i)<<16-i%2*16;return n.create(r,2*e)}};function s(t){return t<<8&4278255360|t>>>8&16711935}t.Utf16LE={stringify:function(t){for(var e=t.words,r=t.sigBytes,i=[],n=0;n<r;n+=2){var o=s(e[n>>>2]>>>16-n%4*8&65535);i.push(String.fromCharCode(o))}return i.join("")},parse:function(t){for(var e=t.length,r=[],i=0;i<e;i++)r[i>>>1]|=s(t.charCodeAt(i)<<16-i%2*16);return n.create(r,2*e)}}}(),a=(w=U).lib.WordArray,w.enc.Base64={stringify:function(t){var e=t.words,r=t.sigBytes,i=this._map;t.clamp();for(var n=[],o=0;o<r;o+=3)for(var s=(e[o>>>2]>>>24-o%4*8&255)<<16|(e[o+1>>>2]>>>24-(o+1)%4*8&255)<<8|e[o+2>>>2]>>>24-(o+2)%4*8&255,c=0;c<4&&o+.75*c<r;c++)n.push(i.charAt(s>>>6*(3-c)&63));var a=i.charAt(64);if(a)for(;n.length%4;)n.push(a);return n.join("")},parse:function(t){var e=t.length,r=this._map;if(!(i=this._reverseMap))for(var i=this._reverseMap=[],n=0;n<r.length;n++)i[r.charCodeAt(n)]=n;var o=r.charAt(64);return!o||-1!==(o=t.indexOf(o))&&(e=o),function(t,e,r){for(var i=[],n=0,o=0;o<e;o++){var s,c;o%4&&(s=r[t.charCodeAt(o-1)]<<o%4*2,c=r[t.charCodeAt(o)]>>>6-o%4*2,c=s|c,i[n>>>2]|=c<<24-n%4*8,n++)}return a.create(i,n)}(t,e,i)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="},h=(F=U).lib.WordArray,F.enc.Base64url={stringify:function(t,e=!0){var r=t.words,i=t.sigBytes,n=e?this._safe_map:this._map;t.clamp();for(var o=[],s=0;s<i;s+=3)for(var c=(r[s>>>2]>>>24-s%4*8&255)<<16|(r[s+1>>>2]>>>24-(s+1)%4*8&255)<<8|r[s+2>>>2]>>>24-(s+2)%4*8&255,a=0;a<4&&s+.75*a<i;a++)o.push(n.charAt(c>>>6*(3-a)&63));var h=n.charAt(64);if(h)for(;o.length%4;)o.push(h);return o.join("")},parse:function(t,e=!0){var r=t.length,i=e?this._safe_map:this._map;if(!(n=this._reverseMap))for(var n=this._reverseMap=[],o=0;o<i.length;o++)n[i.charCodeAt(o)]=o;e=i.charAt(64);return!e||-1!==(e=t.indexOf(e))&&(r=e),function(t,e,r){for(var i=[],n=0,o=0;o<e;o++){var s,c;o%4&&(s=r[t.charCodeAt(o-1)]<<o%4*2,c=r[t.charCodeAt(o)]>>>6-o%4*2,c=s|c,i[n>>>2]|=c<<24-n%4*8,n++)}return h.create(i,n)}(t,r,n)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",_safe_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"},function(a){var t=U,e=t.lib,r=e.WordArray,i=e.Hasher,e=t.algo,A=[];!function(){for(var t=0;t<64;t++)A[t]=4294967296*a.abs(a.sin(t+1))|0}();e=e.MD5=i.extend({_doReset:function(){this._hash=new r.init([1732584193,4023233417,2562383102,271733878])},_doProcessBlock:function(t,e){for(var r=0;r<16;r++){var i=e+r,n=t[i];t[i]=16711935&(n<<8|n>>>24)|4278255360&(n<<24|n>>>8)}var o=this._hash.words,s=t[e+0],c=t[e+1],a=t[e+2],h=t[e+3],l=t[e+4],f=t[e+5],d=t[e+6],u=t[e+7],p=t[e+8],_=t[e+9],y=t[e+10],v=t[e+11],g=t[e+12],B=t[e+13],w=t[e+14],k=t[e+15],m=H(m=o[0],b=o[1],x=o[2],S=o[3],s,7,A[0]),S=H(S,m,b,x,c,12,A[1]),x=H(x,S,m,b,a,17,A[2]),b=H(b,x,S,m,h,22,A[3]);m=H(m,b,x,S,l,7,A[4]),S=H(S,m,b,x,f,12,A[5]),x=H(x,S,m,b,d,17,A[6]),b=H(b,x,S,m,u,22,A[7]),m=H(m,b,x,S,p,7,A[8]),S=H(S,m,b,x,_,12,A[9]),x=H(x,S,m,b,y,17,A[10]),b=H(b,x,S,m,v,22,A[11]),m=H(m,b,x,S,g,7,A[12]),S=H(S,m,b,x,B,12,A[13]),x=H(x,S,m,b,w,17,A[14]),m=z(m,b=H(b,x,S,m,k,22,A[15]),x,S,c,5,A[16]),S=z(S,m,b,x,d,9,A[17]),x=z(x,S,m,b,v,14,A[18]),b=z(b,x,S,m,s,20,A[19]),m=z(m,b,x,S,f,5,A[20]),S=z(S,m,b,x,y,9,A[21]),x=z(x,S,m,b,k,14,A[22]),b=z(b,x,S,m,l,20,A[23]),m=z(m,b,x,S,_,5,A[24]),S=z(S,m,b,x,w,9,A[25]),x=z(x,S,m,b,h,14,A[26]),b=z(b,x,S,m,p,20,A[27]),m=z(m,b,x,S,B,5,A[28]),S=z(S,m,b,x,a,9,A[29]),x=z(x,S,m,b,u,14,A[30]),m=C(m,b=z(b,x,S,m,g,20,A[31]),x,S,f,4,A[32]),S=C(S,m,b,x,p,11,A[33]),x=C(x,S,m,b,v,16,A[34]),b=C(b,x,S,m,w,23,A[35]),m=C(m,b,x,S,c,4,A[36]),S=C(S,m,b,x,l,11,A[37]),x=C(x,S,m,b,u,16,A[38]),b=C(b,x,S,m,y,23,A[39]),m=C(m,b,x,S,B,4,A[40]),S=C(S,m,b,x,s,11,A[41]),x=C(x,S,m,b,h,16,A[42]),b=C(b,x,S,m,d,23,A[43]),m=C(m,b,x,S,_,4,A[44]),S=C(S,m,b,x,g,11,A[45]),x=C(x,S,m,b,k,16,A[46]),m=D(m,b=C(b,x,S,m,a,23,A[47]),x,S,s,6,A[48]),S=D(S,m,b,x,u,10,A[49]),x=D(x,S,m,b,w,15,A[50]),b=D(b,x,S,m,f,21,A[51]),m=D(m,b,x,S,g,6,A[52]),S=D(S,m,b,x,h,10,A[53]),x=D(x,S,m,b,y,15,A[54]),b=D(b,x,S,m,c,21,A[55]),m=D(m,b,x,S,p,6,A[56]),S=D(S,m,b,x,k,10,A[57]),x=D(x,S,m,b,d,15,A[58]),b=D(b,x,S,m,B,21,A[59]),m=D(m,b,x,S,l,6,A[60]),S=D(S,m,b,x,v,10,A[61]),x=D(x,S,m,b,a,15,A[62]),b=D(b,x,S,m,_,21,A[63]),o[0]=o[0]+m|0,o[1]=o[1]+b|0,o[2]=o[2]+x|0,o[3]=o[3]+S|0},_doFinalize:function(){var t=this._data,e=t.words,r=8*this._nDataBytes,i=8*t.sigBytes;e[i>>>5]|=128<<24-i%32;var n=a.floor(r/4294967296),r=r;e[15+(64+i>>>9<<4)]=16711935&(n<<8|n>>>24)|4278255360&(n<<24|n>>>8),e[14+(64+i>>>9<<4)]=16711935&(r<<8|r>>>24)|4278255360&(r<<24|r>>>8),t.sigBytes=4*(e.length+1),this._process();for(var e=this._hash,o=e.words,s=0;s<4;s++){var c=o[s];o[s]=16711935&(c<<8|c>>>24)|4278255360&(c<<24|c>>>8)}return e},clone:function(){var t=i.clone.call(this);return t._hash=this._hash.clone(),t}});function H(t,e,r,i,n,o,s){s=t+(e&r|~e&i)+n+s;return(s<<o|s>>>32-o)+e}function z(t,e,r,i,n,o,s){s=t+(e&i|r&~i)+n+s;return(s<<o|s>>>32-o)+e}function C(t,e,r,i,n,o,s){s=t+(e^r^i)+n+s;return(s<<o|s>>>32-o)+e}function D(t,e,r,i,n,o,s){s=t+(r^(e|~i))+n+s;return(s<<o|s>>>32-o)+e}t.MD5=i._createHelper(e),t.HmacMD5=i._createHmacHelper(e)}(Math),P=(M=U).lib,t=P.WordArray,e=P.Hasher,P=M.algo,l=[],P=P.SHA1=e.extend({_doReset:function(){this._hash=new t.init([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(t,e){for(var r=this._hash.words,i=r[0],n=r[1],o=r[2],s=r[3],c=r[4],a=0;a<80;a++){a<16?l[a]=0|t[e+a]:(h=l[a-3]^l[a-8]^l[a-14]^l[a-16],l[a]=h<<1|h>>>31);var h=(i<<5|i>>>27)+c+l[a];h+=a<20?1518500249+(n&o|~n&s):a<40?1859775393+(n^o^s):a<60?(n&o|n&s|o&s)-1894007588:(n^o^s)-899497514,c=s,s=o,o=n<<30|n>>>2,n=i,i=h}r[0]=r[0]+i|0,r[1]=r[1]+n|0,r[2]=r[2]+o|0,r[3]=r[3]+s|0,r[4]=r[4]+c|0},_doFinalize:function(){var t=this._data,e=t.words,r=8*this._nDataBytes,i=8*t.sigBytes;return e[i>>>5]|=128<<24-i%32,e[14+(64+i>>>9<<4)]=Math.floor(r/4294967296),e[15+(64+i>>>9<<4)]=r,t.sigBytes=4*e.length,this._process(),this._hash},clone:function(){var t=e.clone.call(this);return t._hash=this._hash.clone(),t}}),M.SHA1=e._createHelper(P),M.HmacSHA1=e._createHmacHelper(P),function(n){var t=U,e=t.lib,r=e.WordArray,i=e.Hasher,e=t.algo,o=[],p=[];!function(){function t(t){return 4294967296*(t-(0|t))|0}for(var e=2,r=0;r<64;)!function(t){for(var e=n.sqrt(t),r=2;r<=e;r++)if(!(t%r))return;return 1}(e)||(r<8&&(o[r]=t(n.pow(e,.5))),p[r]=t(n.pow(e,1/3)),r++),e++}();var _=[],e=e.SHA256=i.extend({_doReset:function(){this._hash=new r.init(o.slice(0))},_doProcessBlock:function(t,e){for(var r=this._hash.words,i=r[0],n=r[1],o=r[2],s=r[3],c=r[4],a=r[5],h=r[6],l=r[7],f=0;f<64;f++){f<16?_[f]=0|t[e+f]:(d=_[f-15],u=_[f-2],_[f]=((d<<25|d>>>7)^(d<<14|d>>>18)^d>>>3)+_[f-7]+((u<<15|u>>>17)^(u<<13|u>>>19)^u>>>10)+_[f-16]);var d=i&n^i&o^n&o,u=l+((c<<26|c>>>6)^(c<<21|c>>>11)^(c<<7|c>>>25))+(c&a^~c&h)+p[f]+_[f],l=h,h=a,a=c,c=s+u|0,s=o,o=n,n=i,i=u+(((i<<30|i>>>2)^(i<<19|i>>>13)^(i<<10|i>>>22))+d)|0}r[0]=r[0]+i|0,r[1]=r[1]+n|0,r[2]=r[2]+o|0,r[3]=r[3]+s|0,r[4]=r[4]+c|0,r[5]=r[5]+a|0,r[6]=r[6]+h|0,r[7]=r[7]+l|0},_doFinalize:function(){var t=this._data,e=t.words,r=8*this._nDataBytes,i=8*t.sigBytes;return e[i>>>5]|=128<<24-i%32,e[14+(64+i>>>9<<4)]=n.floor(r/4294967296),e[15+(64+i>>>9<<4)]=r,t.sigBytes=4*e.length,this._process(),this._hash},clone:function(){var t=i.clone.call(this);return t._hash=this._hash.clone(),t}});t.SHA256=i._createHelper(e),t.HmacSHA256=i._createHmacHelper(e)}(Math),r=(w=U).lib.WordArray,F=w.algo,i=F.SHA256,F=F.SHA224=i.extend({_doReset:function(){this._hash=new r.init([3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428])},_doFinalize:function(){var t=i._doFinalize.call(this);return t.sigBytes-=4,t}}),w.SHA224=i._createHelper(F),w.HmacSHA224=i._createHmacHelper(F),function(){var t=U,e=t.lib.Hasher,r=t.x64,i=r.Word,n=r.WordArray,r=t.algo;function o(){return i.create.apply(i,arguments)}var t1=[o(1116352408,3609767458),o(1899447441,602891725),o(3049323471,3964484399),o(3921009573,2173295548),o(961987163,4081628472),o(1508970993,3053834265),o(2453635748,2937671579),o(2870763221,3664609560),o(3624381080,2734883394),o(310598401,1164996542),o(607225278,1323610764),o(1426881987,3590304994),o(1925078388,4068182383),o(2162078206,991336113),o(2614888103,633803317),o(3248222580,3479774868),o(3835390401,2666613458),o(4022224774,944711139),o(264347078,2341262773),o(604807628,2007800933),o(770255983,1495990901),o(1249150122,1856431235),o(1555081692,3175218132),o(1996064986,2198950837),o(2554220882,3999719339),o(2821834349,766784016),o(2952996808,2566594879),o(3210313671,3203337956),o(3336571891,1034457026),o(3584528711,2466948901),o(113926993,3758326383),o(338241895,168717936),o(666307205,1188179964),o(773529912,1546045734),o(1294757372,1522805485),o(1396182291,2643833823),o(1695183700,2343527390),o(1986661051,1014477480),o(2177026350,1206759142),o(2456956037,344077627),o(2730485921,1290863460),o(2820302411,3158454273),o(3259730800,3505952657),o(3345764771,106217008),o(3516065817,3606008344),o(3600352804,1432725776),o(4094571909,1467031594),o(275423344,851169720),o(430227734,3100823752),o(506948616,1363258195),o(659060556,3750685593),o(883997877,3785050280),o(958139571,3318307427),o(1322822218,3812723403),o(1537002063,2003034995),o(1747873779,3602036899),o(1955562222,1575990012),o(2024104815,1125592928),o(2227730452,2716904306),o(2361852424,442776044),o(2428436474,593698344),o(2756734187,3733110249),o(3204031479,2999351573),o(3329325298,3815920427),o(3391569614,3928383900),o(3515267271,566280711),o(3940187606,3454069534),o(4118630271,4000239992),o(116418474,1914138554),o(174292421,2731055270),o(289380356,3203993006),o(460393269,320620315),o(685471733,587496836),o(852142971,1086792851),o(1017036298,365543100),o(1126000580,2618297676),o(1288033470,3409855158),o(1501505948,4234509866),o(1607167915,987167468),o(1816402316,1246189591)],e1=[];!function(){for(var t=0;t<80;t++)e1[t]=o()}();r=r.SHA512=e.extend({_doReset:function(){this._hash=new n.init([new i.init(1779033703,4089235720),new i.init(3144134277,2227873595),new i.init(1013904242,4271175723),new i.init(2773480762,1595750129),new i.init(1359893119,2917565137),new i.init(2600822924,725511199),new i.init(528734635,4215389547),new i.init(1541459225,327033209)])},_doProcessBlock:function(t,e){for(var r=this._hash.words,i=r[0],n=r[1],o=r[2],s=r[3],c=r[4],a=r[5],h=r[6],l=r[7],f=i.high,d=i.low,u=n.high,p=n.low,_=o.high,y=o.low,v=s.high,g=s.low,B=c.high,w=c.low,k=a.high,m=a.low,S=h.high,x=h.low,b=l.high,r=l.low,A=f,H=d,z=u,C=p,D=_,E=y,R=v,M=g,F=B,P=w,W=k,O=m,I=S,U=x,K=b,X=r,L=0;L<80;L++){var j,T,N=e1[L];L<16?(T=N.high=0|t[e+2*L],j=N.low=0|t[e+2*L+1]):($=(q=e1[L-15]).high,J=q.low,G=(Q=e1[L-2]).high,V=Q.low,Z=(Y=e1[L-7]).high,q=Y.low,Y=(Q=e1[L-16]).high,T=(T=(($>>>1|J<<31)^($>>>8|J<<24)^$>>>7)+Z+((j=(Z=(J>>>1|$<<31)^(J>>>8|$<<24)^(J>>>7|$<<25))+q)>>>0<Z>>>0?1:0))+((G>>>19|V<<13)^(G<<3|V>>>29)^G>>>6)+((j+=J=(V>>>19|G<<13)^(V<<3|G>>>29)^(V>>>6|G<<26))>>>0<J>>>0?1:0),j+=$=Q.low,N.high=T=T+Y+(j>>>0<$>>>0?1:0),N.low=j);var q=F&W^~F&I,Z=P&O^~P&U,V=A&z^A&D^z&D,G=(H>>>28|A<<4)^(H<<30|A>>>2)^(H<<25|A>>>7),J=t1[L],Q=J.high,Y=J.low,$=X+((P>>>14|F<<18)^(P>>>18|F<<14)^(P<<23|F>>>9)),N=K+((F>>>14|P<<18)^(F>>>18|P<<14)^(F<<23|P>>>9))+($>>>0<X>>>0?1:0),J=G+(H&C^H&E^C&E),K=I,X=U,I=W,U=O,W=F,O=P,F=R+(N=(N=(N=N+q+(($=$+Z)>>>0<Z>>>0?1:0))+Q+(($=$+Y)>>>0<Y>>>0?1:0))+T+(($=$+j)>>>0<j>>>0?1:0))+((P=M+$|0)>>>0<M>>>0?1:0)|0,R=D,M=E,D=z,E=C,z=A,C=H,A=N+(((A>>>28|H<<4)^(A<<30|H>>>2)^(A<<25|H>>>7))+V+(J>>>0<G>>>0?1:0))+((H=$+J|0)>>>0<$>>>0?1:0)|0}d=i.low=d+H,i.high=f+A+(d>>>0<H>>>0?1:0),p=n.low=p+C,n.high=u+z+(p>>>0<C>>>0?1:0),y=o.low=y+E,o.high=_+D+(y>>>0<E>>>0?1:0),g=s.low=g+M,s.high=v+R+(g>>>0<M>>>0?1:0),w=c.low=w+P,c.high=B+F+(w>>>0<P>>>0?1:0),m=a.low=m+O,a.high=k+W+(m>>>0<O>>>0?1:0),x=h.low=x+U,h.high=S+I+(x>>>0<U>>>0?1:0),r=l.low=r+X,l.high=b+K+(r>>>0<X>>>0?1:0)},_doFinalize:function(){var t=this._data,e=t.words,r=8*this._nDataBytes,i=8*t.sigBytes;return e[i>>>5]|=128<<24-i%32,e[30+(128+i>>>10<<5)]=Math.floor(r/4294967296),e[31+(128+i>>>10<<5)]=r,t.sigBytes=4*e.length,this._process(),this._hash.toX32()},clone:function(){var t=e.clone.call(this);return t._hash=this._hash.clone(),t},blockSize:32});t.SHA512=e._createHelper(r),t.HmacSHA512=e._createHmacHelper(r)}(),P=(M=U).x64,c=P.Word,f=P.WordArray,P=M.algo,d=P.SHA512,P=P.SHA384=d.extend({_doReset:function(){this._hash=new f.init([new c.init(3418070365,3238371032),new c.init(1654270250,914150663),new c.init(2438529370,812702999),new c.init(355462360,4144912697),new c.init(1731405415,4290775857),new c.init(2394180231,1750603025),new c.init(3675008525,1694076839),new c.init(1203062813,3204075428)])},_doFinalize:function(){var t=d._doFinalize.call(this);return t.sigBytes-=16,t}}),M.SHA384=d._createHelper(P),M.HmacSHA384=d._createHmacHelper(P),function(l){var t=U,e=t.lib,f=e.WordArray,i=e.Hasher,d=t.x64.Word,e=t.algo,A=[],H=[],z=[];!function(){for(var t=1,e=0,r=0;r<24;r++){A[t+5*e]=(r+1)*(r+2)/2%64;var i=(2*t+3*e)%5;t=e%5,e=i}for(t=0;t<5;t++)for(e=0;e<5;e++)H[t+5*e]=e+(2*t+3*e)%5*5;for(var n=1,o=0;o<24;o++){for(var s,c=0,a=0,h=0;h<7;h++)1&n&&((s=(1<<h)-1)<32?a^=1<<s:c^=1<<s-32),128&n?n=n<<1^113:n<<=1;z[o]=d.create(c,a)}}();var C=[];!function(){for(var t=0;t<25;t++)C[t]=d.create()}();e=e.SHA3=i.extend({cfg:i.cfg.extend({outputLength:512}),_doReset:function(){for(var t=this._state=[],e=0;e<25;e++)t[e]=new d.init;this.blockSize=(1600-2*this.cfg.outputLength)/32},_doProcessBlock:function(t,e){for(var r=this._state,i=this.blockSize/2,n=0;n<i;n++){var o=t[e+2*n],s=t[e+2*n+1],o=16711935&(o<<8|o>>>24)|4278255360&(o<<24|o>>>8);(m=r[n]).high^=s=16711935&(s<<8|s>>>24)|4278255360&(s<<24|s>>>8),m.low^=o}for(var c=0;c<24;c++){for(var a=0;a<5;a++){for(var h=0,l=0,f=0;f<5;f++)h^=(m=r[a+5*f]).high,l^=m.low;var d=C[a];d.high=h,d.low=l}for(a=0;a<5;a++)for(var u=C[(a+4)%5],p=C[(a+1)%5],_=p.high,p=p.low,h=u.high^(_<<1|p>>>31),l=u.low^(p<<1|_>>>31),f=0;f<5;f++)(m=r[a+5*f]).high^=h,m.low^=l;for(var y=1;y<25;y++){var v=(m=r[y]).high,g=m.low,B=A[y];l=B<32?(h=v<<B|g>>>32-B,g<<B|v>>>32-B):(h=g<<B-32|v>>>64-B,v<<B-32|g>>>64-B);B=C[H[y]];B.high=h,B.low=l}var w=C[0],k=r[0];w.high=k.high,w.low=k.low;for(a=0;a<5;a++)for(f=0;f<5;f++){var m=r[y=a+5*f],S=C[y],x=C[(a+1)%5+5*f],b=C[(a+2)%5+5*f];m.high=S.high^~x.high&b.high,m.low=S.low^~x.low&b.low}m=r[0],k=z[c];m.high^=k.high,m.low^=k.low}},_doFinalize:function(){var t=this._data,e=t.words,r=(this._nDataBytes,8*t.sigBytes),i=32*this.blockSize;e[r>>>5]|=1<<24-r%32,e[(l.ceil((1+r)/i)*i>>>5)-1]|=128,t.sigBytes=4*e.length,this._process();for(var n=this._state,e=this.cfg.outputLength/8,o=e/8,s=[],c=0;c<o;c++){var a=n[c],h=a.high,a=a.low,h=16711935&(h<<8|h>>>24)|4278255360&(h<<24|h>>>8);s.push(a=16711935&(a<<8|a>>>24)|4278255360&(a<<24|a>>>8)),s.push(h)}return new f.init(s,e)},clone:function(){for(var t=i.clone.call(this),e=t._state=this._state.slice(0),r=0;r<25;r++)e[r]=e[r].clone();return t}});t.SHA3=i._createHelper(e),t.HmacSHA3=i._createHmacHelper(e)}(Math),Math,F=(w=U).lib,u=F.WordArray,p=F.Hasher,F=w.algo,S=u.create([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13]),x=u.create([5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11]),b=u.create([11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6]),A=u.create([8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11]),H=u.create([0,1518500249,1859775393,2400959708,2840853838]),z=u.create([1352829926,1548603684,1836072691,2053994217,0]),F=F.RIPEMD160=p.extend({_doReset:function(){this._hash=u.create([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(t,e){for(var r=0;r<16;r++){var i=e+r,n=t[i];t[i]=16711935&(n<<8|n>>>24)|4278255360&(n<<24|n>>>8)}for(var o,s,c,a,h,l,f=this._hash.words,d=H.words,u=z.words,p=S.words,_=x.words,y=b.words,v=A.words,g=o=f[0],B=s=f[1],w=c=f[2],k=a=f[3],m=h=f[4],r=0;r<80;r+=1)l=o+t[e+p[r]]|0,l+=r<16?(s^c^a)+d[0]:r<32?K(s,c,a)+d[1]:r<48?((s|~c)^a)+d[2]:r<64?X(s,c,a)+d[3]:(s^(c|~a))+d[4],l=(l=L(l|=0,y[r]))+h|0,o=h,h=a,a=L(c,10),c=s,s=l,l=g+t[e+_[r]]|0,l+=r<16?(B^(w|~k))+u[0]:r<32?X(B,w,k)+u[1]:r<48?((B|~w)^k)+u[2]:r<64?K(B,w,k)+u[3]:(B^w^k)+u[4],l=(l=L(l|=0,v[r]))+m|0,g=m,m=k,k=L(w,10),w=B,B=l;l=f[1]+c+k|0,f[1]=f[2]+a+m|0,f[2]=f[3]+h+g|0,f[3]=f[4]+o+B|0,f[4]=f[0]+s+w|0,f[0]=l},_doFinalize:function(){var t=this._data,e=t.words,r=8*this._nDataBytes,i=8*t.sigBytes;e[i>>>5]|=128<<24-i%32,e[14+(64+i>>>9<<4)]=16711935&(r<<8|r>>>24)|4278255360&(r<<24|r>>>8),t.sigBytes=4*(e.length+1),this._process();for(var e=this._hash,n=e.words,o=0;o<5;o++){var s=n[o];n[o]=16711935&(s<<8|s>>>24)|4278255360&(s<<24|s>>>8)}return e},clone:function(){var t=p.clone.call(this);return t._hash=this._hash.clone(),t}}),w.RIPEMD160=p._createHelper(F),w.HmacRIPEMD160=p._createHmacHelper(F),P=(M=U).lib.Base,_=M.enc.Utf8,M.algo.HMAC=P.extend({init:function(t,e){t=this._hasher=new t.init,"string"==typeof e&&(e=_.parse(e));var r=t.blockSize,i=4*r;(e=e.sigBytes>i?t.finalize(e):e).clamp();for(var t=this._oKey=e.clone(),e=this._iKey=e.clone(),n=t.words,o=e.words,s=0;s<r;s++)n[s]^=1549556828,o[s]^=909522486;t.sigBytes=e.sigBytes=i,this.reset()},reset:function(){var t=this._hasher;t.reset(),t.update(this._iKey)},update:function(t){return this._hasher.update(t),this},finalize:function(t){var e=this._hasher,t=e.finalize(t);return e.reset(),e.finalize(this._oKey.clone().concat(t))}}),F=(w=U).lib,M=F.Base,v=F.WordArray,P=w.algo,F=P.SHA1,g=P.HMAC,y=P.PBKDF2=M.extend({cfg:M.extend({keySize:4,hasher:F,iterations:1}),init:function(t){this.cfg=this.cfg.extend(t)},compute:function(t,e){for(var r=this.cfg,i=g.create(r.hasher,t),n=v.create(),o=v.create([1]),s=n.words,c=o.words,a=r.keySize,h=r.iterations;s.length<a;){var l=i.update(e).finalize(o);i.reset();for(var f=l.words,d=f.length,u=l,p=1;p<h;p++){u=i.finalize(u),i.reset();for(var _=u.words,y=0;y<d;y++)f[y]^=_[y]}n.concat(l),c[0]++}return n.sigBytes=4*a,n}}),w.PBKDF2=function(t,e,r){return y.create(r).compute(t,e)},M=(P=U).lib,F=M.Base,B=M.WordArray,w=P.algo,M=w.MD5,k=w.EvpKDF=F.extend({cfg:F.extend({keySize:4,hasher:M,iterations:1}),init:function(t){this.cfg=this.cfg.extend(t)},compute:function(t,e){for(var r,i=this.cfg,n=i.hasher.create(),o=B.create(),s=o.words,c=i.keySize,a=i.iterations;s.length<c;){r&&n.update(r),r=n.update(t).finalize(e),n.reset();for(var h=1;h<a;h++)r=n.finalize(r),n.reset();o.concat(r)}return o.sigBytes=4*c,o}}),P.EvpKDF=function(t,e,r){return k.create(r).compute(t,e)},U.lib.Cipher||function(){var t=U,e=t.lib,r=e.Base,s=e.WordArray,i=e.BufferedBlockAlgorithm,n=t.enc,o=(n.Utf8,n.Base64),c=t.algo.EvpKDF,a=e.Cipher=i.extend({cfg:r.extend(),createEncryptor:function(t,e){return this.create(this._ENC_XFORM_MODE,t,e)},createDecryptor:function(t,e){return this.create(this._DEC_XFORM_MODE,t,e)},init:function(t,e,r){this.cfg=this.cfg.extend(r),this._xformMode=t,this._key=e,this.reset()},reset:function(){i.reset.call(this),this._doReset()},process:function(t){return this._append(t),this._process()},finalize:function(t){return t&&this._append(t),this._doFinalize()},keySize:4,ivSize:4,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(i){return{encrypt:function(t,e,r){return h(e).encrypt(i,t,e,r)},decrypt:function(t,e,r){return h(e).decrypt(i,t,e,r)}}}});function h(t){return"string"==typeof t?p:u}e.StreamCipher=a.extend({_doFinalize:function(){return this._process(!0)},blockSize:1});var l=t.mode={},n=e.BlockCipherMode=r.extend({createEncryptor:function(t,e){return this.Encryptor.create(t,e)},createDecryptor:function(t,e){return this.Decryptor.create(t,e)},init:function(t,e){this._cipher=t,this._iv=e}}),n=l.CBC=((l=n.extend()).Encryptor=l.extend({processBlock:function(t,e){var r=this._cipher,i=r.blockSize;f.call(this,t,e,i),r.encryptBlock(t,e),this._prevBlock=t.slice(e,e+i)}}),l.Decryptor=l.extend({processBlock:function(t,e){var r=this._cipher,i=r.blockSize,n=t.slice(e,e+i);r.decryptBlock(t,e),f.call(this,t,e,i),this._prevBlock=n}}),l);function f(t,e,r){var i,n=this._iv;n?(i=n,this._iv=void 0):i=this._prevBlock;for(var o=0;o<r;o++)t[e+o]^=i[o]}var l=(t.pad={}).Pkcs7={pad:function(t,e){for(var e=4*e,r=e-t.sigBytes%e,i=r<<24|r<<16|r<<8|r,n=[],o=0;o<r;o+=4)n.push(i);e=s.create(n,r);t.concat(e)},unpad:function(t){var e=255&t.words[t.sigBytes-1>>>2];t.sigBytes-=e}},d=(e.BlockCipher=a.extend({cfg:a.cfg.extend({mode:n,padding:l}),reset:function(){var t;a.reset.call(this);var e=this.cfg,r=e.iv,e=e.mode;this._xformMode==this._ENC_XFORM_MODE?t=e.createEncryptor:(t=e.createDecryptor,this._minBufferSize=1),this._mode&&this._mode.__creator==t?this._mode.init(this,r&&r.words):(this._mode=t.call(e,this,r&&r.words),this._mode.__creator=t)},_doProcessBlock:function(t,e){this._mode.processBlock(t,e)},_doFinalize:function(){var t,e=this.cfg.padding;return this._xformMode==this._ENC_XFORM_MODE?(e.pad(this._data,this.blockSize),t=this._process(!0)):(t=this._process(!0),e.unpad(t)),t},blockSize:4}),e.CipherParams=r.extend({init:function(t){this.mixIn(t)},toString:function(t){return(t||this.formatter).stringify(this)}})),l=(t.format={}).OpenSSL={stringify:function(t){var e=t.ciphertext,t=t.salt,e=t?s.create([1398893684,1701076831]).concat(t).concat(e):e;return e.toString(o)},parse:function(t){var e,r=o.parse(t),t=r.words;return 1398893684==t[0]&&1701076831==t[1]&&(e=s.create(t.slice(2,4)),t.splice(0,4),r.sigBytes-=16),d.create({ciphertext:r,salt:e})}},u=e.SerializableCipher=r.extend({cfg:r.extend({format:l}),encrypt:function(t,e,r,i){i=this.cfg.extend(i);var n=t.createEncryptor(r,i),e=n.finalize(e),n=n.cfg;return d.create({ciphertext:e,key:r,iv:n.iv,algorithm:t,mode:n.mode,padding:n.padding,blockSize:t.blockSize,formatter:i.format})},decrypt:function(t,e,r,i){return i=this.cfg.extend(i),e=this._parse(e,i.format),t.createDecryptor(r,i).finalize(e.ciphertext)},_parse:function(t,e){return"string"==typeof t?e.parse(t,this):t}}),t=(t.kdf={}).OpenSSL={execute:function(t,e,r,i){i=i||s.random(8);t=c.create({keySize:e+r}).compute(t,i),r=s.create(t.words.slice(e),4*r);return t.sigBytes=4*e,d.create({key:t,iv:r,salt:i})}},p=e.PasswordBasedCipher=u.extend({cfg:u.cfg.extend({kdf:t}),encrypt:function(t,e,r,i){r=(i=this.cfg.extend(i)).kdf.execute(r,t.keySize,t.ivSize);i.iv=r.iv;i=u.encrypt.call(this,t,e,r.key,i);return i.mixIn(r),i},decrypt:function(t,e,r,i){i=this.cfg.extend(i),e=this._parse(e,i.format);r=i.kdf.execute(r,t.keySize,t.ivSize,e.salt);return i.iv=r.iv,u.decrypt.call(this,t,e,r.key,i)}})}(),U.mode.CFB=((F=U.lib.BlockCipherMode.extend()).Encryptor=F.extend({processBlock:function(t,e){var r=this._cipher,i=r.blockSize;j.call(this,t,e,i,r),this._prevBlock=t.slice(e,e+i)}}),F.Decryptor=F.extend({processBlock:function(t,e){var r=this._cipher,i=r.blockSize,n=t.slice(e,e+i);j.call(this,t,e,i,r),this._prevBlock=n}}),F),U.mode.CTR=(M=U.lib.BlockCipherMode.extend(),P=M.Encryptor=M.extend({processBlock:function(t,e){var r=this._cipher,i=r.blockSize,n=this._iv,o=this._counter;n&&(o=this._counter=n.slice(0),this._iv=void 0);var s=o.slice(0);r.encryptBlock(s,0),o[i-1]=o[i-1]+1|0;for(var c=0;c<i;c++)t[e+c]^=s[c]}}),M.Decryptor=P,M),U.mode.CTRGladman=(F=U.lib.BlockCipherMode.extend(),P=F.Encryptor=F.extend({processBlock:function(t,e){var r=this._cipher,i=r.blockSize,n=this._iv,o=this._counter;n&&(o=this._counter=n.slice(0),this._iv=void 0),0===((n=o)[0]=T(n[0]))&&(n[1]=T(n[1]));var s=o.slice(0);r.encryptBlock(s,0);for(var c=0;c<i;c++)t[e+c]^=s[c]}}),F.Decryptor=P,F),U.mode.OFB=(M=U.lib.BlockCipherMode.extend(),P=M.Encryptor=M.extend({processBlock:function(t,e){var r=this._cipher,i=r.blockSize,n=this._iv,o=this._keystream;n&&(o=this._keystream=n.slice(0),this._iv=void 0),r.encryptBlock(o,0);for(var s=0;s<i;s++)t[e+s]^=o[s]}}),M.Decryptor=P,M),U.mode.ECB=((F=U.lib.BlockCipherMode.extend()).Encryptor=F.extend({processBlock:function(t,e){this._cipher.encryptBlock(t,e)}}),F.Decryptor=F.extend({processBlock:function(t,e){this._cipher.decryptBlock(t,e)}}),F),U.pad.AnsiX923={pad:function(t,e){var r=t.sigBytes,e=4*e,e=e-r%e,r=r+e-1;t.clamp(),t.words[r>>>2]|=e<<24-r%4*8,t.sigBytes+=e},unpad:function(t){var e=255&t.words[t.sigBytes-1>>>2];t.sigBytes-=e}},U.pad.Iso10126={pad:function(t,e){e*=4,e-=t.sigBytes%e;t.concat(U.lib.WordArray.random(e-1)).concat(U.lib.WordArray.create([e<<24],1))},unpad:function(t){var e=255&t.words[t.sigBytes-1>>>2];t.sigBytes-=e}},U.pad.Iso97971={pad:function(t,e){t.concat(U.lib.WordArray.create([2147483648],1)),U.pad.ZeroPadding.pad(t,e)},unpad:function(t){U.pad.ZeroPadding.unpad(t),t.sigBytes--}},U.pad.ZeroPadding={pad:function(t,e){e*=4;t.clamp(),t.sigBytes+=e-(t.sigBytes%e||e)},unpad:function(t){for(var e=t.words,r=t.sigBytes-1,r=t.sigBytes-1;0<=r;r--)if(e[r>>>2]>>>24-r%4*8&255){t.sigBytes=r+1;break}}},U.pad.NoPadding={pad:function(){},unpad:function(){}},m=(P=U).lib.CipherParams,C=P.enc.Hex,P.format.Hex={stringify:function(t){return t.ciphertext.toString(C)},parse:function(t){t=C.parse(t);return m.create({ciphertext:t})}},function(){var t=U,e=t.lib.BlockCipher,r=t.algo,h=[],l=[],f=[],d=[],u=[],p=[],_=[],y=[],v=[],g=[];!function(){for(var t=[],e=0;e<256;e++)t[e]=e<128?e<<1:e<<1^283;for(var r=0,i=0,e=0;e<256;e++){var n=i^i<<1^i<<2^i<<3^i<<4;h[r]=n=n>>>8^255&n^99;var o=t[l[n]=r],s=t[o],c=t[s],a=257*t[n]^16843008*n;f[r]=a<<24|a>>>8,d[r]=a<<16|a>>>16,u[r]=a<<8|a>>>24,p[r]=a,_[n]=(a=16843009*c^65537*s^257*o^16843008*r)<<24|a>>>8,y[n]=a<<16|a>>>16,v[n]=a<<8|a>>>24,g[n]=a,r?(r=o^t[t[t[c^o]]],i^=t[t[i]]):r=i=1}}();var B=[0,1,2,4,8,16,32,64,128,27,54],r=r.AES=e.extend({_doReset:function(){if(!this._nRounds||this._keyPriorReset!==this._key){for(var t=this._keyPriorReset=this._key,e=t.words,r=t.sigBytes/4,i=4*(1+(this._nRounds=6+r)),n=this._keySchedule=[],o=0;o<i;o++)o<r?n[o]=e[o]:(a=n[o-1],o%r?6<r&&o%r==4&&(a=h[a>>>24]<<24|h[a>>>16&255]<<16|h[a>>>8&255]<<8|h[255&a]):(a=h[(a=a<<8|a>>>24)>>>24]<<24|h[a>>>16&255]<<16|h[a>>>8&255]<<8|h[255&a],a^=B[o/r|0]<<24),n[o]=n[o-r]^a);for(var s=this._invKeySchedule=[],c=0;c<i;c++){var a,o=i-c;a=c%4?n[o]:n[o-4],s[c]=c<4||o<=4?a:_[h[a>>>24]]^y[h[a>>>16&255]]^v[h[a>>>8&255]]^g[h[255&a]]}}},encryptBlock:function(t,e){this._doCryptBlock(t,e,this._keySchedule,f,d,u,p,h)},decryptBlock:function(t,e){var r=t[e+1];t[e+1]=t[e+3],t[e+3]=r,this._doCryptBlock(t,e,this._invKeySchedule,_,y,v,g,l);r=t[e+1];t[e+1]=t[e+3],t[e+3]=r},_doCryptBlock:function(t,e,r,i,n,o,s,c){for(var a=this._nRounds,h=t[e]^r[0],l=t[e+1]^r[1],f=t[e+2]^r[2],d=t[e+3]^r[3],u=4,p=1;p<a;p++)var _=i[h>>>24]^n[l>>>16&255]^o[f>>>8&255]^s[255&d]^r[u++],y=i[l>>>24]^n[f>>>16&255]^o[d>>>8&255]^s[255&h]^r[u++],v=i[f>>>24]^n[d>>>16&255]^o[h>>>8&255]^s[255&l]^r[u++],g=i[d>>>24]^n[h>>>16&255]^o[l>>>8&255]^s[255&f]^r[u++],h=_,l=y,f=v,d=g;_=(c[h>>>24]<<24|c[l>>>16&255]<<16|c[f>>>8&255]<<8|c[255&d])^r[u++],y=(c[l>>>24]<<24|c[f>>>16&255]<<16|c[d>>>8&255]<<8|c[255&h])^r[u++],v=(c[f>>>24]<<24|c[d>>>16&255]<<16|c[h>>>8&255]<<8|c[255&l])^r[u++],g=(c[d>>>24]<<24|c[h>>>16&255]<<16|c[l>>>8&255]<<8|c[255&f])^r[u++];t[e]=_,t[e+1]=y,t[e+2]=v,t[e+3]=g},keySize:8});t.AES=e._createHelper(r)}(),function(){var t=U,e=t.lib,i=e.WordArray,r=e.BlockCipher,e=t.algo,h=[57,49,41,33,25,17,9,1,58,50,42,34,26,18,10,2,59,51,43,35,27,19,11,3,60,52,44,36,63,55,47,39,31,23,15,7,62,54,46,38,30,22,14,6,61,53,45,37,29,21,13,5,28,20,12,4],l=[14,17,11,24,1,5,3,28,15,6,21,10,23,19,12,4,26,8,16,7,27,20,13,2,41,52,31,37,47,55,30,40,51,45,33,48,44,49,39,56,34,53,46,42,50,36,29,32],f=[1,2,4,6,8,10,12,14,15,17,19,21,23,25,27,28],d=[{0:8421888,268435456:32768,536870912:8421378,805306368:2,1073741824:512,1342177280:8421890,1610612736:8389122,1879048192:8388608,2147483648:514,2415919104:8389120,2684354560:33280,2952790016:8421376,3221225472:32770,3489660928:8388610,3758096384:0,4026531840:33282,134217728:0,402653184:8421890,671088640:33282,939524096:32768,1207959552:8421888,1476395008:512,1744830464:8421378,2013265920:2,2281701376:8389120,2550136832:33280,2818572288:8421376,3087007744:8389122,3355443200:8388610,3623878656:32770,3892314112:514,4160749568:8388608,1:32768,268435457:2,536870913:8421888,805306369:8388608,1073741825:8421378,1342177281:33280,1610612737:512,1879048193:8389122,2147483649:8421890,2415919105:8421376,2684354561:8388610,2952790017:33282,3221225473:514,3489660929:8389120,3758096385:32770,4026531841:0,134217729:8421890,402653185:8421376,671088641:8388608,939524097:512,1207959553:32768,1476395009:8388610,1744830465:2,2013265921:33282,2281701377:32770,2550136833:8389122,2818572289:514,3087007745:8421888,3355443201:8389120,3623878657:0,3892314113:33280,4160749569:8421378},{0:1074282512,16777216:16384,33554432:524288,50331648:1074266128,67108864:1073741840,83886080:1074282496,100663296:1073758208,117440512:16,134217728:540672,150994944:1073758224,167772160:1073741824,184549376:540688,201326592:524304,218103808:0,234881024:16400,251658240:1074266112,8388608:1073758208,25165824:540688,41943040:16,58720256:1073758224,75497472:1074282512,92274688:1073741824,109051904:524288,125829120:1074266128,142606336:524304,159383552:0,176160768:16384,192937984:1074266112,209715200:1073741840,226492416:540672,243269632:1074282496,260046848:16400,268435456:0,285212672:1074266128,301989888:1073758224,318767104:1074282496,335544320:1074266112,352321536:16,369098752:540688,385875968:16384,402653184:16400,419430400:524288,436207616:524304,452984832:1073741840,469762048:540672,486539264:1073758208,503316480:1073741824,520093696:1074282512,276824064:540688,293601280:524288,310378496:1074266112,327155712:16384,343932928:1073758208,360710144:1074282512,377487360:16,394264576:1073741824,411041792:1074282496,427819008:1073741840,444596224:1073758224,461373440:524304,478150656:0,494927872:16400,511705088:1074266128,528482304:540672},{0:260,1048576:0,2097152:67109120,3145728:65796,4194304:65540,5242880:67108868,6291456:67174660,7340032:67174400,8388608:67108864,9437184:67174656,10485760:65792,11534336:67174404,12582912:67109124,13631488:65536,14680064:4,15728640:256,524288:67174656,1572864:67174404,2621440:0,3670016:67109120,4718592:67108868,5767168:65536,6815744:65540,7864320:260,8912896:4,9961472:256,11010048:67174400,12058624:65796,13107200:65792,14155776:67109124,15204352:67174660,16252928:67108864,16777216:67174656,17825792:65540,18874368:65536,19922944:67109120,20971520:256,22020096:67174660,23068672:67108868,24117248:0,25165824:67109124,26214400:67108864,27262976:4,28311552:65792,29360128:67174400,30408704:260,31457280:65796,32505856:67174404,17301504:67108864,18350080:260,19398656:67174656,20447232:0,21495808:65540,22544384:67109120,23592960:256,24641536:67174404,25690112:65536,26738688:67174660,27787264:65796,28835840:67108868,29884416:67109124,30932992:67174400,31981568:4,33030144:65792},{0:2151682048,65536:2147487808,131072:4198464,196608:2151677952,262144:0,327680:4198400,393216:2147483712,458752:4194368,524288:2147483648,589824:4194304,655360:64,720896:2147487744,786432:2151678016,851968:4160,917504:4096,983040:2151682112,32768:2147487808,98304:64,163840:2151678016,229376:2147487744,294912:4198400,360448:2151682112,425984:0,491520:2151677952,557056:4096,622592:2151682048,688128:4194304,753664:4160,819200:2147483648,884736:4194368,950272:4198464,1015808:2147483712,1048576:4194368,1114112:4198400,1179648:2147483712,1245184:0,1310720:4160,1376256:2151678016,1441792:2151682048,1507328:2147487808,1572864:2151682112,1638400:2147483648,1703936:2151677952,1769472:4198464,1835008:2147487744,1900544:4194304,1966080:64,2031616:4096,1081344:2151677952,1146880:2151682112,1212416:0,1277952:4198400,1343488:4194368,1409024:2147483648,1474560:2147487808,1540096:64,1605632:2147483712,1671168:4096,1736704:2147487744,1802240:2151678016,1867776:4160,1933312:2151682048,1998848:4194304,2064384:4198464},{0:128,4096:17039360,8192:262144,12288:536870912,16384:537133184,20480:16777344,24576:553648256,28672:262272,32768:16777216,36864:537133056,40960:536871040,45056:553910400,49152:553910272,53248:0,57344:17039488,61440:553648128,2048:17039488,6144:553648256,10240:128,14336:17039360,18432:262144,22528:537133184,26624:553910272,30720:536870912,34816:537133056,38912:0,43008:553910400,47104:16777344,51200:536871040,55296:553648128,59392:16777216,63488:262272,65536:262144,69632:128,73728:536870912,77824:553648256,81920:16777344,86016:553910272,90112:537133184,94208:16777216,98304:553910400,102400:553648128,106496:17039360,110592:537133056,114688:262272,118784:536871040,122880:0,126976:17039488,67584:553648256,71680:16777216,75776:17039360,79872:537133184,83968:536870912,88064:17039488,92160:128,96256:553910272,100352:262272,104448:553910400,108544:0,112640:553648128,116736:16777344,120832:262144,124928:537133056,129024:536871040},{0:268435464,256:8192,512:270532608,768:270540808,1024:268443648,1280:2097152,1536:2097160,1792:268435456,2048:0,2304:268443656,2560:2105344,2816:8,3072:270532616,3328:2105352,3584:8200,3840:270540800,128:270532608,384:270540808,640:8,896:2097152,1152:2105352,1408:268435464,1664:268443648,1920:8200,2176:2097160,2432:8192,2688:268443656,2944:270532616,3200:0,3456:270540800,3712:2105344,3968:268435456,4096:268443648,4352:270532616,4608:270540808,4864:8200,5120:2097152,5376:268435456,5632:268435464,5888:2105344,6144:2105352,6400:0,6656:8,6912:270532608,7168:8192,7424:268443656,7680:270540800,7936:2097160,4224:8,4480:2105344,4736:2097152,4992:268435464,5248:268443648,5504:8200,5760:270540808,6016:270532608,6272:270540800,6528:270532616,6784:8192,7040:2105352,7296:2097160,7552:0,7808:268435456,8064:268443656},{0:1048576,16:33555457,32:1024,48:1049601,64:34604033,80:0,96:1,112:34603009,128:33555456,144:1048577,160:33554433,176:34604032,192:34603008,208:1025,224:1049600,240:33554432,8:34603009,24:0,40:33555457,56:34604032,72:1048576,88:33554433,104:33554432,120:1025,136:1049601,152:33555456,168:34603008,184:1048577,200:1024,216:34604033,232:1,248:1049600,256:33554432,272:1048576,288:33555457,304:34603009,320:1048577,336:33555456,352:34604032,368:1049601,384:1025,400:34604033,416:1049600,432:1,448:0,464:34603008,480:33554433,496:1024,264:1049600,280:33555457,296:34603009,312:1,328:33554432,344:1048576,360:1025,376:34604032,392:33554433,408:34603008,424:0,440:34604033,456:1049601,472:1024,488:33555456,504:1048577},{0:134219808,1:131072,2:134217728,3:32,4:131104,5:134350880,6:134350848,7:2048,8:134348800,9:134219776,10:133120,11:134348832,12:2080,13:0,14:134217760,15:133152,2147483648:2048,2147483649:134350880,2147483650:134219808,2147483651:134217728,2147483652:134348800,2147483653:133120,2147483654:133152,2147483655:32,2147483656:134217760,2147483657:2080,2147483658:131104,2147483659:134350848,2147483660:0,2147483661:134348832,2147483662:134219776,2147483663:131072,16:133152,17:134350848,18:32,19:2048,20:134219776,21:134217760,22:134348832,23:131072,24:0,25:131104,26:134348800,27:134219808,28:134350880,29:133120,30:2080,31:134217728,2147483664:131072,2147483665:2048,2147483666:134348832,2147483667:133152,2147483668:32,2147483669:134348800,2147483670:134217728,2147483671:134219808,2147483672:134350880,2147483673:134217760,2147483674:134219776,2147483675:0,2147483676:133120,2147483677:2080,2147483678:131104,2147483679:134350848}],u=[4160749569,528482304,33030144,2064384,129024,8064,504,2147483679],n=e.DES=r.extend({_doReset:function(){for(var t=this._key.words,e=[],r=0;r<56;r++){var i=h[r]-1;e[r]=t[i>>>5]>>>31-i%32&1}for(var n=this._subKeys=[],o=0;o<16;o++){for(var s=n[o]=[],c=f[o],r=0;r<24;r++)s[r/6|0]|=e[(l[r]-1+c)%28]<<31-r%6,s[4+(r/6|0)]|=e[28+(l[r+24]-1+c)%28]<<31-r%6;s[0]=s[0]<<1|s[0]>>>31;for(r=1;r<7;r++)s[r]=s[r]>>>4*(r-1)+3;s[7]=s[7]<<5|s[7]>>>27}for(var a=this._invSubKeys=[],r=0;r<16;r++)a[r]=n[15-r]},encryptBlock:function(t,e){this._doCryptBlock(t,e,this._subKeys)},decryptBlock:function(t,e){this._doCryptBlock(t,e,this._invSubKeys)},_doCryptBlock:function(t,e,r){this._lBlock=t[e],this._rBlock=t[e+1],p.call(this,4,252645135),p.call(this,16,65535),_.call(this,2,858993459),_.call(this,8,16711935),p.call(this,1,1431655765);for(var i=0;i<16;i++){for(var n=r[i],o=this._lBlock,s=this._rBlock,c=0,a=0;a<8;a++)c|=d[a][((s^n[a])&u[a])>>>0];this._lBlock=s,this._rBlock=o^c}var h=this._lBlock;this._lBlock=this._rBlock,this._rBlock=h,p.call(this,1,1431655765),_.call(this,8,16711935),_.call(this,2,858993459),p.call(this,16,65535),p.call(this,4,252645135),t[e]=this._lBlock,t[e+1]=this._rBlock},keySize:2,ivSize:2,blockSize:2});function p(t,e){e=(this._lBlock>>>t^this._rBlock)&e;this._rBlock^=e,this._lBlock^=e<<t}function _(t,e){e=(this._rBlock>>>t^this._lBlock)&e;this._lBlock^=e,this._rBlock^=e<<t}t.DES=r._createHelper(n);e=e.TripleDES=r.extend({_doReset:function(){var t=this._key.words;if(2!==t.length&&4!==t.length&&t.length<6)throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");var e=t.slice(0,2),r=t.length<4?t.slice(0,2):t.slice(2,4),t=t.length<6?t.slice(0,2):t.slice(4,6);this._des1=n.createEncryptor(i.create(e)),this._des2=n.createEncryptor(i.create(r)),this._des3=n.createEncryptor(i.create(t))},encryptBlock:function(t,e){this._des1.encryptBlock(t,e),this._des2.decryptBlock(t,e),this._des3.encryptBlock(t,e)},decryptBlock:function(t,e){this._des3.decryptBlock(t,e),this._des2.encryptBlock(t,e),this._des1.decryptBlock(t,e)},keySize:6,ivSize:2,blockSize:2});t.TripleDES=r._createHelper(e)}(),function(){var t=U,e=t.lib.StreamCipher,r=t.algo,i=r.RC4=e.extend({_doReset:function(){for(var t=this._key,e=t.words,r=t.sigBytes,i=this._S=[],n=0;n<256;n++)i[n]=n;for(var n=0,o=0;n<256;n++){var s=n%r,s=e[s>>>2]>>>24-s%4*8&255,o=(o+i[n]+s)%256,s=i[n];i[n]=i[o],i[o]=s}this._i=this._j=0},_doProcessBlock:function(t,e){t[e]^=n.call(this)},keySize:8,ivSize:0});function n(){for(var t=this._S,e=this._i,r=this._j,i=0,n=0;n<4;n++){var r=(r+t[e=(e+1)%256])%256,o=t[e];t[e]=t[r],t[r]=o,i|=t[(t[e]+t[r])%256]<<24-8*n}return this._i=e,this._j=r,i}t.RC4=e._createHelper(i);r=r.RC4Drop=i.extend({cfg:i.cfg.extend({drop:192}),_doReset:function(){i._doReset.call(this);for(var t=this.cfg.drop;0<t;t--)n.call(this)}});t.RC4Drop=e._createHelper(r)}(),F=(M=U).lib.StreamCipher,P=M.algo,D=[],E=[],R=[],P=P.Rabbit=F.extend({_doReset:function(){for(var t=this._key.words,e=this.cfg.iv,r=0;r<4;r++)t[r]=16711935&(t[r]<<8|t[r]>>>24)|4278255360&(t[r]<<24|t[r]>>>8);for(var i=this._X=[t[0],t[3]<<16|t[2]>>>16,t[1],t[0]<<16|t[3]>>>16,t[2],t[1]<<16|t[0]>>>16,t[3],t[2]<<16|t[1]>>>16],n=this._C=[t[2]<<16|t[2]>>>16,4294901760&t[0]|65535&t[1],t[3]<<16|t[3]>>>16,4294901760&t[1]|65535&t[2],t[0]<<16|t[0]>>>16,4294901760&t[2]|65535&t[3],t[1]<<16|t[1]>>>16,4294901760&t[3]|65535&t[0]],r=this._b=0;r<4;r++)N.call(this);for(r=0;r<8;r++)n[r]^=i[r+4&7];if(e){var o=e.words,s=o[0],c=o[1],e=16711935&(s<<8|s>>>24)|4278255360&(s<<24|s>>>8),o=16711935&(c<<8|c>>>24)|4278255360&(c<<24|c>>>8),s=e>>>16|4294901760&o,c=o<<16|65535&e;n[0]^=e,n[1]^=s,n[2]^=o,n[3]^=c,n[4]^=e,n[5]^=s,n[6]^=o,n[7]^=c;for(r=0;r<4;r++)N.call(this)}},_doProcessBlock:function(t,e){var r=this._X;N.call(this),D[0]=r[0]^r[5]>>>16^r[3]<<16,D[1]=r[2]^r[7]>>>16^r[5]<<16,D[2]=r[4]^r[1]>>>16^r[7]<<16,D[3]=r[6]^r[3]>>>16^r[1]<<16;for(var i=0;i<4;i++)D[i]=16711935&(D[i]<<8|D[i]>>>24)|4278255360&(D[i]<<24|D[i]>>>8),t[e+i]^=D[i]},blockSize:4,ivSize:2}),M.Rabbit=F._createHelper(P),F=(M=U).lib.StreamCipher,P=M.algo,W=[],O=[],I=[],P=P.RabbitLegacy=F.extend({_doReset:function(){for(var t=this._key.words,e=this.cfg.iv,r=this._X=[t[0],t[3]<<16|t[2]>>>16,t[1],t[0]<<16|t[3]>>>16,t[2],t[1]<<16|t[0]>>>16,t[3],t[2]<<16|t[1]>>>16],i=this._C=[t[2]<<16|t[2]>>>16,4294901760&t[0]|65535&t[1],t[3]<<16|t[3]>>>16,4294901760&t[1]|65535&t[2],t[0]<<16|t[0]>>>16,4294901760&t[2]|65535&t[3],t[1]<<16|t[1]>>>16,4294901760&t[3]|65535&t[0]],n=this._b=0;n<4;n++)q.call(this);for(n=0;n<8;n++)i[n]^=r[n+4&7];if(e){var o=e.words,s=o[0],t=o[1],e=16711935&(s<<8|s>>>24)|4278255360&(s<<24|s>>>8),o=16711935&(t<<8|t>>>24)|4278255360&(t<<24|t>>>8),s=e>>>16|4294901760&o,t=o<<16|65535&e;i[0]^=e,i[1]^=s,i[2]^=o,i[3]^=t,i[4]^=e,i[5]^=s,i[6]^=o,i[7]^=t;for(n=0;n<4;n++)q.call(this)}},_doProcessBlock:function(t,e){var r=this._X;q.call(this),W[0]=r[0]^r[5]>>>16^r[3]<<16,W[1]=r[2]^r[7]>>>16^r[5]<<16,W[2]=r[4]^r[1]>>>16^r[7]<<16,W[3]=r[6]^r[3]>>>16^r[1]<<16;for(var i=0;i<4;i++)W[i]=16711935&(W[i]<<8|W[i]>>>24)|4278255360&(W[i]<<24|W[i]>>>8),t[e+i]^=W[i]},blockSize:4,ivSize:2}),M.RabbitLegacy=F._createHelper(P),U});
    </script>
    
    <!-- 
    Library: Elliptic v6.5.4
    Description: Fast elliptic curve cryptography in JavaScript
    Source: https://github.com/indutny/elliptic
    License: MIT License
    Downloaded from: https://cdnjs.cloudflare.com/ajax/libs/elliptic/6.5.4/elliptic.min.js
    Last verified: April 23, 2025
    -->
    <script>
        !function(e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).elliptic=e()}(function(){return function r(f,d,n){function a(t,e){if(!d[t]){if(!f[t]){var i="function"==typeof require&&require;if(!e&&i)return i(t,!0);if(s)return s(t,!0);throw(i=new Error("Cannot find module '"+t+"'")).code="MODULE_NOT_FOUND",i}i=d[t]={exports:{}},f[t][0].call(i.exports,function(e){return a(f[t][1][e]||e)},i,i.exports,r,f,d,n)}return d[t].exports}for(var s="function"==typeof require&&require,e=0;e<n.length;e++)a(n[e]);return a}({1:[function(e,t,i){"use strict";i.version=e("../package.json").version,i.utils=e("./elliptic/utils"),i.rand=e("brorand"),i.curve=e("./elliptic/curve"),i.curves=e("./elliptic/curves"),i.ec=e("./elliptic/ec"),i.eddsa=e("./elliptic/eddsa")},{"../package.json":35,"./elliptic/curve":4,"./elliptic/curves":7,"./elliptic/ec":8,"./elliptic/eddsa":11,"./elliptic/utils":15,brorand:17}],2:[function(e,t,i){"use strict";var r=e("bn.js"),f=e("../utils"),x=f.getNAF,I=f.getJSF,o=f.assert;function d(e,t){this.type=e,this.p=new r(t.p,16),this.red=t.prime?r.red(t.prime):r.mont(this.p),this.zero=new r(0).toRed(this.red),this.one=new r(1).toRed(this.red),this.two=new r(2).toRed(this.red),this.n=t.n&&new r(t.n,16),this.g=t.g&&this.pointFromJSON(t.g,t.gRed),this._wnafT1=new Array(4),this._wnafT2=new Array(4),this._wnafT3=new Array(4),this._wnafT4=new Array(4),this._bitLength=this.n?this.n.bitLength():0;t=this.n&&this.p.div(this.n);!t||0<t.cmpn(100)?this.redN=null:(this._maxwellTrick=!0,this.redN=this.n.toRed(this.red))}function n(e,t){this.curve=e,this.type=t,this.precomputed=null}(t.exports=d).prototype.point=function(){throw new Error("Not implemented")},d.prototype.validate=function(){throw new Error("Not implemented")},d.prototype._fixedNafMul=function(e,t){o(e.precomputed);var i=e._getDoubles(),r=x(t,1,this._bitLength),t=(1<<i.step+1)-(i.step%2==0?2:1);t/=3;for(var f,d=[],n=0;n<r.length;n+=i.step){f=0;for(var a=n+i.step-1;n<=a;a--)f=(f<<1)+r[a];d.push(f)}for(var s=this.jpoint(null,null,null),c=this.jpoint(null,null,null),h=t;0<h;h--){for(n=0;n<d.length;n++)(f=d[n])===h?c=c.mixedAdd(i.points[n]):f===-h&&(c=c.mixedAdd(i.points[n].neg()));s=s.add(c)}return s.toP()},d.prototype._wnafMul=function(e,t){for(var i=e._getNAFPoints(4),r=i.wnd,f=i.points,d=x(t,r,this._bitLength),n=this.jpoint(null,null,null),a=d.length-1;0<=a;a--){for(var s=0;0<=a&&0===d[a];a--)s++;if(0<=a&&s++,n=n.dblp(s),a<0)break;var c=d[a];o(0!==c),n="affine"===e.type?0<c?n.mixedAdd(f[c-1>>1]):n.mixedAdd(f[-c-1>>1].neg()):0<c?n.add(f[c-1>>1]):n.add(f[-c-1>>1].neg())}return"affine"===e.type?n.toP():n},d.prototype._wnafMulAdd=function(e,t,i,r,f){for(var d,n=this._wnafT1,a=this._wnafT2,s=this._wnafT3,c=0,h=0;h<r;h++){var o=(d=t[h])._getNAFPoints(e);n[h]=o.wnd,a[h]=o.points}for(h=r-1;1<=h;h-=2){var u=h-1,b=h;if(1===n[u]&&1===n[b]){var l=[t[u],null,null,t[b]];0===t[u].y.cmp(t[b].y)?(l[1]=t[u].add(t[b]),l[2]=t[u].toJ().mixedAdd(t[b].neg())):0===t[u].y.cmp(t[b].y.redNeg())?(l[1]=t[u].toJ().mixedAdd(t[b]),l[2]=t[u].add(t[b].neg())):(l[1]=t[u].toJ().mixedAdd(t[b]),l[2]=t[u].toJ().mixedAdd(t[b].neg()));var p=[-3,-1,-5,-7,0,7,5,1,3],m=I(i[u],i[b]),c=Math.max(m[0].length,c);for(s[u]=new Array(c),s[b]=new Array(c),_=0;_<c;_++){var v=0|m[0][_],g=0|m[1][_];s[u][_]=p[3*(1+v)+(1+g)],s[b][_]=0,a[u]=l}}else s[u]=x(i[u],n[u],this._bitLength),s[b]=x(i[b],n[b],this._bitLength),c=Math.max(s[u].length,c),c=Math.max(s[b].length,c)}var y=this.jpoint(null,null,null),M=this._wnafT4;for(h=c;0<=h;h--){for(var w=0;0<=h;){for(var S=!0,_=0;_<r;_++)M[_]=0|s[_][h],0!==M[_]&&(S=!1);if(!S)break;w++,h--}if(0<=h&&w++,y=y.dblp(w),h<0)break;for(_=0;_<r;_++){var A=M[_];0!==A&&(0<A?d=a[_][A-1>>1]:A<0&&(d=a[_][-A-1>>1].neg()),y="affine"===d.type?y.mixedAdd(d):y.add(d))}}for(h=0;h<r;h++)a[h]=null;return f?y:y.toP()},(d.BasePoint=n).prototype.eq=function(){throw new Error("Not implemented")},n.prototype.validate=function(){return this.curve.validate(this)},d.prototype.decodePoint=function(e,t){e=f.toArray(e,t);t=this.p.byteLength();if((4===e[0]||6===e[0]||7===e[0])&&e.length-1==2*t)return 6===e[0]?o(e[e.length-1]%2==0):7===e[0]&&o(e[e.length-1]%2==1),this.point(e.slice(1,1+t),e.slice(1+t,1+2*t));if((2===e[0]||3===e[0])&&e.length-1===t)return this.pointFromX(e.slice(1,1+t),3===e[0]);throw new Error("Unknown point format")},n.prototype.encodeCompressed=function(e){return this.encode(e,!0)},n.prototype._encode=function(e){var t=this.curve.p.byteLength(),i=this.getX().toArray("be",t);return e?[this.getY().isEven()?2:3].concat(i):[4].concat(i,this.getY().toArray("be",t))},n.prototype.encode=function(e,t){return f.encode(this._encode(t),e)},n.prototype.precompute=function(e){if(this.precomputed)return this;var t={doubles:null,naf:null,beta:null};return t.naf=this._getNAFPoints(8),t.doubles=this._getDoubles(4,e),t.beta=this._getBeta(),this.precomputed=t,this},n.prototype._hasDoubles=function(e){if(!this.precomputed)return!1;var t=this.precomputed.doubles;return!!t&&t.points.length>=Math.ceil((e.bitLength()+1)/t.step)},n.prototype._getDoubles=function(e,t){if(this.precomputed&&this.precomputed.doubles)return this.precomputed.doubles;for(var i=[this],r=this,f=0;f<t;f+=e){for(var d=0;d<e;d++)r=r.dbl();i.push(r)}return{step:e,points:i}},n.prototype._getNAFPoints=function(e){if(this.precomputed&&this.precomputed.naf)return this.precomputed.naf;for(var t=[this],i=(1<<e)-1,r=1==i?null:this.dbl(),f=1;f<i;f++)t[f]=t[f-1].add(r);return{wnd:e,points:t}},n.prototype._getBeta=function(){return null},n.prototype.dblp=function(e){for(var t=this,i=0;i<e;i++)t=t.dbl();return t}},{"../utils":15,"bn.js":16}],3:[function(e,t,i){"use strict";var r=e("../utils"),d=e("bn.js"),f=e("inherits"),n=e("./base"),a=r.assert;function s(e){this.twisted=1!=(0|e.a),this.mOneA=this.twisted&&-1==(0|e.a),this.extended=this.mOneA,n.call(this,"edwards",e),this.a=new d(e.a,16).umod(this.red.m),this.a=this.a.toRed(this.red),this.c=new d(e.c,16).toRed(this.red),this.c2=this.c.redSqr(),this.d=new d(e.d,16).toRed(this.red),this.dd=this.d.redAdd(this.d),a(!this.twisted||0===this.c.fromRed().cmpn(1)),this.oneC=1==(0|e.c)}function c(e,t,i,r,f){n.BasePoint.call(this,e,"projective"),null===t&&null===i&&null===r?(this.x=this.curve.zero,this.y=this.curve.one,this.z=this.curve.one,this.t=this.curve.zero,this.zOne=!0):(this.x=new d(t,16),this.y=new d(i,16),this.z=r?new d(r,16):this.curve.one,this.t=f&&new d(f,16),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.z.red||(this.z=this.z.toRed(this.curve.red)),this.t&&!this.t.red&&(this.t=this.t.toRed(this.curve.red)),this.zOne=this.z===this.curve.one,this.curve.extended&&!this.t&&(this.t=this.x.redMul(this.y),this.zOne||(this.t=this.t.redMul(this.z.redInvm()))))}f(s,n),(t.exports=s).prototype._mulA=function(e){return this.mOneA?e.redNeg():this.a.redMul(e)},s.prototype._mulC=function(e){return this.oneC?e:this.c.redMul(e)},s.prototype.jpoint=function(e,t,i,r){return this.point(e,t,i,r)},s.prototype.pointFromX=function(e,t){var i=(e=!(e=new d(e,16)).red?e.toRed(this.red):e).redSqr(),r=this.c2.redSub(this.a.redMul(i)),i=this.one.redSub(this.c2.redMul(this.d).redMul(i)),r=r.redMul(i.redInvm()),i=r.redSqrt();if(0!==i.redSqr().redSub(r).cmp(this.zero))throw new Error("invalid point");r=i.fromRed().isOdd();return(t&&!r||!t&&r)&&(i=i.redNeg()),this.point(e,i)},s.prototype.pointFromY=function(e,t){var i=(e=!(e=new d(e,16)).red?e.toRed(this.red):e).redSqr(),r=i.redSub(this.c2),i=i.redMul(this.d).redMul(this.c2).redSub(this.a),r=r.redMul(i.redInvm());if(0===r.cmp(this.zero)){if(t)throw new Error("invalid point");return this.point(this.zero,e)}i=r.redSqrt();if(0!==i.redSqr().redSub(r).cmp(this.zero))throw new Error("invalid point");return i.fromRed().isOdd()!==t&&(i=i.redNeg()),this.point(i,e)},s.prototype.validate=function(e){if(e.isInfinity())return!0;e.normalize();var t=e.x.redSqr(),i=e.y.redSqr(),e=t.redMul(this.a).redAdd(i),i=this.c2.redMul(this.one.redAdd(this.d.redMul(t).redMul(i)));return 0===e.cmp(i)},f(c,n.BasePoint),s.prototype.pointFromJSON=function(e){return c.fromJSON(this,e)},s.prototype.point=function(e,t,i,r){return new c(this,e,t,i,r)},c.fromJSON=function(e,t){return new c(e,t[0],t[1],t[2])},c.prototype.inspect=function(){return this.isInfinity()?"<EC Point Infinity>":"<EC Point x: "+this.x.fromRed().toString(16,2)+" y: "+this.y.fromRed().toString(16,2)+" z: "+this.z.fromRed().toString(16,2)+">"},c.prototype.isInfinity=function(){return 0===this.x.cmpn(0)&&(0===this.y.cmp(this.z)||this.zOne&&0===this.y.cmp(this.curve.c))},c.prototype._extDbl=function(){var e=this.x.redSqr(),t=this.y.redSqr(),i=(i=this.z.redSqr()).redIAdd(i),r=this.curve._mulA(e),f=this.x.redAdd(this.y).redSqr().redISub(e).redISub(t),d=r.redAdd(t),e=d.redSub(i),i=r.redSub(t),r=f.redMul(e),t=d.redMul(i),i=f.redMul(i),d=e.redMul(d);return this.curve.point(r,t,d,i)},c.prototype._projDbl=function(){var e,t,i,r,f,d,n=this.x.redAdd(this.y).redSqr(),a=this.x.redSqr(),s=this.y.redSqr();return d=this.curve.twisted?(f=(i=this.curve._mulA(a)).redAdd(s),this.zOne?(e=n.redSub(a).redSub(s).redMul(f.redSub(this.curve.two)),t=f.redMul(i.redSub(s)),f.redSqr().redSub(f).redSub(f)):(r=this.z.redSqr(),d=f.redSub(r).redISub(r),e=n.redSub(a).redISub(s).redMul(d),t=f.redMul(i.redSub(s)),f.redMul(d))):(i=a.redAdd(s),r=this.curve._mulC(this.z).redSqr(),d=i.redSub(r).redSub(r),e=this.curve._mulC(n.redISub(i)).redMul(d),t=this.curve._mulC(i).redMul(a.redISub(s)),i.redMul(d)),this.curve.point(e,t,d)},c.prototype.dbl=function(){return this.isInfinity()?this:this.curve.extended?this._extDbl():this._projDbl()},c.prototype._extAdd=function(e){var t=this.y.redSub(this.x).redMul(e.y.redSub(e.x)),i=this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)),r=this.t.redMul(this.curve.dd).redMul(e.t),f=this.z.redMul(e.z.redAdd(e.z)),d=i.redSub(t),e=f.redSub(r),f=f.redAdd(r),r=i.redAdd(t),i=d.redMul(e),t=f.redMul(r),r=d.redMul(r),f=e.redMul(f);return this.curve.point(i,t,f,r)},c.prototype._projAdd=function(e){var t,i=this.z.redMul(e.z),r=i.redSqr(),f=this.x.redMul(e.x),d=this.y.redMul(e.y),n=this.curve.d.redMul(f).redMul(d),a=r.redSub(n),n=r.redAdd(n),e=this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(f).redISub(d),e=i.redMul(a).redMul(e),n=this.curve.twisted?(t=i.redMul(n).redMul(d.redSub(this.curve._mulA(f))),a.redMul(n)):(t=i.redMul(n).redMul(d.redSub(f)),this.curve._mulC(a).redMul(n));return this.curve.point(e,t,n)},c.prototype.add=function(e){return this.isInfinity()?e:e.isInfinity()?this:this.curve.extended?this._extAdd(e):this._projAdd(e)},c.prototype.mul=function(e){return this._hasDoubles(e)?this.curve._fixedNafMul(this,e):this.curve._wnafMul(this,e)},c.prototype.mulAdd=function(e,t,i){return this.curve._wnafMulAdd(1,[this,t],[e,i],2,!1)},c.prototype.jmulAdd=function(e,t,i){return this.curve._wnafMulAdd(1,[this,t],[e,i],2,!0)},c.prototype.normalize=function(){if(this.zOne)return this;var e=this.z.redInvm();return this.x=this.x.redMul(e),this.y=this.y.redMul(e),this.t&&(this.t=this.t.redMul(e)),this.z=this.curve.one,this.zOne=!0,this},c.prototype.neg=function(){return this.curve.point(this.x.redNeg(),this.y,this.z,this.t&&this.t.redNeg())},c.prototype.getX=function(){return this.normalize(),this.x.fromRed()},c.prototype.getY=function(){return this.normalize(),this.y.fromRed()},c.prototype.eq=function(e){return this===e||0===this.getX().cmp(e.getX())&&0===this.getY().cmp(e.getY())},c.prototype.eqXToP=function(e){var t=e.toRed(this.curve.red).redMul(this.z);if(0===this.x.cmp(t))return!0;for(var i=e.clone(),r=this.curve.redN.redMul(this.z);;){if(i.iadd(this.curve.n),0<=i.cmp(this.curve.p))return!1;if(t.redIAdd(r),0===this.x.cmp(t))return!0}},c.prototype.toP=c.prototype.normalize,c.prototype.mixedAdd=c.prototype.add},{"../utils":15,"./base":2,"bn.js":16,inherits:32}],4:[function(e,t,i){"use strict";i.base=e("./base"),i.short=e("./short"),i.mont=e("./mont"),i.edwards=e("./edwards")},{"./base":2,"./edwards":3,"./mont":5,"./short":6}],5:[function(e,t,i){"use strict";var r=e("bn.js"),f=e("inherits"),d=e("./base"),n=e("../utils");function a(e){d.call(this,"mont",e),this.a=new r(e.a,16).toRed(this.red),this.b=new r(e.b,16).toRed(this.red),this.i4=new r(4).toRed(this.red).redInvm(),this.two=new r(2).toRed(this.red),this.a24=this.i4.redMul(this.a.redAdd(this.two))}function s(e,t,i){d.BasePoint.call(this,e,"projective"),null===t&&null===i?(this.x=this.curve.one,this.z=this.curve.zero):(this.x=new r(t,16),this.z=new r(i,16),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.z.red||(this.z=this.z.toRed(this.curve.red)))}f(a,d),(t.exports=a).prototype.validate=function(e){var t=e.normalize().x,e=t.redSqr(),t=e.redMul(t).redAdd(e.redMul(this.a)).redAdd(t);return 0===t.redSqrt().redSqr().cmp(t)},f(s,d.BasePoint),a.prototype.decodePoint=function(e,t){return this.point(n.toArray(e,t),1)},a.prototype.point=function(e,t){return new s(this,e,t)},a.prototype.pointFromJSON=function(e){return s.fromJSON(this,e)},s.prototype.precompute=function(){},s.prototype._encode=function(){return this.getX().toArray("be",this.curve.p.byteLength())},s.fromJSON=function(e,t){return new s(e,t[0],t[1]||e.one)},s.prototype.inspect=function(){return this.isInfinity()?"<EC Point Infinity>":"<EC Point x: "+this.x.fromRed().toString(16,2)+" z: "+this.z.fromRed().toString(16,2)+">"},s.prototype.isInfinity=function(){return 0===this.z.cmpn(0)},s.prototype.dbl=function(){var e=this.x.redAdd(this.z).redSqr(),t=this.x.redSub(this.z).redSqr(),i=e.redSub(t),e=e.redMul(t),i=i.redMul(t.redAdd(this.curve.a24.redMul(i)));return this.curve.point(e,i)},s.prototype.add=function(){throw new Error("Not supported on Montgomery curve")},s.prototype.diffAdd=function(e,t){var i=this.x.redAdd(this.z),r=this.x.redSub(this.z),f=e.x.redAdd(e.z),i=e.x.redSub(e.z).redMul(i),f=f.redMul(r),r=t.z.redMul(i.redAdd(f).redSqr()),f=t.x.redMul(i.redISub(f).redSqr());return this.curve.point(r,f)},s.prototype.mul=function(e){for(var t=e.clone(),i=this,r=this.curve.point(null,null),f=[];0!==t.cmpn(0);t.iushrn(1))f.push(t.andln(1));for(var d=f.length-1;0<=d;d--)0===f[d]?(i=i.diffAdd(r,this),r=r.dbl()):(r=i.diffAdd(r,this),i=i.dbl());return r},s.prototype.mulAdd=function(){throw new Error("Not supported on Montgomery curve")},s.prototype.jumlAdd=function(){throw new Error("Not supported on Montgomery curve")},s.prototype.eq=function(e){return 0===this.getX().cmp(e.getX())},s.prototype.normalize=function(){return this.x=this.x.redMul(this.z.redInvm()),this.z=this.curve.one,this},s.prototype.getX=function(){return this.normalize(),this.x.fromRed()}},{"../utils":15,"./base":2,"bn.js":16,inherits:32}],6:[function(e,t,i){"use strict";var r=e("../utils"),y=e("bn.js"),f=e("inherits"),d=e("./base"),n=r.assert;function a(e){d.call(this,"short",e),this.a=new y(e.a,16).toRed(this.red),this.b=new y(e.b,16).toRed(this.red),this.tinv=this.two.redInvm(),this.zeroA=0===this.a.fromRed().cmpn(0),this.threeA=0===this.a.fromRed().sub(this.p).cmpn(-3),this.endo=this._getEndomorphism(e),this._endoWnafT1=new Array(4),this._endoWnafT2=new Array(4)}function s(e,t,i,r){d.BasePoint.call(this,e,"affine"),null===t&&null===i?(this.x=null,this.y=null,this.inf=!0):(this.x=new y(t,16),this.y=new y(i,16),r&&(this.x.forceRed(this.curve.red),this.y.forceRed(this.curve.red)),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.inf=!1)}function c(e,t,i,r){d.BasePoint.call(this,e,"jacobian"),null===t&&null===i&&null===r?(this.x=this.curve.one,this.y=this.curve.one,this.z=new y(0)):(this.x=new y(t,16),this.y=new y(i,16),this.z=new y(r,16)),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.z.red||(this.z=this.z.toRed(this.curve.red)),this.zOne=this.z===this.curve.one}f(a,d),(t.exports=a).prototype._getEndomorphism=function(e){var t,i,r;if(this.zeroA&&this.g&&this.n&&1===this.p.modn(3))return i=(e.beta?new y(e.beta,16):i=(r=this._getEndoRoots(this.p))[0].cmp(r[1])<0?r[0]:r[1]).toRed(this.red),e.lambda?t=new y(e.lambda,16):(r=this._getEndoRoots(this.n),0===this.g.mul(r[0]).x.cmp(this.g.x.redMul(i))?t=r[0]:(t=r[1],n(0===this.g.mul(t).x.cmp(this.g.x.redMul(i))))),{beta:i,lambda:t,basis:e.basis?e.basis.map(function(e){return{a:new y(e.a,16),b:new y(e.b,16)}}):this._getEndoBasis(t)}},a.prototype._getEndoRoots=function(e){var t=e===this.p?this.red:y.mont(e),i=new y(2).toRed(t).redInvm(),e=i.redNeg(),i=new y(3).toRed(t).redNeg().redSqrt().redMul(i);return[e.redAdd(i).fromRed(),e.redSub(i).fromRed()]},a.prototype._getEndoBasis=function(e){for(var t,i,r,f,d,n,a,s=this.n.ushrn(Math.floor(this.n.bitLength()/2)),c=e,h=this.n.clone(),o=new y(1),u=new y(0),b=new y(0),l=new y(1),p=0;0!==c.cmpn(0);){var m=h.div(c),v=h.sub(m.mul(c)),g=b.sub(m.mul(o)),m=l.sub(m.mul(u));if(!r&&v.cmp(s)<0)t=a.neg(),i=o,r=v.neg(),f=g;else if(r&&2==++p)break;h=c,c=a=v,b=o,o=g,l=u,u=m}d=v.neg(),n=g;e=r.sqr().add(f.sqr());return 0<=d.sqr().add(n.sqr()).cmp(e)&&(d=t,n=i),r.negative&&(r=r.neg(),f=f.neg()),d.negative&&(d=d.neg(),n=n.neg()),[{a:r,b:f},{a:d,b:n}]},a.prototype._endoSplit=function(e){var t=this.endo.basis,i=t[0],r=t[1],f=r.b.mul(e).divRound(this.n),d=i.b.neg().mul(e).divRound(this.n),n=f.mul(i.a),t=d.mul(r.a),i=f.mul(i.b),r=d.mul(r.b);return{k1:e.sub(n).sub(t),k2:i.add(r).neg()}},a.prototype.pointFromX=function(e,t){var i=(e=!(e=new y(e,16)).red?e.toRed(this.red):e).redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b),r=i.redSqrt();if(0!==r.redSqr().redSub(i).cmp(this.zero))throw new Error("invalid point");i=r.fromRed().isOdd();return(t&&!i||!t&&i)&&(r=r.redNeg()),this.point(e,r)},a.prototype.validate=function(e){if(e.inf)return!0;var t=e.x,i=e.y,e=this.a.redMul(t),e=t.redSqr().redMul(t).redIAdd(e).redIAdd(this.b);return 0===i.redSqr().redISub(e).cmpn(0)},a.prototype._endoWnafMulAdd=function(e,t,i){for(var r=this._endoWnafT1,f=this._endoWnafT2,d=0;d<e.length;d++){var n=this._endoSplit(t[d]),a=e[d],s=a._getBeta();n.k1.negative&&(n.k1.ineg(),a=a.neg(!0)),n.k2.negative&&(n.k2.ineg(),s=s.neg(!0)),r[2*d]=a,r[2*d+1]=s,f[2*d]=n.k1,f[2*d+1]=n.k2}for(var i=this._wnafMulAdd(1,r,f,2*d,i),c=0;c<2*d;c++)r[c]=null,f[c]=null;return i},f(s,d.BasePoint),a.prototype.point=function(e,t,i){return new s(this,e,t,i)},a.prototype.pointFromJSON=function(e,t){return s.fromJSON(this,e,t)},s.prototype._getBeta=function(){if(this.curve.endo){var e=this.precomputed;if(e&&e.beta)return e.beta;var t,i,r=this.curve.point(this.x.redMul(this.curve.endo.beta),this.y);return e&&(t=this.curve,i=function(e){return t.point(e.x.redMul(t.endo.beta),e.y)},(e.beta=r).precomputed={beta:null,naf:e.naf&&{wnd:e.naf.wnd,points:e.naf.points.map(i)},doubles:e.doubles&&{step:e.doubles.step,points:e.doubles.points.map(i)}}),r}},s.prototype.toJSON=function(){return this.precomputed?[this.x,this.y,this.precomputed&&{doubles:this.precomputed.doubles&&{step:this.precomputed.doubles.step,points:this.precomputed.doubles.points.slice(1)},naf:this.precomputed.naf&&{wnd:this.precomputed.naf.wnd,points:this.precomputed.naf.points.slice(1)}}]:[this.x,this.y]},s.fromJSON=function(t,e,i){"string"==typeof e&&(e=JSON.parse(e));var r=t.point(e[0],e[1],i);if(!e[2])return r;function f(e){return t.point(e[0],e[1],i)}e=e[2];return r.precomputed={beta:null,doubles:e.doubles&&{step:e.doubles.step,points:[r].concat(e.doubles.points.map(f))},naf:e.naf&&{wnd:e.naf.wnd,points:[r].concat(e.naf.points.map(f))}},r},s.prototype.inspect=function(){return this.isInfinity()?"<EC Point Infinity>":"<EC Point x: "+this.x.fromRed().toString(16,2)+" y: "+this.y.fromRed().toString(16,2)+">"},s.prototype.isInfinity=function(){return this.inf},s.prototype.add=function(e){if(this.inf)return e;if(e.inf)return this;if(this.eq(e))return this.dbl();if(this.neg().eq(e))return this.curve.point(null,null);if(0===this.x.cmp(e.x))return this.curve.point(null,null);var t=this.y.redSub(e.y),e=(t=0!==t.cmpn(0)?t.redMul(this.x.redSub(e.x).redInvm()):t).redSqr().redISub(this.x).redISub(e.x),t=t.redMul(this.x.redSub(e)).redISub(this.y);return this.curve.point(e,t)},s.prototype.dbl=function(){if(this.inf)return this;var e=this.y.redAdd(this.y);if(0===e.cmpn(0))return this.curve.point(null,null);var t=this.curve.a,i=this.x.redSqr(),e=e.redInvm(),t=i.redAdd(i).redIAdd(i).redIAdd(t).redMul(e),e=t.redSqr().redISub(this.x.redAdd(this.x)),t=t.redMul(this.x.redSub(e)).redISub(this.y);return this.curve.point(e,t)},s.prototype.getX=function(){return this.x.fromRed()},s.prototype.getY=function(){return this.y.fromRed()},s.prototype.mul=function(e){return e=new y(e,16),this.isInfinity()?this:this._hasDoubles(e)?this.curve._fixedNafMul(this,e):this.curve.endo?this.curve._endoWnafMulAdd([this],[e]):this.curve._wnafMul(this,e)},s.prototype.mulAdd=function(e,t,i){t=[this,t],i=[e,i];return this.curve.endo?this.curve._endoWnafMulAdd(t,i):this.curve._wnafMulAdd(1,t,i,2)},s.prototype.jmulAdd=function(e,t,i){t=[this,t],i=[e,i];return this.curve.endo?this.curve._endoWnafMulAdd(t,i,!0):this.curve._wnafMulAdd(1,t,i,2,!0)},s.prototype.eq=function(e){return this===e||this.inf===e.inf&&(this.inf||0===this.x.cmp(e.x)&&0===this.y.cmp(e.y))},s.prototype.neg=function(e){if(this.inf)return this;var t,i=this.curve.point(this.x,this.y.redNeg());return e&&this.precomputed&&(t=this.precomputed,e=function(e){return e.neg()},i.precomputed={naf:t.naf&&{wnd:t.naf.wnd,points:t.naf.points.map(e)},doubles:t.doubles&&{step:t.doubles.step,points:t.doubles.points.map(e)}}),i},s.prototype.toJ=function(){return this.inf?this.curve.jpoint(null,null,null):this.curve.jpoint(this.x,this.y,this.curve.one)},f(c,d.BasePoint),a.prototype.jpoint=function(e,t,i){return new c(this,e,t,i)},c.prototype.toP=function(){if(this.isInfinity())return this.curve.point(null,null);var e=this.z.redInvm(),t=e.redSqr(),i=this.x.redMul(t),e=this.y.redMul(t).redMul(e);return this.curve.point(i,e)},c.prototype.neg=function(){return this.curve.jpoint(this.x,this.y.redNeg(),this.z)},c.prototype.add=function(e){if(this.isInfinity())return e;if(e.isInfinity())return this;var t=e.z.redSqr(),i=this.z.redSqr(),r=this.x.redMul(t),f=e.x.redMul(i),d=this.y.redMul(t.redMul(e.z)),n=e.y.redMul(i.redMul(this.z)),t=r.redSub(f),i=d.redSub(n);if(0===t.cmpn(0))return 0!==i.cmpn(0)?this.curve.jpoint(null,null,null):this.dbl();f=t.redSqr(),n=f.redMul(t),r=r.redMul(f),f=i.redSqr().redIAdd(n).redISub(r).redISub(r),n=i.redMul(r.redISub(f)).redISub(d.redMul(n)),t=this.z.redMul(e.z).redMul(t);return this.curve.jpoint(f,n,t)},c.prototype.mixedAdd=function(e){if(this.isInfinity())return e.toJ();if(e.isInfinity())return this;var t=this.z.redSqr(),i=this.x,r=e.x.redMul(t),f=this.y,d=e.y.redMul(t).redMul(this.z),e=i.redSub(r),t=f.redSub(d);if(0===e.cmpn(0))return 0!==t.cmpn(0)?this.curve.jpoint(null,null,null):this.dbl();r=e.redSqr(),d=r.redMul(e),i=i.redMul(r),r=t.redSqr().redIAdd(d).redISub(i).redISub(i),d=t.redMul(i.redISub(r)).redISub(f.redMul(d)),e=this.z.redMul(e);return this.curve.jpoint(r,d,e)},c.prototype.dblp=function(e){if(0===e)return this;if(this.isInfinity())return this;if(!e)return this.dbl();if(this.curve.zeroA||this.curve.threeA){for(var t=this,i=0;i<e;i++)t=t.dbl();return t}var r=this.curve.a,f=this.curve.tinv,d=this.x,n=this.y,a=this.z,s=a.redSqr().redSqr(),c=n.redAdd(n);for(i=0;i<e;i++){var h=d.redSqr(),o=c.redSqr(),u=o.redSqr(),b=h.redAdd(h).redIAdd(h).redIAdd(r.redMul(s)),h=d.redMul(o),o=b.redSqr().redISub(h.redAdd(h)),h=h.redISub(o),b=(b=b.redMul(h)).redIAdd(b).redISub(u),h=c.redMul(a);i+1<e&&(s=s.redMul(u)),d=o,a=h,c=b}return this.curve.jpoint(d,c.redMul(f),a)},c.prototype.dbl=function(){return this.isInfinity()?this:this.curve.zeroA?this._zeroDbl():this.curve.threeA?this._threeDbl():this._dbl()},c.prototype._zeroDbl=function(){var e,t,i,r,f,d=this.zOne?(i=this.x.redSqr(),e=(r=this.y.redSqr()).redSqr(),f=(f=this.x.redAdd(r).redSqr().redISub(i).redISub(e)).redIAdd(f),r=(t=i.redAdd(i).redIAdd(i)).redSqr().redISub(f).redISub(f),i=(i=(i=e.redIAdd(e)).redIAdd(i)).redIAdd(i),e=r,t=t.redMul(f.redISub(r)).redISub(i),this.y.redAdd(this.y)):(f=this.x.redSqr(),d=(r=this.y.redSqr()).redSqr(),i=(i=this.x.redAdd(r).redSqr().redISub(f).redISub(d)).redIAdd(i),f=(r=f.redAdd(f).redIAdd(f)).redSqr(),d=(d=(d=d.redIAdd(d)).redIAdd(d)).redIAdd(d),e=f.redISub(i).redISub(i),t=r.redMul(i.redISub(e)).redISub(d),(d=this.y.redMul(this.z)).redIAdd(d));return this.curve.jpoint(e,t,d)},c.prototype._threeDbl=function(){var e,t,i,r,f,d,n,a;return this.zOne?(e=this.x.redSqr(),r=(t=this.y.redSqr()).redSqr(),n=(n=this.x.redAdd(t).redSqr().redISub(e).redISub(r)).redIAdd(n),i=f=(a=e.redAdd(e).redIAdd(e).redIAdd(this.curve.a)).redSqr().redISub(n).redISub(n),d=(d=(d=r.redIAdd(r)).redIAdd(d)).redIAdd(d),t=a.redMul(n.redISub(f)).redISub(d),e=this.y.redAdd(this.y)):(r=this.z.redSqr(),a=this.y.redSqr(),n=this.x.redMul(a),f=(f=this.x.redSub(r).redMul(this.x.redAdd(r))).redAdd(f).redIAdd(f),n=(d=(d=n.redIAdd(n)).redIAdd(d)).redAdd(d),i=f.redSqr().redISub(n),e=this.y.redAdd(this.z).redSqr().redISub(a).redISub(r),a=(a=(a=(a=a.redSqr()).redIAdd(a)).redIAdd(a)).redIAdd(a),t=f.redMul(d.redISub(i)).redISub(a)),this.curve.jpoint(i,t,e)},c.prototype._dbl=function(){var e=this.curve.a,t=this.x,i=this.y,r=this.z,f=r.redSqr().redSqr(),d=t.redSqr(),n=i.redSqr(),e=d.redAdd(d).redIAdd(d).redIAdd(e.redMul(f)),f=t.redAdd(t),t=(f=f.redIAdd(f)).redMul(n),f=e.redSqr().redISub(t.redAdd(t)),t=t.redISub(f),n=n.redSqr();n=(n=(n=n.redIAdd(n)).redIAdd(n)).redIAdd(n);n=e.redMul(t).redISub(n),r=i.redAdd(i).redMul(r);return this.curve.jpoint(f,n,r)},c.prototype.trpl=function(){if(!this.curve.zeroA)return this.dbl().add(this);var e=this.x.redSqr(),t=this.y.redSqr(),i=this.z.redSqr(),r=t.redSqr(),f=e.redAdd(e).redIAdd(e),d=f.redSqr(),n=this.x.redAdd(t).redSqr().redISub(e).redISub(r),e=(n=(n=(n=n.redIAdd(n)).redAdd(n).redIAdd(n)).redISub(d)).redSqr(),r=r.redIAdd(r);r=(r=(r=r.redIAdd(r)).redIAdd(r)).redIAdd(r);d=f.redIAdd(n).redSqr().redISub(d).redISub(e).redISub(r),t=t.redMul(d);t=(t=t.redIAdd(t)).redIAdd(t);t=this.x.redMul(e).redISub(t);t=(t=t.redIAdd(t)).redIAdd(t);d=this.y.redMul(d.redMul(r.redISub(d)).redISub(n.redMul(e)));d=(d=(d=d.redIAdd(d)).redIAdd(d)).redIAdd(d);e=this.z.redAdd(n).redSqr().redISub(i).redISub(e);return this.curve.jpoint(t,d,e)},c.prototype.mul=function(e,t){return e=new y(e,t),this.curve._wnafMul(this,e)},c.prototype.eq=function(e){if("affine"===e.type)return this.eq(e.toJ());if(this===e)return!0;var t=this.z.redSqr(),i=e.z.redSqr();if(0!==this.x.redMul(i).redISub(e.x.redMul(t)).cmpn(0))return!1;t=t.redMul(this.z),i=i.redMul(e.z);return 0===this.y.redMul(i).redISub(e.y.redMul(t)).cmpn(0)},c.prototype.eqXToP=function(e){var t=this.z.redSqr(),i=e.toRed(this.curve.red).redMul(t);if(0===this.x.cmp(i))return!0;for(var r=e.clone(),f=this.curve.redN.redMul(t);;){if(r.iadd(this.curve.n),0<=r.cmp(this.curve.p))return!1;if(i.redIAdd(f),0===this.x.cmp(i))return!0}},c.prototype.inspect=function(){return this.isInfinity()?"<EC JPoint Infinity>":"<EC JPoint x: "+this.x.toString(16,2)+" y: "+this.y.toString(16,2)+" z: "+this.z.toString(16,2)+">"},c.prototype.isInfinity=function(){return 0===this.z.cmpn(0)}},{"../utils":15,"./base":2,"bn.js":16,inherits:32}],7:[function(e,t,i){"use strict";var r,f=i,i=e("hash.js"),d=e("./curve"),n=e("./utils").assert;function a(e){"short"===e.type?this.curve=new d.short(e):"edwards"===e.type?this.curve=new d.edwards(e):this.curve=new d.mont(e),this.g=this.curve.g,this.n=this.curve.n,this.hash=e.hash,n(this.g.validate(),"Invalid curve"),n(this.g.mul(this.n).isInfinity(),"Invalid curve, G*N != O")}function s(t,i){Object.defineProperty(f,t,{configurable:!0,enumerable:!0,get:function(){var e=new a(i);return Object.defineProperty(f,t,{configurable:!0,enumerable:!0,value:e}),e}})}f.PresetCurve=a,s("p192",{type:"short",prime:"p192",p:"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",a:"ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",b:"64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",n:"ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",hash:i.sha256,gRed:!1,g:["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012","07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]}),s("p224",{type:"short",prime:"p224",p:"ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",a:"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",b:"b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",n:"ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",hash:i.sha256,gRed:!1,g:["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21","bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]}),s("p256",{type:"short",prime:null,p:"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",a:"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",b:"5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",n:"ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",hash:i.sha256,gRed:!1,g:["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296","4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]}),s("p384",{type:"short",prime:null,p:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",a:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",b:"b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",n:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",hash:i.sha384,gRed:!1,g:["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7","3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]}),s("p521",{type:"short",prime:null,p:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",a:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",b:"00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",n:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",hash:i.sha512,gRed:!1,g:["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66","00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]}),s("curve25519",{type:"mont",prime:"p25519",p:"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",a:"76d06",b:"1",n:"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",hash:i.sha256,gRed:!1,g:["9"]}),s("ed25519",{type:"edwards",prime:"p25519",p:"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",a:"-1",c:"1",d:"52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",n:"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",hash:i.sha256,gRed:!1,g:["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a","6666666666666666666666666666666666666666666666666666666666666658"]});try{r=e("./precomputed/secp256k1")}catch(e){r=void 0}s("secp256k1",{type:"short",prime:"k256",p:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",a:"0",b:"7",n:"ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",h:"1",hash:i.sha256,beta:"7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",lambda:"5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",basis:[{a:"3086d221a7d46bcde86c90e49284eb15",b:"-e4437ed6010e88286f547fa90abfe4c3"},{a:"114ca50f7a8e2f3f657c1108d9d44cfd8",b:"3086d221a7d46bcde86c90e49284eb15"}],gRed:!1,g:["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798","483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",r]})},{"./curve":4,"./precomputed/secp256k1":14,"./utils":15,"hash.js":19}],8:[function(e,t,i){"use strict";var u=e("bn.js"),b=e("hmac-drbg"),r=e("../utils"),f=e("../curves"),d=e("brorand"),a=r.assert,n=e("./key"),l=e("./signature");function s(e){if(!(this instanceof s))return new s(e);"string"==typeof e&&(a(Object.prototype.hasOwnProperty.call(f,e),"Unknown curve "+e),e=f[e]),e instanceof f.PresetCurve&&(e={curve:e}),this.curve=e.curve.curve,this.n=this.curve.n,this.nh=this.n.ushrn(1),this.g=this.curve.g,this.g=e.curve.g,this.g.precompute(e.curve.n.bitLength()+1),this.hash=e.hash||e.curve.hash}(t.exports=s).prototype.keyPair=function(e){return new n(this,e)},s.prototype.keyFromPrivate=function(e,t){return n.fromPrivate(this,e,t)},s.prototype.keyFromPublic=function(e,t){return n.fromPublic(this,e,t)},s.prototype.genKeyPair=function(e){e=e||{};for(var t=new b({hash:this.hash,pers:e.pers,persEnc:e.persEnc||"utf8",entropy:e.entropy||d(this.hash.hmacStrength),entropyEnc:e.entropy&&e.entropyEnc||"utf8",nonce:this.n.toArray()}),i=this.n.byteLength(),r=this.n.sub(new u(2));;){var f=new u(t.generate(i));if(!(0<f.cmp(r)))return f.iaddn(1),this.keyFromPrivate(f)}},s.prototype._truncateToN=function(e,t){var i=8*e.byteLength()-this.n.bitLength();return 0<i&&(e=e.ushrn(i)),!t&&0<=e.cmp(this.n)?e.sub(this.n):e},s.prototype.sign=function(e,t,i,r){"object"==typeof i&&(r=i,i=null),r=r||{},t=this.keyFromPrivate(t,i),e=this._truncateToN(new u(e,16));for(var f=this.n.byteLength(),i=t.getPrivate().toArray("be",f),f=e.toArray("be",f),d=new b({hash:this.hash,entropy:i,nonce:f,pers:r.pers,persEnc:r.persEnc||"utf8"}),n=this.n.sub(new u(1)),a=0;;a++){var s=r.k?r.k(a):new u(d.generate(this.n.byteLength()));if(!((s=this._truncateToN(s,!0)).cmpn(1)<=0||0<=s.cmp(n))){var c=this.g.mul(s);if(!c.isInfinity()){var h=c.getX(),o=h.umod(this.n);if(0!==o.cmpn(0)){s=s.invm(this.n).mul(o.mul(t.getPrivate()).iadd(e));if(0!==(s=s.umod(this.n)).cmpn(0)){h=(c.getY().isOdd()?1:0)|(0!==h.cmp(o)?2:0);return r.canonical&&0<s.cmp(this.nh)&&(s=this.n.sub(s),h^=1),new l({r:o,s:s,recoveryParam:h})}}}}}},s.prototype.verify=function(e,t,i,r){e=this._truncateToN(new u(e,16)),i=this.keyFromPublic(i,r);r=(t=new l(t,"hex")).r,t=t.s;if(r.cmpn(1)<0||0<=r.cmp(this.n))return!1;if(t.cmpn(1)<0||0<=t.cmp(this.n))return!1;var f,t=t.invm(this.n),e=t.mul(e).umod(this.n),t=t.mul(r).umod(this.n);return this.curve._maxwellTrick?!(f=this.g.jmulAdd(e,i.getPublic(),t)).isInfinity()&&f.eqXToP(r):!(f=this.g.mulAdd(e,i.getPublic(),t)).isInfinity()&&0===f.getX().umod(this.n).cmp(r)},s.prototype.recoverPubKey=function(e,t,i,r){a((3&i)===i,"The recovery param is more than two bits"),t=new l(t,r);var f=this.n,d=new u(e),n=t.r,r=t.s,e=1&i,i=i>>1;if(0<=n.cmp(this.curve.p.umod(this.curve.n))&&i)throw new Error("Unable to find sencond key candinate");n=i?this.curve.pointFromX(n.add(this.curve.n),e):this.curve.pointFromX(n,e);t=t.r.invm(f),d=f.sub(d).mul(t).umod(f),f=r.mul(t).umod(f);return this.g.mulAdd(d,n,f)},s.prototype.getKeyRecoveryParam=function(e,t,i,r){if(null!==(t=new l(t,r)).recoveryParam)return t.recoveryParam;for(var f,d=0;d<4;d++){try{f=this.recoverPubKey(e,t,d)}catch(e){continue}if(f.eq(i))return d}throw new Error("Unable to find valid recovery factor")}},{"../curves":7,"../utils":15,"./key":9,"./signature":10,"bn.js":16,brorand:17,"hmac-drbg":31}],9:[function(e,t,i){"use strict";var r=e("bn.js"),f=e("../utils").assert;function d(e,t){this.ec=e,this.priv=null,this.pub=null,t.priv&&this._importPrivate(t.priv,t.privEnc),t.pub&&this._importPublic(t.pub,t.pubEnc)}(t.exports=d).fromPublic=function(e,t,i){return t instanceof d?t:new d(e,{pub:t,pubEnc:i})},d.fromPrivate=function(e,t,i){return t instanceof d?t:new d(e,{priv:t,privEnc:i})},d.prototype.validate=function(){var e=this.getPublic();return e.isInfinity()?{result:!1,reason:"Invalid public key"}:e.validate()?e.mul(this.ec.curve.n).isInfinity()?{result:!0,reason:null}:{result:!1,reason:"Public key * N != O"}:{result:!1,reason:"Public key is not a point"}},d.prototype.getPublic=function(e,t){return"string"==typeof e&&(t=e,e=null),this.pub||(this.pub=this.ec.g.mul(this.priv)),t?this.pub.encode(t,e):this.pub},d.prototype.getPrivate=function(e){return"hex"===e?this.priv.toString(16,2):this.priv},d.prototype._importPrivate=function(e,t){this.priv=new r(e,t||16),this.priv=this.priv.umod(this.ec.curve.n)},d.prototype._importPublic=function(e,t){if(e.x||e.y)return"mont"===this.ec.curve.type?f(e.x,"Need x coordinate"):"short"!==this.ec.curve.type&&"edwards"!==this.ec.curve.type||f(e.x&&e.y,"Need both x and y coordinate"),void(this.pub=this.ec.curve.point(e.x,e.y));this.pub=this.ec.curve.decodePoint(e,t)},d.prototype.derive=function(e){return e.validate()||f(e.validate(),"public point not validated"),e.mul(this.priv).getX()},d.prototype.sign=function(e,t,i){return this.ec.sign(e,this,t,i)},d.prototype.verify=function(e,t){return this.ec.verify(e,t,this)},d.prototype.inspect=function(){return"<Key priv: "+(this.priv&&this.priv.toString(16,2))+" pub: "+(this.pub&&this.pub.inspect())+" >"}},{"../utils":15,"bn.js":16}],10:[function(e,t,i){"use strict";var f=e("bn.js"),d=e("../utils"),r=d.assert;function n(e,t){if(e instanceof n)return e;this._importDER(e,t)||(r(e.r&&e.s,"Signature without r or s"),this.r=new f(e.r,16),this.s=new f(e.s,16),void 0===e.recoveryParam?this.recoveryParam=null:this.recoveryParam=e.recoveryParam)}function a(){this.place=0}function s(e,t){var i=e[t.place++];if(!(128&i))return i;var r=15&i;if(0==r||4<r)return!1;for(var f=0,d=0,n=t.place;d<r;d++,n++)f<<=8,f|=e[n],f>>>=0;return!(f<=127)&&(t.place=n,f)}function c(e){for(var t=0,i=e.length-1;!e[t]&&!(128&e[t+1])&&t<i;)t++;return 0===t?e:e.slice(t)}function h(e,t){if(t<128)e.push(t);else{var i=1+(Math.log(t)/Math.LN2>>>3);for(e.push(128|i);--i;)e.push(t>>>(i<<3)&255);e.push(t)}}(t.exports=n).prototype._importDER=function(e,t){e=d.toArray(e,t);var i=new a;if(48!==e[i.place++])return!1;var r=s(e,i);if(!1===r)return!1;if(r+i.place!==e.length)return!1;if(2!==e[i.place++])return!1;t=s(e,i);if(!1===t)return!1;r=e.slice(i.place,t+i.place);if(i.place+=t,2!==e[i.place++])return!1;t=s(e,i);if(!1===t)return!1;if(e.length!==t+i.place)return!1;i=e.slice(i.place,t+i.place);if(0===r[0]){if(!(128&r[1]))return!1;r=r.slice(1)}if(0===i[0]){if(!(128&i[1]))return!1;i=i.slice(1)}return this.r=new f(r),this.s=new f(i),!(this.recoveryParam=null)},n.prototype.toDER=function(e){var t=this.r.toArray(),i=this.s.toArray();for(128&t[0]&&(t=[0].concat(t)),128&i[0]&&(i=[0].concat(i)),t=c(t),i=c(i);!(i[0]||128&i[1]);)i=i.slice(1);var r=[2];h(r,t.length),(r=r.concat(t)).push(2),h(r,i.length);t=r.concat(i),r=[48];return h(r,t.length),r=r.concat(t),d.encode(r,e)}},{"../utils":15,"bn.js":16}],11:[function(e,t,i){"use strict";var r=e("hash.js"),f=e("../curves"),d=e("../utils"),n=d.assert,a=d.parseBytes,s=e("./key"),c=e("./signature");function h(e){if(n("ed25519"===e,"only tested with ed25519 so far"),!(this instanceof h))return new h(e);e=f[e].curve,this.curve=e,this.g=e.g,this.g.precompute(e.n.bitLength()+1),this.pointClass=e.point().constructor,this.encodingLength=Math.ceil(e.n.bitLength()/8),this.hash=r.sha512}(t.exports=h).prototype.sign=function(e,t){e=a(e);var i=this.keyFromSecret(t),r=this.hashInt(i.messagePrefix(),e),f=this.g.mul(r),t=this.encodePoint(f),i=this.hashInt(t,i.pubBytes(),e).mul(i.priv()),i=r.add(i).umod(this.curve.n);return this.makeSignature({R:f,S:i,Rencoded:t})},h.prototype.verify=function(e,t,i){e=a(e),t=this.makeSignature(t);var r=this.keyFromPublic(i),i=this.hashInt(t.Rencoded(),r.pubBytes(),e),e=this.g.mul(t.S());return t.R().add(r.pub().mul(i)).eq(e)},h.prototype.hashInt=function(){for(var e=this.hash(),t=0;t<arguments.length;t++)e.update(arguments[t]);return d.intFromLE(e.digest()).umod(this.curve.n)},h.prototype.keyFromPublic=function(e){return s.fromPublic(this,e)},h.prototype.keyFromSecret=function(e){return s.fromSecret(this,e)},h.prototype.makeSignature=function(e){return e instanceof c?e:new c(this,e)},h.prototype.encodePoint=function(e){var t=e.getY().toArray("le",this.encodingLength);return t[this.encodingLength-1]|=e.getX().isOdd()?128:0,t},h.prototype.decodePoint=function(e){var t=(e=d.parseBytes(e)).length-1,i=e.slice(0,t).concat(-129&e[t]),t=0!=(128&e[t]),i=d.intFromLE(i);return this.curve.pointFromY(i,t)},h.prototype.encodeInt=function(e){return e.toArray("le",this.encodingLength)},h.prototype.decodeInt=function(e){return d.intFromLE(e)},h.prototype.isPoint=function(e){return e instanceof this.pointClass}},{"../curves":7,"../utils":15,"./key":12,"./signature":13,"hash.js":19}],12:[function(e,t,i){"use strict";var r=e("../utils"),f=r.assert,d=r.parseBytes,e=r.cachedProperty;function n(e,t){this.eddsa=e,this._secret=d(t.secret),e.isPoint(t.pub)?this._pub=t.pub:this._pubBytes=d(t.pub)}n.fromPublic=function(e,t){return t instanceof n?t:new n(e,{pub:t})},n.fromSecret=function(e,t){return t instanceof n?t:new n(e,{secret:t})},n.prototype.secret=function(){return this._secret},e(n,"pubBytes",function(){return this.eddsa.encodePoint(this.pub())}),e(n,"pub",function(){return this._pubBytes?this.eddsa.decodePoint(this._pubBytes):this.eddsa.g.mul(this.priv())}),e(n,"privBytes",function(){var e=this.eddsa,t=this.hash(),i=e.encodingLength-1,e=t.slice(0,e.encodingLength);return e[0]&=248,e[i]&=127,e[i]|=64,e}),e(n,"priv",function(){return this.eddsa.decodeInt(this.privBytes())}),e(n,"hash",function(){return this.eddsa.hash().update(this.secret()).digest()}),e(n,"messagePrefix",function(){return this.hash().slice(this.eddsa.encodingLength)}),n.prototype.sign=function(e){return f(this._secret,"KeyPair can only verify"),this.eddsa.sign(e,this)},n.prototype.verify=function(e,t){return this.eddsa.verify(e,t,this)},n.prototype.getSecret=function(e){return f(this._secret,"KeyPair is public only"),r.encode(this.secret(),e)},n.prototype.getPublic=function(e){return r.encode(this.pubBytes(),e)},t.exports=n},{"../utils":15}],13:[function(e,t,i){"use strict";var r=e("bn.js"),f=e("../utils"),d=f.assert,e=f.cachedProperty,n=f.parseBytes;function a(e,t){this.eddsa=e,"object"!=typeof t&&(t=n(t)),Array.isArray(t)&&(t={R:t.slice(0,e.encodingLength),S:t.slice(e.encodingLength)}),d(t.R&&t.S,"Signature without R or S"),e.isPoint(t.R)&&(this._R=t.R),t.S instanceof r&&(this._S=t.S),this._Rencoded=Array.isArray(t.R)?t.R:t.Rencoded,this._Sencoded=Array.isArray(t.S)?t.S:t.Sencoded}e(a,"S",function(){return this.eddsa.decodeInt(this.Sencoded())}),e(a,"R",function(){return this.eddsa.decodePoint(this.Rencoded())}),e(a,"Rencoded",function(){return this.eddsa.encodePoint(this.R())}),e(a,"Sencoded",function(){return this.eddsa.encodeInt(this.S())}),a.prototype.toBytes=function(){return this.Rencoded().concat(this.Sencoded())},a.prototype.toHex=function(){return f.encode(this.toBytes(),"hex").toUpperCase()},t.exports=a},{"../utils":15,"bn.js":16}],14:[function(e,t,i){t.exports={doubles:{step:4,points:[["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a","f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"],["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508","11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"],["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739","d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"],["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640","4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"],["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c","4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"],["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda","96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"],["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa","5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"],["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0","cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"],["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d","9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"],["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d","e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"],["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1","9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"],["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0","5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"],["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047","10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"],["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862","283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"],["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7","7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"],["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd","56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"],["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83","7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"],["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a","53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"],["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8","bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"],["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d","4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"],["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725","7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"],["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754","4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"],["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c","17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"],["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6","6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"],["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39","c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"],["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891","893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"],["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b","febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"],["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03","2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"],["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d","eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"],["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070","7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"],["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4","e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"],["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da","662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"],["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11","1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"],["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e","efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"],["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41","2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"],["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef","67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"],["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8","db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"],["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d","648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"],["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96","35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"],["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd","ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"],["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5","9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"],["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266","40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"],["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71","34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"],["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac","c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"],["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751","1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"],["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e","493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"],["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241","c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"],["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3","be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"],["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f","4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"],["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19","aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"],["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be","b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"],["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9","6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"],["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2","8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"],["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13","7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"],["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c","ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"],["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba","2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"],["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151","e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"],["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073","d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"],["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458","38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"],["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b","69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"],["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366","d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"],["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa","40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"],["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0","620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"],["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787","7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"],["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e","ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]]},naf:{wnd:7,points:[["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9","388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"],["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4","d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"],["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc","6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"],["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe","cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"],["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb","d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"],["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8","ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"],["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e","581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"],["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34","4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"],["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c","85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"],["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5","321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"],["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f","2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"],["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714","73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"],["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729","a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"],["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db","2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"],["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4","e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"],["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5","b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"],["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479","2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"],["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d","80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"],["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f","1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"],["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb","d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"],["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9","eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"],["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963","758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"],["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74","958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"],["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530","e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"],["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b","5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"],["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247","cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"],["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1","cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"],["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120","4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"],["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435","91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"],["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18","673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"],["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8","59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"],["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb","3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"],["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f","55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"],["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143","efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"],["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba","e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"],["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45","f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"],["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a","744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"],["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e","c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"],["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8","e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"],["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c","30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"],["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519","e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"],["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab","100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"],["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca","ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"],["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf","8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"],["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610","68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"],["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4","f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"],["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c","d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"],["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940","edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"],["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980","a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"],["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3","66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"],["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf","9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"],["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63","4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"],["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448","fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"],["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf","5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"],["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5","8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"],["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6","8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"],["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5","5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"],["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99","f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"],["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51","f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"],["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5","42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"],["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5","204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"],["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997","4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"],["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881","73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"],["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5","39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"],["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66","d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"],["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726","ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"],["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede","6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"],["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94","60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"],["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31","3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"],["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51","b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"],["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252","ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"],["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5","cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"],["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b","6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"],["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4","322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"],["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f","6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"],["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889","2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"],["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246","b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"],["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984","998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"],["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a","b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"],["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030","bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"],["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197","6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"],["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593","c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"],["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef","21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"],["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38","60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"],["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a","49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"],["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111","5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"],["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502","7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"],["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea","be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"],["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26","8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"],["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986","39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"],["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e","62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"],["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4","25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"],["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda","ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"],["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859","cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"],["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f","f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"],["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c","6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"],["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942","fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"],["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a","1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"],["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80","5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"],["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d","438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"],["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1","cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"],["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63","c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"],["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352","6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"],["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193","ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"],["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00","9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"],["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58","ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"],["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7","d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"],["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8","c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"],["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e","67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"],["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d","cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"],["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b","299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"],["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f","f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"],["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6","462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"],["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297","62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"],["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a","7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"],["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c","ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"],["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52","4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"],["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb","bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"],["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065","bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"],["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917","603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"],["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9","cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"],["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3","553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"],["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57","712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"],["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66","ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"],["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8","9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"],["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721","9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"],["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180","4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]]}}},{}],15:[function(e,t,i){"use strict";var r=i,f=e("bn.js"),i=e("minimalistic-assert"),e=e("minimalistic-crypto-utils");r.assert=i,r.toArray=e.toArray,r.zero2=e.zero2,r.toHex=e.toHex,r.encode=e.encode,r.getNAF=function(e,t,i){var r=new Array(Math.max(e.bitLength(),i)+1);r.fill(0);for(var f=1<<t+1,d=e.clone(),n=0;n<r.length;n++){var a,s=d.andln(f-1);d.isOdd()?(a=(f>>1)-1<s?(f>>1)-s:s,d.isubn(a)):a=0,r[n]=a,d.iushrn(1)}return r},r.getJSF=function(e,t){var i=[[],[]];e=e.clone(),t=t.clone();for(var r,f=0,d=0;0<e.cmpn(-f)||0<t.cmpn(-d);){var n,a=e.andln(3)+f&3,s=t.andln(3)+d&3;3===s&&(s=-1),n=0==(1&(a=3===a?-1:a))?0:3!==(r=e.andln(7)+f&7)&&5!==r||2!==s?a:-a,i[0].push(n),s=0==(1&s)?0:3!==(r=t.andln(7)+d&7)&&5!==r||2!==a?s:-s,i[1].push(s),2*f===n+1&&(f=1-f),2*d===s+1&&(d=1-d),e.iushrn(1),t.iushrn(1)}return i},r.cachedProperty=function(e,t,i){var r="_"+t;e.prototype[t]=function(){return void 0!==this[r]?this[r]:this[r]=i.call(this)}},r.parseBytes=function(e){return"string"==typeof e?r.toArray(e,"hex"):e},r.intFromLE=function(e){return new f(e,"hex","le")}},{"bn.js":16,"minimalistic-assert":33,"minimalistic-crypto-utils":34}],16:[function(_,e,t){!function(e,t){"use strict";function p(e,t){if(!e)throw new Error(t||"Assertion failed")}function i(e,t){e.super_=t;function i(){}i.prototype=t.prototype,e.prototype=new i,e.prototype.constructor=e}function m(e,t,i){if(m.isBN(e))return e;this.negative=0,this.words=null,this.length=0,(this.red=null)!==e&&("le"!==t&&"be"!==t||(i=t,t=10),this._init(e||0,t||10,i||"be"))}var r;"object"==typeof e?e.exports=m:t.BN=m,(m.BN=m).wordSize=26;try{r=_("buffer").Buffer}catch(e){}function n(e,t,i){for(var r=0,f=Math.min(e.length,i),d=t;d<f;d++){var n=e.charCodeAt(d)-48;r<<=4,r|=49<=n&&n<=54?n-49+10:17<=n&&n<=22?n-17+10:15&n}return r}function o(e,t,i,r){for(var f=0,d=Math.min(e.length,i),n=t;n<d;n++){var a=e.charCodeAt(n)-48;f*=r,f+=49<=a?a-49+10:17<=a?a-17+10:a}return f}m.isBN=function(e){return e instanceof m||null!==e&&"object"==typeof e&&e.constructor.wordSize===m.wordSize&&Array.isArray(e.words)},m.max=function(e,t){return 0<e.cmp(t)?e:t},m.min=function(e,t){return e.cmp(t)<0?e:t},m.prototype._init=function(e,t,i){if("number"==typeof e)return this._initNumber(e,t,i);if("object"==typeof e)return this._initArray(e,t,i);p((t="hex"===t?16:t)===(0|t)&&2<=t&&t<=36);var r=0;"-"===(e=e.toString().replace(/\s+/g,""))[0]&&r++,16===t?this._parseHex(e,r):this._parseBase(e,t,r),"-"===e[0]&&(this.negative=1),this.strip(),"le"===i&&this._initArray(this.toArray(),t,i)},m.prototype._initNumber=function(e,t,i){e<0&&(this.negative=1,e=-e),e<67108864?(this.words=[67108863&e],this.length=1):e<4503599627370496?(this.words=[67108863&e,e/67108864&67108863],this.length=2):(p(e<9007199254740992),this.words=[67108863&e,e/67108864&67108863,1],this.length=3),"le"===i&&this._initArray(this.toArray(),t,i)},m.prototype._initArray=function(e,t,i){if(p("number"==typeof e.length),e.length<=0)return this.words=[0],this.length=1,this;this.length=Math.ceil(e.length/3),this.words=new Array(this.length);for(var r,f,d=0;d<this.length;d++)this.words[d]=0;var n=0;if("be"===i)for(d=e.length-1,r=0;0<=d;d-=3)f=e[d]|e[d-1]<<8|e[d-2]<<16,this.words[r]|=f<<n&67108863,this.words[r+1]=f>>>26-n&67108863,26<=(n+=24)&&(n-=26,r++);else if("le"===i)for(r=d=0;d<e.length;d+=3)f=e[d]|e[d+1]<<8|e[d+2]<<16,this.words[r]|=f<<n&67108863,this.words[r+1]=f>>>26-n&67108863,26<=(n+=24)&&(n-=26,r++);return this.strip()},m.prototype._parseHex=function(e,t){this.length=Math.ceil((e.length-t)/6),this.words=new Array(this.length);for(var i,r=0;r<this.length;r++)this.words[r]=0;for(var f=0,r=e.length-6,d=0;t<=r;r-=6)i=n(e,r,r+6),this.words[d]|=i<<f&67108863,this.words[d+1]|=i>>>26-f&4194303,26<=(f+=24)&&(f-=26,d++);r+6!==t&&(i=n(e,t,r+6),this.words[d]|=i<<f&67108863,this.words[d+1]|=i>>>26-f&4194303),this.strip()},m.prototype._parseBase=function(e,t,i){this.words=[0];for(var r=0,f=this.length=1;f<=67108863;f*=t)r++;r--,f=f/t|0;for(var d=e.length-i,n=d%r,a=Math.min(d,d-n)+i,s=0,c=i;c<a;c+=r)s=o(e,c,c+r,t),this.imuln(f),this.words[0]+s<67108864?this.words[0]+=s:this._iaddn(s);if(0!=n){for(var h=1,s=o(e,c,e.length,t),c=0;c<n;c++)h*=t;this.imuln(h),this.words[0]+s<67108864?this.words[0]+=s:this._iaddn(s)}},m.prototype.copy=function(e){e.words=new Array(this.length);for(var t=0;t<this.length;t++)e.words[t]=this.words[t];e.length=this.length,e.negative=this.negative,e.red=this.red},m.prototype.clone=function(){var e=new m(null);return this.copy(e),e},m.prototype._expand=function(e){for(;this.length<e;)this.words[this.length++]=0;return this},m.prototype.strip=function(){for(;1<this.length&&0===this.words[this.length-1];)this.length--;return this._normSign()},m.prototype._normSign=function(){return 1===this.length&&0===this.words[0]&&(this.negative=0),this},m.prototype.inspect=function(){return(this.red?"<BN-R: ":"<BN: ")+this.toString(16)+">"};var u=["","0","00","000","0000","00000","000000","0000000","00000000","000000000","0000000000","00000000000","000000000000","0000000000000","00000000000000","000000000000000","0000000000000000","00000000000000000","000000000000000000","0000000000000000000","00000000000000000000","000000000000000000000","0000000000000000000000","00000000000000000000000","000000000000000000000000","0000000000000000000000000"],b=[0,0,25,16,12,11,10,9,8,8,7,7,7,7,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5],l=[0,0,33554432,43046721,16777216,48828125,60466176,40353607,16777216,43046721,1e7,19487171,35831808,62748517,7529536,11390625,16777216,24137569,34012224,47045881,64e6,4084101,5153632,6436343,7962624,9765625,11881376,14348907,17210368,20511149,243e5,28629151,33554432,39135393,45435424,52521875,60466176];function f(e,t,i){i.negative=t.negative^e.negative;var r=e.length+t.length|0,r=(i.length=r)-1|0,f=67108863&(o=(0|e.words[0])*(0|t.words[0])),d=o/67108864|0;i.words[0]=f;for(var n=1;n<r;n++){for(var a=d>>>26,s=67108863&d,c=Math.min(n,t.length-1),h=Math.max(0,n-e.length+1);h<=c;h++){var o,u=n-h|0;a+=(o=(0|e.words[u])*(0|t.words[h])+s)/67108864|0,s=67108863&o}i.words[n]=0|s,d=0|a}return 0!==d?i.words[n]=0|d:i.length--,i.strip()}m.prototype.toString=function(e,t){if(t=0|t||1,16===(e=e||10)||"hex"===e){a="";for(var i=0,r=0,f=0;f<this.length;f++){var d=this.words[f],n=(16777215&(d<<i|r)).toString(16),a=0!==(r=d>>>24-i&16777215)||f!==this.length-1?u[6-n.length]+n+a:n+a;26<=(i+=2)&&(i-=26,f--)}for(0!==r&&(a=r.toString(16)+a);a.length%t!=0;)a="0"+a;return a=0!==this.negative?"-"+a:a}if(e===(0|e)&&2<=e&&e<=36){var s=b[e],c=l[e];for(a="",(h=this.clone()).negative=0;!h.isZero();){var h,o=h.modn(c).toString(e);a=(h=h.idivn(c)).isZero()?o+a:u[s-o.length]+o+a}for(this.isZero()&&(a="0"+a);a.length%t!=0;)a="0"+a;return a=0!==this.negative?"-"+a:a}p(!1,"Base should be between 2 and 36")},m.prototype.toNumber=function(){var e=this.words[0];return 2===this.length?e+=67108864*this.words[1]:3===this.length&&1===this.words[2]?e+=4503599627370496+67108864*this.words[1]:2<this.length&&p(!1,"Number can only safely store up to 53 bits"),0!==this.negative?-e:e},m.prototype.toJSON=function(){return this.toString(16)},m.prototype.toBuffer=function(e,t){return p(void 0!==r),this.toArrayLike(r,e,t)},m.prototype.toArray=function(e,t){return this.toArrayLike(Array,e,t)},m.prototype.toArrayLike=function(e,t,i){var r=this.byteLength(),f=i||Math.max(1,r);p(r<=f,"byte array longer than desired length"),p(0<f,"Requested array length <= 0"),this.strip();var d,n,t="le"===t,a=new e(f),s=this.clone();if(t){for(n=0;!s.isZero();n++)d=s.andln(255),s.iushrn(8),a[n]=d;for(;n<f;n++)a[n]=0}else{for(n=0;n<f-r;n++)a[n]=0;for(n=0;!s.isZero();n++)d=s.andln(255),s.iushrn(8),a[f-n-1]=d}return a},Math.clz32?m.prototype._countBits=function(e){return 32-Math.clz32(e)}:m.prototype._countBits=function(e){var t=e,e=0;return 4096<=t&&(e+=13,t>>>=13),64<=t&&(e+=7,t>>>=7),8<=t&&(e+=4,t>>>=4),2<=t&&(e+=2,t>>>=2),e+t},m.prototype._zeroBits=function(e){if(0===e)return 26;var t=e,e=0;return 0==(8191&t)&&(e+=13,t>>>=13),0==(127&t)&&(e+=7,t>>>=7),0==(15&t)&&(e+=4,t>>>=4),0==(3&t)&&(e+=2,t>>>=2),0==(1&t)&&e++,e},m.prototype.bitLength=function(){var e=this.words[this.length-1],e=this._countBits(e);return 26*(this.length-1)+e},m.prototype.zeroBits=function(){if(this.isZero())return 0;for(var e=0,t=0;t<this.length;t++){var i=this._zeroBits(this.words[t]);if(e+=i,26!==i)break}return e},m.prototype.byteLength=function(){return Math.ceil(this.bitLength()/8)},m.prototype.toTwos=function(e){return 0!==this.negative?this.abs().inotn(e).iaddn(1):this.clone()},m.prototype.fromTwos=function(e){return this.testn(e-1)?this.notn(e).iaddn(1).ineg():this.clone()},m.prototype.isNeg=function(){return 0!==this.negative},m.prototype.neg=function(){return this.clone().ineg()},m.prototype.ineg=function(){return this.isZero()||(this.negative^=1),this},m.prototype.iuor=function(e){for(;this.length<e.length;)this.words[this.length++]=0;for(var t=0;t<e.length;t++)this.words[t]=this.words[t]|e.words[t];return this.strip()},m.prototype.ior=function(e){return p(0==(this.negative|e.negative)),this.iuor(e)},m.prototype.or=function(e){return this.length>e.length?this.clone().ior(e):e.clone().ior(this)},m.prototype.uor=function(e){return this.length>e.length?this.clone().iuor(e):e.clone().iuor(this)},m.prototype.iuand=function(e){for(var t=this.length>e.length?e:this,i=0;i<t.length;i++)this.words[i]=this.words[i]&e.words[i];return this.length=t.length,this.strip()},m.prototype.iand=function(e){return p(0==(this.negative|e.negative)),this.iuand(e)},m.prototype.and=function(e){return this.length>e.length?this.clone().iand(e):e.clone().iand(this)},m.prototype.uand=function(e){return this.length>e.length?this.clone().iuand(e):e.clone().iuand(this)},m.prototype.iuxor=function(e){for(var t,i=this.length>e.length?(t=this,e):(t=e,this),r=0;r<i.length;r++)this.words[r]=t.words[r]^i.words[r];if(this!==t)for(;r<t.length;r++)this.words[r]=t.words[r];return this.length=t.length,this.strip()},m.prototype.ixor=function(e){return p(0==(this.negative|e.negative)),this.iuxor(e)},m.prototype.xor=function(e){return this.length>e.length?this.clone().ixor(e):e.clone().ixor(this)},m.prototype.uxor=function(e){return this.length>e.length?this.clone().iuxor(e):e.clone().iuxor(this)},m.prototype.inotn=function(e){p("number"==typeof e&&0<=e);var t=0|Math.ceil(e/26),e=e%26;this._expand(t),0<e&&t--;for(var i=0;i<t;i++)this.words[i]=67108863&~this.words[i];return 0<e&&(this.words[i]=~this.words[i]&67108863>>26-e),this.strip()},m.prototype.notn=function(e){return this.clone().inotn(e)},m.prototype.setn=function(e,t){p("number"==typeof e&&0<=e);var i=e/26|0,e=e%26;return this._expand(1+i),this.words[i]=t?this.words[i]|1<<e:this.words[i]&~(1<<e),this.strip()},m.prototype.iadd=function(e){var t,i,r;if(0!==this.negative&&0===e.negative)return this.negative=0,t=this.isub(e),this.negative^=1,this._normSign();if(0===this.negative&&0!==e.negative)return e.negative=0,t=this.isub(e),e.negative=1,t._normSign();r=this.length>e.length?(i=this,e):(i=e,this);for(var f=0,d=0;d<r.length;d++)t=(0|i.words[d])+(0|r.words[d])+f,this.words[d]=67108863&t,f=t>>>26;for(;0!==f&&d<i.length;d++)t=(0|i.words[d])+f,this.words[d]=67108863&t,f=t>>>26;if(this.length=i.length,0!==f)this.words[this.length]=f,this.length++;else if(i!==this)for(;d<i.length;d++)this.words[d]=i.words[d];return this},m.prototype.add=function(e){var t;return 0!==e.negative&&0===this.negative?(e.negative=0,t=this.sub(e),e.negative^=1,t):0===e.negative&&0!==this.negative?(this.negative=0,t=e.sub(this),this.negative=1,t):this.length>e.length?this.clone().iadd(e):e.clone().iadd(this)},m.prototype.isub=function(e){if(0!==e.negative){e.negative=0;var t=this.iadd(e);return e.negative=1,t._normSign()}if(0!==this.negative)return this.negative=0,this.iadd(e),this.negative=1,this._normSign();var i,r,f=this.cmp(e);if(0===f)return this.negative=0,this.length=1,this.words[0]=0,this;r=0<f?(i=this,e):(i=e,this);for(var d=0,n=0;n<r.length;n++)d=(t=(0|i.words[n])-(0|r.words[n])+d)>>26,this.words[n]=67108863&t;for(;0!==d&&n<i.length;n++)d=(t=(0|i.words[n])+d)>>26,this.words[n]=67108863&t;if(0===d&&n<i.length&&i!==this)for(;n<i.length;n++)this.words[n]=i.words[n];return this.length=Math.max(this.length,n),i!==this&&(this.negative=1),this.strip()},m.prototype.sub=function(e){return this.clone().isub(e)};var d=function(e,t,i){var r=e.words,f=t.words,d=i.words,n=0|r[0],a=8191&n,s=n>>>13,c=0|r[1],h=8191&c,o=c>>>13,u=0|r[2],b=8191&u,l=u>>>13,p=0|r[3],m=8191&p,v=p>>>13,g=0|r[4],y=8191&g,M=g>>>13,w=0|r[5],S=8191&w,_=w>>>13,A=0|r[6],x=8191&A,I=A>>>13,z=0|r[7],q=8191&z,R=z>>>13,k=0|r[8],P=8191&k,j=k>>>13,N=0|r[9],E=8191&N,B=N>>>13,L=0|f[0],O=8191&L,F=L>>>13,T=0|f[1],C=8191&T,Z=T>>>13,J=0|f[2],H=8191&J,D=J>>>13,X=0|f[3],K=8191&X,V=X>>>13,W=0|f[4],U=8191&W,Y=W>>>13,G=0|f[5],Q=8191&G,$=G>>>13,n=0|f[6],c=8191&n,u=n>>>13,p=0|f[7],g=8191&p,w=p>>>13,A=0|f[8],z=8191&A,k=A>>>13,r=0|f[9],N=8191&r,L=r>>>13;i.negative=e.negative^t.negative,i.length=19;var X=(0+Math.imul(a,O)|0)+((8191&(J=Math.imul(a,F)+Math.imul(s,O)|0))<<13)|0,ee=(Math.imul(s,F)+(J>>>13)|0)+(X>>>26)|0;X&=67108863,T=Math.imul(h,O),J=Math.imul(h,F)+Math.imul(o,O)|0,W=Math.imul(o,F);G=(ee+(T+Math.imul(a,C)|0)|0)+((8191&(J=(J+Math.imul(a,Z)|0)+Math.imul(s,C)|0))<<13)|0;ee=((W+Math.imul(s,Z)|0)+(J>>>13)|0)+(G>>>26)|0,G&=67108863,T=Math.imul(b,O),J=Math.imul(b,F)+Math.imul(l,O)|0,W=Math.imul(l,F),T=T+Math.imul(h,C)|0,J=(J+Math.imul(h,Z)|0)+Math.imul(o,C)|0,W=W+Math.imul(o,Z)|0;n=(ee+(T+Math.imul(a,H)|0)|0)+((8191&(J=(J+Math.imul(a,D)|0)+Math.imul(s,H)|0))<<13)|0;ee=((W+Math.imul(s,D)|0)+(J>>>13)|0)+(n>>>26)|0,n&=67108863,T=Math.imul(m,O),J=Math.imul(m,F)+Math.imul(v,O)|0,W=Math.imul(v,F),T=T+Math.imul(b,C)|0,J=(J+Math.imul(b,Z)|0)+Math.imul(l,C)|0,W=W+Math.imul(l,Z)|0,T=T+Math.imul(h,H)|0,J=(J+Math.imul(h,D)|0)+Math.imul(o,H)|0,W=W+Math.imul(o,D)|0;p=(ee+(T+Math.imul(a,K)|0)|0)+((8191&(J=(J+Math.imul(a,V)|0)+Math.imul(s,K)|0))<<13)|0;ee=((W+Math.imul(s,V)|0)+(J>>>13)|0)+(p>>>26)|0,p&=67108863,T=Math.imul(y,O),J=Math.imul(y,F)+Math.imul(M,O)|0,W=Math.imul(M,F),T=T+Math.imul(m,C)|0,J=(J+Math.imul(m,Z)|0)+Math.imul(v,C)|0,W=W+Math.imul(v,Z)|0,T=T+Math.imul(b,H)|0,J=(J+Math.imul(b,D)|0)+Math.imul(l,H)|0,W=W+Math.imul(l,D)|0,T=T+Math.imul(h,K)|0,J=(J+Math.imul(h,V)|0)+Math.imul(o,K)|0,W=W+Math.imul(o,V)|0;A=(ee+(T+Math.imul(a,U)|0)|0)+((8191&(J=(J+Math.imul(a,Y)|0)+Math.imul(s,U)|0))<<13)|0;ee=((W+Math.imul(s,Y)|0)+(J>>>13)|0)+(A>>>26)|0,A&=67108863,T=Math.imul(S,O),J=Math.imul(S,F)+Math.imul(_,O)|0,W=Math.imul(_,F),T=T+Math.imul(y,C)|0,J=(J+Math.imul(y,Z)|0)+Math.imul(M,C)|0,W=W+Math.imul(M,Z)|0,T=T+Math.imul(m,H)|0,J=(J+Math.imul(m,D)|0)+Math.imul(v,H)|0,W=W+Math.imul(v,D)|0,T=T+Math.imul(b,K)|0,J=(J+Math.imul(b,V)|0)+Math.imul(l,K)|0,W=W+Math.imul(l,V)|0,T=T+Math.imul(h,U)|0,J=(J+Math.imul(h,Y)|0)+Math.imul(o,U)|0,W=W+Math.imul(o,Y)|0;f=(ee+(T+Math.imul(a,Q)|0)|0)+((8191&(J=(J+Math.imul(a,$)|0)+Math.imul(s,Q)|0))<<13)|0;ee=((W+Math.imul(s,$)|0)+(J>>>13)|0)+(f>>>26)|0,f&=67108863,T=Math.imul(x,O),J=Math.imul(x,F)+Math.imul(I,O)|0,W=Math.imul(I,F),T=T+Math.imul(S,C)|0,J=(J+Math.imul(S,Z)|0)+Math.imul(_,C)|0,W=W+Math.imul(_,Z)|0,T=T+Math.imul(y,H)|0,J=(J+Math.imul(y,D)|0)+Math.imul(M,H)|0,W=W+Math.imul(M,D)|0,T=T+Math.imul(m,K)|0,J=(J+Math.imul(m,V)|0)+Math.imul(v,K)|0,W=W+Math.imul(v,V)|0,T=T+Math.imul(b,U)|0,J=(J+Math.imul(b,Y)|0)+Math.imul(l,U)|0,W=W+Math.imul(l,Y)|0,T=T+Math.imul(h,Q)|0,J=(J+Math.imul(h,$)|0)+Math.imul(o,Q)|0,W=W+Math.imul(o,$)|0;r=(ee+(T+Math.imul(a,c)|0)|0)+((8191&(J=(J+Math.imul(a,u)|0)+Math.imul(s,c)|0))<<13)|0;ee=((W+Math.imul(s,u)|0)+(J>>>13)|0)+(r>>>26)|0,r&=67108863,T=Math.imul(q,O),J=Math.imul(q,F)+Math.imul(R,O)|0,W=Math.imul(R,F),T=T+Math.imul(x,C)|0,J=(J+Math.imul(x,Z)|0)+Math.imul(I,C)|0,W=W+Math.imul(I,Z)|0,T=T+Math.imul(S,H)|0,J=(J+Math.imul(S,D)|0)+Math.imul(_,H)|0,W=W+Math.imul(_,D)|0,T=T+Math.imul(y,K)|0,J=(J+Math.imul(y,V)|0)+Math.imul(M,K)|0,W=W+Math.imul(M,V)|0,T=T+Math.imul(m,U)|0,J=(J+Math.imul(m,Y)|0)+Math.imul(v,U)|0,W=W+Math.imul(v,Y)|0,T=T+Math.imul(b,Q)|0,J=(J+Math.imul(b,$)|0)+Math.imul(l,Q)|0,W=W+Math.imul(l,$)|0,T=T+Math.imul(h,c)|0,J=(J+Math.imul(h,u)|0)+Math.imul(o,c)|0,W=W+Math.imul(o,u)|0;e=(ee+(T+Math.imul(a,g)|0)|0)+((8191&(J=(J+Math.imul(a,w)|0)+Math.imul(s,g)|0))<<13)|0;ee=((W+Math.imul(s,w)|0)+(J>>>13)|0)+(e>>>26)|0,e&=67108863,T=Math.imul(P,O),J=Math.imul(P,F)+Math.imul(j,O)|0,W=Math.imul(j,F),T=T+Math.imul(q,C)|0,J=(J+Math.imul(q,Z)|0)+Math.imul(R,C)|0,W=W+Math.imul(R,Z)|0,T=T+Math.imul(x,H)|0,J=(J+Math.imul(x,D)|0)+Math.imul(I,H)|0,W=W+Math.imul(I,D)|0,T=T+Math.imul(S,K)|0,J=(J+Math.imul(S,V)|0)+Math.imul(_,K)|0,W=W+Math.imul(_,V)|0,T=T+Math.imul(y,U)|0,J=(J+Math.imul(y,Y)|0)+Math.imul(M,U)|0,W=W+Math.imul(M,Y)|0,T=T+Math.imul(m,Q)|0,J=(J+Math.imul(m,$)|0)+Math.imul(v,Q)|0,W=W+Math.imul(v,$)|0,T=T+Math.imul(b,c)|0,J=(J+Math.imul(b,u)|0)+Math.imul(l,c)|0,W=W+Math.imul(l,u)|0,T=T+Math.imul(h,g)|0,J=(J+Math.imul(h,w)|0)+Math.imul(o,g)|0,W=W+Math.imul(o,w)|0;t=(ee+(T+Math.imul(a,z)|0)|0)+((8191&(J=(J+Math.imul(a,k)|0)+Math.imul(s,z)|0))<<13)|0;ee=((W+Math.imul(s,k)|0)+(J>>>13)|0)+(t>>>26)|0,t&=67108863,T=Math.imul(E,O),J=Math.imul(E,F)+Math.imul(B,O)|0,W=Math.imul(B,F),T=T+Math.imul(P,C)|0,J=(J+Math.imul(P,Z)|0)+Math.imul(j,C)|0,W=W+Math.imul(j,Z)|0,T=T+Math.imul(q,H)|0,J=(J+Math.imul(q,D)|0)+Math.imul(R,H)|0,W=W+Math.imul(R,D)|0,T=T+Math.imul(x,K)|0,J=(J+Math.imul(x,V)|0)+Math.imul(I,K)|0,W=W+Math.imul(I,V)|0,T=T+Math.imul(S,U)|0,J=(J+Math.imul(S,Y)|0)+Math.imul(_,U)|0,W=W+Math.imul(_,Y)|0,T=T+Math.imul(y,Q)|0,J=(J+Math.imul(y,$)|0)+Math.imul(M,Q)|0,W=W+Math.imul(M,$)|0,T=T+Math.imul(m,c)|0,J=(J+Math.imul(m,u)|0)+Math.imul(v,c)|0,W=W+Math.imul(v,u)|0,T=T+Math.imul(b,g)|0,J=(J+Math.imul(b,w)|0)+Math.imul(l,g)|0,W=W+Math.imul(l,w)|0,T=T+Math.imul(h,z)|0,J=(J+Math.imul(h,k)|0)+Math.imul(o,z)|0,W=W+Math.imul(o,k)|0;a=(ee+(T+Math.imul(a,N)|0)|0)+((8191&(J=(J+Math.imul(a,L)|0)+Math.imul(s,N)|0))<<13)|0;ee=((W+Math.imul(s,L)|0)+(J>>>13)|0)+(a>>>26)|0,a&=67108863,T=Math.imul(E,C),J=Math.imul(E,Z)+Math.imul(B,C)|0,W=Math.imul(B,Z),T=T+Math.imul(P,H)|0,J=(J+Math.imul(P,D)|0)+Math.imul(j,H)|0,W=W+Math.imul(j,D)|0,T=T+Math.imul(q,K)|0,J=(J+Math.imul(q,V)|0)+Math.imul(R,K)|0,W=W+Math.imul(R,V)|0,T=T+Math.imul(x,U)|0,J=(J+Math.imul(x,Y)|0)+Math.imul(I,U)|0,W=W+Math.imul(I,Y)|0,T=T+Math.imul(S,Q)|0,J=(J+Math.imul(S,$)|0)+Math.imul(_,Q)|0,W=W+Math.imul(_,$)|0,T=T+Math.imul(y,c)|0,J=(J+Math.imul(y,u)|0)+Math.imul(M,c)|0,W=W+Math.imul(M,u)|0,T=T+Math.imul(m,g)|0,J=(J+Math.imul(m,w)|0)+Math.imul(v,g)|0,W=W+Math.imul(v,w)|0,T=T+Math.imul(b,z)|0,J=(J+Math.imul(b,k)|0)+Math.imul(l,z)|0,W=W+Math.imul(l,k)|0;h=(ee+(T+Math.imul(h,N)|0)|0)+((8191&(J=(J+Math.imul(h,L)|0)+Math.imul(o,N)|0))<<13)|0;ee=((W+Math.imul(o,L)|0)+(J>>>13)|0)+(h>>>26)|0,h&=67108863,T=Math.imul(E,H),J=Math.imul(E,D)+Math.imul(B,H)|0,W=Math.imul(B,D),T=T+Math.imul(P,K)|0,J=(J+Math.imul(P,V)|0)+Math.imul(j,K)|0,W=W+Math.imul(j,V)|0,T=T+Math.imul(q,U)|0,J=(J+Math.imul(q,Y)|0)+Math.imul(R,U)|0,W=W+Math.imul(R,Y)|0,T=T+Math.imul(x,Q)|0,J=(J+Math.imul(x,$)|0)+Math.imul(I,Q)|0,W=W+Math.imul(I,$)|0,T=T+Math.imul(S,c)|0,J=(J+Math.imul(S,u)|0)+Math.imul(_,c)|0,W=W+Math.imul(_,u)|0,T=T+Math.imul(y,g)|0,J=(J+Math.imul(y,w)|0)+Math.imul(M,g)|0,W=W+Math.imul(M,w)|0,T=T+Math.imul(m,z)|0,J=(J+Math.imul(m,k)|0)+Math.imul(v,z)|0,W=W+Math.imul(v,k)|0;b=(ee+(T+Math.imul(b,N)|0)|0)+((8191&(J=(J+Math.imul(b,L)|0)+Math.imul(l,N)|0))<<13)|0;ee=((W+Math.imul(l,L)|0)+(J>>>13)|0)+(b>>>26)|0,b&=67108863,T=Math.imul(E,K),J=Math.imul(E,V)+Math.imul(B,K)|0,W=Math.imul(B,V),T=T+Math.imul(P,U)|0,J=(J+Math.imul(P,Y)|0)+Math.imul(j,U)|0,W=W+Math.imul(j,Y)|0,T=T+Math.imul(q,Q)|0,J=(J+Math.imul(q,$)|0)+Math.imul(R,Q)|0,W=W+Math.imul(R,$)|0,T=T+Math.imul(x,c)|0,J=(J+Math.imul(x,u)|0)+Math.imul(I,c)|0,W=W+Math.imul(I,u)|0,T=T+Math.imul(S,g)|0,J=(J+Math.imul(S,w)|0)+Math.imul(_,g)|0,W=W+Math.imul(_,w)|0,T=T+Math.imul(y,z)|0,J=(J+Math.imul(y,k)|0)+Math.imul(M,z)|0,W=W+Math.imul(M,k)|0;m=(ee+(T+Math.imul(m,N)|0)|0)+((8191&(J=(J+Math.imul(m,L)|0)+Math.imul(v,N)|0))<<13)|0;ee=((W+Math.imul(v,L)|0)+(J>>>13)|0)+(m>>>26)|0,m&=67108863,T=Math.imul(E,U),J=Math.imul(E,Y)+Math.imul(B,U)|0,W=Math.imul(B,Y),T=T+Math.imul(P,Q)|0,J=(J+Math.imul(P,$)|0)+Math.imul(j,Q)|0,W=W+Math.imul(j,$)|0,T=T+Math.imul(q,c)|0,J=(J+Math.imul(q,u)|0)+Math.imul(R,c)|0,W=W+Math.imul(R,u)|0,T=T+Math.imul(x,g)|0,J=(J+Math.imul(x,w)|0)+Math.imul(I,g)|0,W=W+Math.imul(I,w)|0,T=T+Math.imul(S,z)|0,J=(J+Math.imul(S,k)|0)+Math.imul(_,z)|0,W=W+Math.imul(_,k)|0;y=(ee+(T+Math.imul(y,N)|0)|0)+((8191&(J=(J+Math.imul(y,L)|0)+Math.imul(M,N)|0))<<13)|0;ee=((W+Math.imul(M,L)|0)+(J>>>13)|0)+(y>>>26)|0,y&=67108863,T=Math.imul(E,Q),J=Math.imul(E,$)+Math.imul(B,Q)|0,W=Math.imul(B,$),T=T+Math.imul(P,c)|0,J=(J+Math.imul(P,u)|0)+Math.imul(j,c)|0,W=W+Math.imul(j,u)|0,T=T+Math.imul(q,g)|0,J=(J+Math.imul(q,w)|0)+Math.imul(R,g)|0,W=W+Math.imul(R,w)|0,T=T+Math.imul(x,z)|0,J=(J+Math.imul(x,k)|0)+Math.imul(I,z)|0,W=W+Math.imul(I,k)|0;S=(ee+(T+Math.imul(S,N)|0)|0)+((8191&(J=(J+Math.imul(S,L)|0)+Math.imul(_,N)|0))<<13)|0;ee=((W+Math.imul(_,L)|0)+(J>>>13)|0)+(S>>>26)|0,S&=67108863,T=Math.imul(E,c),J=Math.imul(E,u)+Math.imul(B,c)|0,W=Math.imul(B,u),T=T+Math.imul(P,g)|0,J=(J+Math.imul(P,w)|0)+Math.imul(j,g)|0,W=W+Math.imul(j,w)|0,T=T+Math.imul(q,z)|0,J=(J+Math.imul(q,k)|0)+Math.imul(R,z)|0,W=W+Math.imul(R,k)|0;x=(ee+(T+Math.imul(x,N)|0)|0)+((8191&(J=(J+Math.imul(x,L)|0)+Math.imul(I,N)|0))<<13)|0;ee=((W+Math.imul(I,L)|0)+(J>>>13)|0)+(x>>>26)|0,x&=67108863,T=Math.imul(E,g),J=Math.imul(E,w)+Math.imul(B,g)|0,W=Math.imul(B,w),T=T+Math.imul(P,z)|0,J=(J+Math.imul(P,k)|0)+Math.imul(j,z)|0,W=W+Math.imul(j,k)|0;q=(ee+(T+Math.imul(q,N)|0)|0)+((8191&(J=(J+Math.imul(q,L)|0)+Math.imul(R,N)|0))<<13)|0;ee=((W+Math.imul(R,L)|0)+(J>>>13)|0)+(q>>>26)|0,q&=67108863,T=Math.imul(E,z),J=Math.imul(E,k)+Math.imul(B,z)|0,W=Math.imul(B,k);P=(ee+(T+Math.imul(P,N)|0)|0)+((8191&(J=(J+Math.imul(P,L)|0)+Math.imul(j,N)|0))<<13)|0;ee=((W+Math.imul(j,L)|0)+(J>>>13)|0)+(P>>>26)|0,P&=67108863;N=(ee+Math.imul(E,N)|0)+((8191&(J=Math.imul(E,L)+Math.imul(B,N)|0))<<13)|0;return ee=(Math.imul(B,L)+(J>>>13)|0)+(N>>>26)|0,N&=67108863,d[0]=X,d[1]=G,d[2]=n,d[3]=p,d[4]=A,d[5]=f,d[6]=r,d[7]=e,d[8]=t,d[9]=a,d[10]=h,d[11]=b,d[12]=m,d[13]=y,d[14]=S,d[15]=x,d[16]=q,d[17]=P,d[18]=N,0!=ee&&(d[19]=ee,i.length++),i};function a(e,t,i){return(new s).mulp(e,t,i)}function s(e,t){this.x=e,this.y=t}Math.imul||(d=f),m.prototype.mulTo=function(e,t){var i=this.length+e.length,t=(10===this.length&&10===e.length?d:i<63?f:i<1024?function(e,t,i){i.negative=t.negative^e.negative,i.length=e.length+t.length;for(var r=0,f=0,d=0;d<i.length-1;d++){for(var n=f,f=0,a=67108863&r,s=Math.min(d,t.length-1),c=Math.max(0,d-e.length+1);c<=s;c++){var h=d-c,o=(0|e.words[h])*(0|t.words[c]),h=67108863&o,a=67108863&(h=h+a|0);f+=(n=(n=n+(o/67108864|0)|0)+(h>>>26)|0)>>>26,n&=67108863}i.words[d]=a,r=n,n=f}return 0!==r?i.words[d]=r:i.length--,i.strip()}:a)(this,e,t);return t},s.prototype.makeRBT=function(e){for(var t=new Array(e),i=m.prototype._countBits(e)-1,r=0;r<e;r++)t[r]=this.revBin(r,i,e);return t},s.prototype.revBin=function(e,t,i){if(0===e||e===i-1)return e;for(var r=0,f=0;f<t;f++)r|=(1&e)<<t-f-1,e>>=1;return r},s.prototype.permute=function(e,t,i,r,f,d){for(var n=0;n<d;n++)r[n]=t[e[n]],f[n]=i[e[n]]},s.prototype.transform=function(e,t,i,r,f,d){this.permute(d,e,t,i,r,f);for(var n=1;n<f;n<<=1)for(var a=n<<1,s=Math.cos(2*Math.PI/a),c=Math.sin(2*Math.PI/a),h=0;h<f;h+=a)for(var o=s,u=c,b=0;b<n;b++){var l=i[h+b],p=r[h+b],m=o*(g=i[h+b+n])-u*(v=r[h+b+n]),v=o*v+u*g,g=m;i[h+b]=l+g,r[h+b]=p+v,i[h+b+n]=l-g,r[h+b+n]=p-v,b!==a&&(m=s*o-c*u,u=s*u+c*o,o=m)}},s.prototype.guessLen13b=function(e,t){for(var e=1&(r=1|Math.max(t,e)),i=0,r=r/2|0;r;r>>>=1)i++;return 1<<i+1+e},s.prototype.conjugate=function(e,t,i){if(!(i<=1))for(var r=0;r<i/2;r++){var f=e[r];e[r]=e[i-r-1],e[i-r-1]=f,f=t[r],t[r]=-t[i-r-1],t[i-r-1]=-f}},s.prototype.normalize13b=function(e,t){for(var i=0,r=0;r<t/2;r++){var f=8192*Math.round(e[2*r+1]/t)+Math.round(e[2*r]/t)+i;e[r]=67108863&f,i=f<67108864?0:f/67108864|0}return e},s.prototype.convert13b=function(e,t,i,r){for(var f=0,d=0;d<t;d++)f+=0|e[d],i[2*d]=8191&f,f>>>=13,i[2*d+1]=8191&f,f>>>=13;for(d=2*t;d<r;++d)i[d]=0;p(0===f),p(0==(-8192&f))},s.prototype.stub=function(e){for(var t=new Array(e),i=0;i<e;i++)t[i]=0;return t},s.prototype.mulp=function(e,t,i){var r=2*this.guessLen13b(e.length,t.length),f=this.makeRBT(r),d=this.stub(r),n=new Array(r),a=new Array(r),s=new Array(r),c=new Array(r),h=new Array(r),o=new Array(r),u=i.words;u.length=r,this.convert13b(e.words,e.length,n,r),this.convert13b(t.words,t.length,c,r),this.transform(n,d,a,s,r,f),this.transform(c,d,h,o,r,f);for(var b=0;b<r;b++){var l=a[b]*h[b]-s[b]*o[b];s[b]=a[b]*o[b]+s[b]*h[b],a[b]=l}return this.conjugate(a,s,r),this.transform(a,s,u,d,r,f),this.conjugate(u,d,r),this.normalize13b(u,r),i.negative=e.negative^t.negative,i.length=e.length+t.length,i.strip()},m.prototype.mul=function(e){var t=new m(null);return t.words=new Array(this.length+e.length),this.mulTo(e,t)},m.prototype.mulf=function(e){var t=new m(null);return t.words=new Array(this.length+e.length),a(this,e,t)},m.prototype.imul=function(e){return this.clone().mulTo(e,this)},m.prototype.imuln=function(e){p("number"==typeof e),p(e<67108864);for(var t=0,i=0;i<this.length;i++){var r=(0|this.words[i])*e,f=(67108863&r)+(67108863&t);t>>=26,t+=r/67108864|0,t+=f>>>26,this.words[i]=67108863&f}return 0!==t&&(this.words[i]=t,this.length++),this},m.prototype.muln=function(e){return this.clone().imuln(e)},m.prototype.sqr=function(){return this.mul(this)},m.prototype.isqr=function(){return this.imul(this.clone())},m.prototype.pow=function(e){var t=function(e){for(var t=new Array(e.bitLength()),i=0;i<t.length;i++){var r=i/26|0,f=i%26;t[i]=(e.words[r]&1<<f)>>>f}return t}(e);if(0===t.length)return new m(1);for(var i=this,r=0;r<t.length&&0===t[r];r++,i=i.sqr());if(++r<t.length)for(var f=i.sqr();r<t.length;r++,f=f.sqr())0!==t[r]&&(i=i.mul(f));return i},m.prototype.iushln=function(e){p("number"==typeof e&&0<=e);var t=e%26,i=(e-t)/26,r=67108863>>>26-t<<26-t;if(0!=t){for(var f=0,d=0;d<this.length;d++){var n=this.words[d]&r,a=(0|this.words[d])-n<<t;this.words[d]=a|f,f=n>>>26-t}f&&(this.words[d]=f,this.length++)}if(0!=i){for(d=this.length-1;0<=d;d--)this.words[d+i]=this.words[d];for(d=0;d<i;d++)this.words[d]=0;this.length+=i}return this.strip()},m.prototype.ishln=function(e){return p(0===this.negative),this.iushln(e)},m.prototype.iushrn=function(e,t,i){var r;p("number"==typeof e&&0<=e),r=t?(t-t%26)/26:0;var f=e%26,d=Math.min((e-f)/26,this.length),n=67108863^67108863>>>f<<f,a=i;if(r-=d,r=Math.max(0,r),a){for(var s=0;s<d;s++)a.words[s]=this.words[s];a.length=d}if(0!==d)if(this.length>d)for(this.length-=d,s=0;s<this.length;s++)this.words[s]=this.words[s+d];else this.words[0]=0,this.length=1;for(var c=0,s=this.length-1;0<=s&&(0!==c||r<=s);s--){var h=0|this.words[s];this.words[s]=c<<26-f|h>>>f,c=h&n}return a&&0!==c&&(a.words[a.length++]=c),0===this.length&&(this.words[0]=0,this.length=1),this.strip()},m.prototype.ishrn=function(e,t,i){return p(0===this.negative),this.iushrn(e,t,i)},m.prototype.shln=function(e){return this.clone().ishln(e)},m.prototype.ushln=function(e){return this.clone().iushln(e)},m.prototype.shrn=function(e){return this.clone().ishrn(e)},m.prototype.ushrn=function(e){return this.clone().iushrn(e)},m.prototype.testn=function(e){p("number"==typeof e&&0<=e);var t=e%26,e=(e-t)/26,t=1<<t;return!(this.length<=e)&&!!(this.words[e]&t)},m.prototype.imaskn=function(e){p("number"==typeof e&&0<=e);var t=e%26,e=(e-t)/26;return p(0===this.negative,"imaskn works only with positive numbers"),this.length<=e?this:(0!=t&&e++,this.length=Math.min(e,this.length),0!=t&&(t=67108863^67108863>>>t<<t,this.words[this.length-1]&=t),this.strip())},m.prototype.maskn=function(e){return this.clone().imaskn(e)},m.prototype.iaddn=function(e){return p("number"==typeof e),p(e<67108864),e<0?this.isubn(-e):0!==this.negative?(1===this.length&&(0|this.words[0])<e?(this.words[0]=e-(0|this.words[0]),this.negative=0):(this.negative=0,this.isubn(e),this.negative=1),this):this._iaddn(e)},m.prototype._iaddn=function(e){this.words[0]+=e;for(var t=0;t<this.length&&67108864<=this.words[t];t++)this.words[t]-=67108864,t===this.length-1?this.words[t+1]=1:this.words[t+1]++;return this.length=Math.max(this.length,t+1),this},m.prototype.isubn=function(e){if(p("number"==typeof e),p(e<67108864),e<0)return this.iaddn(-e);if(0!==this.negative)return this.negative=0,this.iaddn(e),this.negative=1,this;if(this.words[0]-=e,1===this.length&&this.words[0]<0)this.words[0]=-this.words[0],this.negative=1;else for(var t=0;t<this.length&&this.words[t]<0;t++)this.words[t]+=67108864,--this.words[t+1];return this.strip()},m.prototype.addn=function(e){return this.clone().iaddn(e)},m.prototype.subn=function(e){return this.clone().isubn(e)},m.prototype.iabs=function(){return this.negative=0,this},m.prototype.abs=function(){return this.clone().iabs()},m.prototype._ishlnsubmul=function(e,t,i){var r,f=e.length+i;this._expand(f);for(var d=0,n=0;n<e.length;n++){r=(0|this.words[n+i])+d;var a=(0|e.words[n])*t,d=((r-=67108863&a)>>26)-(a/67108864|0);this.words[n+i]=67108863&r}for(;n<this.length-i;n++)d=(r=(0|this.words[n+i])+d)>>26,this.words[n+i]=67108863&r;if(0===d)return this.strip();for(p(-1===d),n=d=0;n<this.length;n++)d=(r=-(0|this.words[n])+d)>>26,this.words[n]=67108863&r;return this.negative=1,this.strip()},m.prototype._wordDiv=function(e,t){var i=this.length-e.length,r=this.clone(),f=e,d=0|f.words[f.length-1];0!=(i=26-this._countBits(d))&&(f=f.ushln(i),r.iushln(i),d=0|f.words[f.length-1]);var n,a=r.length-f.length;if("mod"!==t){(n=new m(null)).length=1+a,n.words=new Array(n.length);for(var s=0;s<n.length;s++)n.words[s]=0}e=r.clone()._ishlnsubmul(f,1,a);0===e.negative&&(r=e,n&&(n.words[a]=1));for(var c=a-1;0<=c;c--){var h=67108864*(0|r.words[f.length+c])+(0|r.words[f.length+c-1]),h=Math.min(h/d|0,67108863);for(r._ishlnsubmul(f,h,c);0!==r.negative;)h--,r.negative=0,r._ishlnsubmul(f,1,c),r.isZero()||(r.negative^=1);n&&(n.words[c]=h)}return n&&n.strip(),r.strip(),"div"!==t&&0!=i&&r.iushrn(i),{div:n||null,mod:r}},m.prototype.divmod=function(e,t,i){return p(!e.isZero()),this.isZero()?{div:new m(0),mod:new m(0)}:0!==this.negative&&0===e.negative?(d=this.neg().divmod(e,t),"mod"!==t&&(r=d.div.neg()),"div"!==t&&(f=d.mod.neg(),i&&0!==f.negative&&f.iadd(e)),{div:r,mod:f}):0===this.negative&&0!==e.negative?(d=this.divmod(e.neg(),t),{div:r="mod"!==t?d.div.neg():r,mod:d.mod}):0!=(this.negative&e.negative)?(d=this.neg().divmod(e.neg(),t),"div"!==t&&(f=d.mod.neg(),i&&0!==f.negative&&f.isub(e)),{div:d.div,mod:f}):e.length>this.length||this.cmp(e)<0?{div:new m(0),mod:this}:1===e.length?"div"===t?{div:this.divn(e.words[0]),mod:null}:"mod"===t?{div:null,mod:new m(this.modn(e.words[0]))}:{div:this.divn(e.words[0]),mod:new m(this.modn(e.words[0]))}:this._wordDiv(e,t);var r,f,d},m.prototype.div=function(e){return this.divmod(e,"div",!1).div},m.prototype.mod=function(e){return this.divmod(e,"mod",!1).mod},m.prototype.umod=function(e){return this.divmod(e,"mod",!0).mod},m.prototype.divRound=function(e){var t=this.divmod(e);if(t.mod.isZero())return t.div;var i=0!==t.div.negative?t.mod.isub(e):t.mod,r=e.ushrn(1),e=e.andln(1),r=i.cmp(r);return r<0||1===e&&0===r?t.div:0!==t.div.negative?t.div.isubn(1):t.div.iaddn(1)},m.prototype.modn=function(e){p(e<=67108863);for(var t=(1<<26)%e,i=0,r=this.length-1;0<=r;r--)i=(t*i+(0|this.words[r]))%e;return i},m.prototype.idivn=function(e){p(e<=67108863);for(var t=0,i=this.length-1;0<=i;i--){var r=(0|this.words[i])+67108864*t;this.words[i]=r/e|0,t=r%e}return this.strip()},m.prototype.divn=function(e){return this.clone().idivn(e)},m.prototype.egcd=function(e){p(0===e.negative),p(!e.isZero());for(var t=this,i=e.clone(),t=0!==t.negative?t.umod(e):t.clone(),r=new m(1),f=new m(0),d=new m(0),n=new m(1),a=0;t.isEven()&&i.isEven();)t.iushrn(1),i.iushrn(1),++a;for(var s=i.clone(),c=t.clone();!t.isZero();){for(var h=0,o=1;0==(t.words[0]&o)&&h<26;++h,o<<=1);if(0<h)for(t.iushrn(h);0<h--;)(r.isOdd()||f.isOdd())&&(r.iadd(s),f.isub(c)),r.iushrn(1),f.iushrn(1);for(var u=0,b=1;0==(i.words[0]&b)&&u<26;++u,b<<=1);if(0<u)for(i.iushrn(u);0<u--;)(d.isOdd()||n.isOdd())&&(d.iadd(s),n.isub(c)),d.iushrn(1),n.iushrn(1);0<=t.cmp(i)?(t.isub(i),r.isub(d),f.isub(n)):(i.isub(t),d.isub(r),n.isub(f))}return{a:d,b:n,gcd:i.iushln(a)}},m.prototype._invmp=function(e){p(0===e.negative),p(!e.isZero());for(var t,i=this,r=e.clone(),i=0!==i.negative?i.umod(e):i.clone(),f=new m(1),d=new m(0),n=r.clone();0<i.cmpn(1)&&0<r.cmpn(1);){for(var a=0,s=1;0==(i.words[0]&s)&&a<26;++a,s<<=1);if(0<a)for(i.iushrn(a);0<a--;)f.isOdd()&&f.iadd(n),f.iushrn(1);for(var c=0,h=1;0==(r.words[0]&h)&&c<26;++c,h<<=1);if(0<c)for(r.iushrn(c);0<c--;)d.isOdd()&&d.iadd(n),d.iushrn(1);0<=i.cmp(r)?(i.isub(r),f.isub(d)):(r.isub(i),d.isub(f))}return(t=0===i.cmpn(1)?f:d).cmpn(0)<0&&t.iadd(e),t},m.prototype.gcd=function(e){if(this.isZero())return e.abs();if(e.isZero())return this.abs();var t=this.clone(),i=e.clone();t.negative=0;for(var r=i.negative=0;t.isEven()&&i.isEven();r++)t.iushrn(1),i.iushrn(1);for(;;){for(;t.isEven();)t.iushrn(1);for(;i.isEven();)i.iushrn(1);var f=t.cmp(i);if(f<0)var d=t,t=i,i=d;else if(0===f||0===i.cmpn(1))break;t.isub(i)}return i.iushln(r)},m.prototype.invm=function(e){return this.egcd(e).a.umod(e)},m.prototype.isEven=function(){return 0==(1&this.words[0])},m.prototype.isOdd=function(){return 1==(1&this.words[0])},m.prototype.andln=function(e){return this.words[0]&e},m.prototype.bincn=function(e){p("number"==typeof e);var t=e%26,e=(e-t)/26,t=1<<t;if(this.length<=e)return this._expand(1+e),this.words[e]|=t,this;for(var i=t,r=e;0!==i&&r<this.length;r++){var f=0|this.words[r],i=(f+=i)>>>26;f&=67108863,this.words[r]=f}return 0!==i&&(this.words[r]=i,this.length++),this},m.prototype.isZero=function(){return 1===this.length&&0===this.words[0]},m.prototype.cmpn=function(e){var t=e<0;return 0===this.negative||t?0===this.negative&&t?1:(this.strip(),e=1<this.length?1:(p((e=t?-e:e)<=67108863,"Number is too big"),(t=0|this.words[0])===e?0:t<e?-1:1),0!==this.negative?0|-e:e):-1},m.prototype.cmp=function(e){if(0!==this.negative&&0===e.negative)return-1;if(0===this.negative&&0!==e.negative)return 1;e=this.ucmp(e);return 0!==this.negative?0|-e:e},m.prototype.ucmp=function(e){if(this.length>e.length)return 1;if(this.length<e.length)return-1;for(var t=0,i=this.length-1;0<=i;i--){var r=0|this.words[i],f=0|e.words[i];if(r!=f){r<f?t=-1:f<r&&(t=1);break}}return t},m.prototype.gtn=function(e){return 1===this.cmpn(e)},m.prototype.gt=function(e){return 1===this.cmp(e)},m.prototype.gten=function(e){return 0<=this.cmpn(e)},m.prototype.gte=function(e){return 0<=this.cmp(e)},m.prototype.ltn=function(e){return-1===this.cmpn(e)},m.prototype.lt=function(e){return-1===this.cmp(e)},m.prototype.lten=function(e){return this.cmpn(e)<=0},m.prototype.lte=function(e){return this.cmp(e)<=0},m.prototype.eqn=function(e){return 0===this.cmpn(e)},m.prototype.eq=function(e){return 0===this.cmp(e)},m.red=function(e){return new w(e)},m.prototype.toRed=function(e){return p(!this.red,"Already a number in reduction context"),p(0===this.negative,"red works only with positives"),e.convertTo(this)._forceRed(e)},m.prototype.fromRed=function(){return p(this.red,"fromRed works only with numbers in reduction context"),this.red.convertFrom(this)},m.prototype._forceRed=function(e){return this.red=e,this},m.prototype.forceRed=function(e){return p(!this.red,"Already a number in reduction context"),this._forceRed(e)},m.prototype.redAdd=function(e){return p(this.red,"redAdd works only with red numbers"),this.red.add(this,e)},m.prototype.redIAdd=function(e){return p(this.red,"redIAdd works only with red numbers"),this.red.iadd(this,e)},m.prototype.redSub=function(e){return p(this.red,"redSub works only with red numbers"),this.red.sub(this,e)},m.prototype.redISub=function(e){return p(this.red,"redISub works only with red numbers"),this.red.isub(this,e)},m.prototype.redShl=function(e){return p(this.red,"redShl works only with red numbers"),this.red.shl(this,e)},m.prototype.redMul=function(e){return p(this.red,"redMul works only with red numbers"),this.red._verify2(this,e),this.red.mul(this,e)},m.prototype.redIMul=function(e){return p(this.red,"redMul works only with red numbers"),this.red._verify2(this,e),this.red.imul(this,e)},m.prototype.redSqr=function(){return p(this.red,"redSqr works only with red numbers"),this.red._verify1(this),this.red.sqr(this)},m.prototype.redISqr=function(){return p(this.red,"redISqr works only with red numbers"),this.red._verify1(this),this.red.isqr(this)},m.prototype.redSqrt=function(){return p(this.red,"redSqrt works only with red numbers"),this.red._verify1(this),this.red.sqrt(this)},m.prototype.redInvm=function(){return p(this.red,"redInvm works only with red numbers"),this.red._verify1(this),this.red.invm(this)},m.prototype.redNeg=function(){return p(this.red,"redNeg works only with red numbers"),this.red._verify1(this),this.red.neg(this)},m.prototype.redPow=function(e){return p(this.red&&!e.red,"redPow(normalNum)"),this.red._verify1(this),this.red.pow(this,e)};var c={k256:null,p224:null,p192:null,p25519:null};function h(e,t){this.name=e,this.p=new m(t,16),this.n=this.p.bitLength(),this.k=new m(1).iushln(this.n).isub(this.p),this.tmp=this._tmp()}function v(){h.call(this,"k256","ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")}function g(){h.call(this,"p224","ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")}function y(){h.call(this,"p192","ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")}function M(){h.call(this,"25519","7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")}function w(e){var t;"string"==typeof e?(t=m._prime(e),this.m=t.p,this.prime=t):(p(e.gtn(1),"modulus must be greater than 1"),this.m=e,this.prime=null)}function S(e){w.call(this,e),this.shift=this.m.bitLength(),this.shift%26!=0&&(this.shift+=26-this.shift%26),this.r=new m(1).iushln(this.shift),this.r2=this.imod(this.r.sqr()),this.rinv=this.r._invmp(this.m),this.minv=this.rinv.mul(this.r).isubn(1).div(this.m),this.minv=this.minv.umod(this.r),this.minv=this.r.sub(this.minv)}h.prototype._tmp=function(){var e=new m(null);return e.words=new Array(Math.ceil(this.n/13)),e},h.prototype.ireduce=function(e){for(var t,i=e;this.split(i,this.tmp),t=(i=(i=this.imulK(i)).iadd(this.tmp)).bitLength(),t>this.n;);e=t<this.n?-1:i.ucmp(this.p);return 0===e?(i.words[0]=0,i.length=1):0<e?i.isub(this.p):void 0!==i.strip?i.strip():i._strip(),i},h.prototype.split=function(e,t){e.iushrn(this.n,0,t)},h.prototype.imulK=function(e){return e.imul(this.k)},i(v,h),v.prototype.split=function(e,t){for(var i=Math.min(e.length,9),r=0;r<i;r++)t.words[r]=e.words[r];if(t.length=i,e.length<=9)return e.words[0]=0,void(e.length=1);var f=e.words[9];for(t.words[t.length++]=4194303&f,r=10;r<e.length;r++){var d=0|e.words[r];e.words[r-10]=(4194303&d)<<4|f>>>22,f=d}f>>>=22,0===(e.words[r-10]=f)&&10<e.length?e.length-=10:e.length-=9},v.prototype.imulK=function(e){e.words[e.length]=0,e.words[e.length+1]=0,e.length+=2;for(var t=0,i=0;i<e.length;i++){var r=0|e.words[i];t+=977*r,e.words[i]=67108863&t,t=64*r+(t/67108864|0)}return 0===e.words[e.length-1]&&(e.length--,0===e.words[e.length-1]&&e.length--),e},i(g,h),i(y,h),i(M,h),M.prototype.imulK=function(e){for(var t=0,i=0;i<e.length;i++){var r=19*(0|e.words[i])+t,f=67108863&r;r>>>=26,e.words[i]=f,t=r}return 0!==t&&(e.words[e.length++]=t),e},m._prime=function(e){if(c[e])return c[e];var t;if("k256"===e)t=new v;else if("p224"===e)t=new g;else if("p192"===e)t=new y;else{if("p25519"!==e)throw new Error("Unknown prime "+e);t=new M}return c[e]=t},w.prototype._verify1=function(e){p(0===e.negative,"red works only with positives"),p(e.red,"red works only with red numbers")},w.prototype._verify2=function(e,t){p(0==(e.negative|t.negative),"red works only with positives"),p(e.red&&e.red===t.red,"red works only with red numbers")},w.prototype.imod=function(e){return(this.prime?this.prime.ireduce(e):e.umod(this.m))._forceRed(this)},w.prototype.neg=function(e){return e.isZero()?e.clone():this.m.sub(e)._forceRed(this)},w.prototype.add=function(e,t){this._verify2(e,t);t=e.add(t);return 0<=t.cmp(this.m)&&t.isub(this.m),t._forceRed(this)},w.prototype.iadd=function(e,t){this._verify2(e,t);t=e.iadd(t);return 0<=t.cmp(this.m)&&t.isub(this.m),t},w.prototype.sub=function(e,t){this._verify2(e,t);t=e.sub(t);return t.cmpn(0)<0&&t.iadd(this.m),t._forceRed(this)},w.prototype.isub=function(e,t){this._verify2(e,t);t=e.isub(t);return t.cmpn(0)<0&&t.iadd(this.m),t},w.prototype.shl=function(e,t){return this._verify1(e),this.imod(e.ushln(t))},w.prototype.imul=function(e,t){return this._verify2(e,t),this.imod(e.imul(t))},w.prototype.mul=function(e,t){return this._verify2(e,t),this.imod(e.mul(t))},w.prototype.isqr=function(e){return this.imul(e,e.clone())},w.prototype.sqr=function(e){return this.mul(e,e)},w.prototype.sqrt=function(e){if(e.isZero())return e.clone();var t=this.m.andln(3);if(p(t%2==1),3===t){t=this.m.add(new m(1)).iushrn(2);return this.pow(e,t)}for(var i=this.m.subn(1),r=0;!i.isZero()&&0===i.andln(1);)r++,i.iushrn(1);p(!i.isZero());for(var f=new m(1).toRed(this),d=f.redNeg(),n=this.m.subn(1).iushrn(1),a=new m(2*(a=this.m.bitLength())*a).toRed(this);0!==this.pow(a,n).cmp(d);)a.redIAdd(d);for(var s=this.pow(a,i),c=this.pow(e,i.addn(1).iushrn(1)),h=this.pow(e,i),o=r;0!==h.cmp(f);){for(var u=h,b=0;0!==u.cmp(f);b++)u=u.redSqr();p(b<o);var l=this.pow(s,new m(1).iushln(o-b-1)),c=c.redMul(l),s=l.redSqr(),h=h.redMul(s),o=b}return c},w.prototype.invm=function(e){e=e._invmp(this.m);return 0!==e.negative?(e.negative=0,this.imod(e).redNeg()):this.imod(e)},w.prototype.pow=function(e,t){if(t.isZero())return new m(1).toRed(this);if(0===t.cmpn(1))return e.clone();var i=new Array(16);i[0]=new m(1).toRed(this),i[1]=e;for(var r=2;r<i.length;r++)i[r]=this.mul(i[r-1],e);var f=i[0],d=0,n=0,a=t.bitLength()%26;for(0===a&&(a=26),r=t.length-1;0<=r;r--){for(var s=t.words[r],c=a-1;0<=c;c--){var h=s>>c&1;f!==i[0]&&(f=this.sqr(f)),0!=h||0!==d?(d<<=1,d|=h,(4===++n||0===r&&0===c)&&(f=this.mul(f,i[d]),d=n=0)):n=0}a=26}return f},w.prototype.convertTo=function(e){var t=e.umod(this.m);return t===e?t.clone():t},w.prototype.convertFrom=function(e){e=e.clone();return e.red=null,e},m.mont=function(e){return new S(e)},i(S,w),S.prototype.convertTo=function(e){return this.imod(e.ushln(this.shift))},S.prototype.convertFrom=function(e){e=this.imod(e.mul(this.rinv));return e.red=null,e},S.prototype.imul=function(e,t){if(e.isZero()||t.isZero())return e.words[0]=0,e.length=1,e;e=e.imul(t),t=e.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),e=e.isub(t).iushrn(this.shift),t=e;return 0<=e.cmp(this.m)?t=e.isub(this.m):e.cmpn(0)<0&&(t=e.iadd(this.m)),t._forceRed(this)},S.prototype.mul=function(e,t){if(e.isZero()||t.isZero())return new m(0)._forceRed(this);e=e.mul(t),t=e.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),e=e.isub(t).iushrn(this.shift),t=e;return 0<=e.cmp(this.m)?t=e.isub(this.m):e.cmpn(0)<0&&(t=e.iadd(this.m)),t._forceRed(this)},S.prototype.invm=function(e){return this.imod(e._invmp(this.m).mul(this.r2))._forceRed(this)}}(void 0===e||e,this)},{buffer:18}],17:[function(e,t,i){var r;function f(e){this.rand=e}if(t.exports=function(e){return(r=r||new f(null)).generate(e)},(t.exports.Rand=f).prototype.generate=function(e){return this._rand(e)},f.prototype._rand=function(e){if(this.rand.getBytes)return this.rand.getBytes(e);for(var t=new Uint8Array(e),i=0;i<t.length;i++)t[i]=this.rand.getByte();return t},"object"==typeof self)self.crypto&&self.crypto.getRandomValues?f.prototype._rand=function(e){e=new Uint8Array(e);return self.crypto.getRandomValues(e),e}:self.msCrypto&&self.msCrypto.getRandomValues?f.prototype._rand=function(e){e=new Uint8Array(e);return self.msCrypto.getRandomValues(e),e}:"object"==typeof window&&(f.prototype._rand=function(){throw new Error("Not implemented yet")});else try{var d=e("crypto");if("function"!=typeof d.randomBytes)throw new Error("Not supported");f.prototype._rand=function(e){return d.randomBytes(e)}}catch(e){}},{crypto:18}],18:[function(e,t,i){},{}],19:[function(e,t,i){i.utils=e("./hash/utils"),i.common=e("./hash/common"),i.sha=e("./hash/sha"),i.ripemd=e("./hash/ripemd"),i.hmac=e("./hash/hmac"),i.sha1=i.sha.sha1,i.sha256=i.sha.sha256,i.sha224=i.sha.sha224,i.sha384=i.sha.sha384,i.sha512=i.sha.sha512,i.ripemd160=i.ripemd.ripemd160},{"./hash/common":20,"./hash/hmac":21,"./hash/ripemd":22,"./hash/sha":23,"./hash/utils":30}],20:[function(e,t,i){"use strict";var r=e("./utils"),f=e("minimalistic-assert");function d(){this.pending=null,this.pendingTotal=0,this.blockSize=this.constructor.blockSize,this.outSize=this.constructor.outSize,this.hmacStrength=this.constructor.hmacStrength,this.padLength=this.constructor.padLength/8,this.endian="big",this._delta8=this.blockSize/8,this._delta32=this.blockSize/32}(i.BlockHash=d).prototype.update=function(e,t){if(e=r.toArray(e,t),this.pending?this.pending=this.pending.concat(e):this.pending=e,this.pendingTotal+=e.length,this.pending.length>=this._delta8){t=(e=this.pending).length%this._delta8;this.pending=e.slice(e.length-t,e.length),0===this.pending.length&&(this.pending=null),e=r.join32(e,0,e.length-t,this.endian);for(var i=0;i<e.length;i+=this._delta32)this._update(e,i,i+this._delta32)}return this},d.prototype.digest=function(e){return this.update(this._pad()),f(null===this.pending),this._digest(e)},d.prototype._pad=function(){var e=this.pendingTotal,t=this._delta8,i=t-(e+this.padLength)%t,r=new Array(i+this.padLength);r[0]=128;for(var f=1;f<i;f++)r[f]=0;if(e<<=3,"big"===this.endian){for(var d=8;d<this.padLength;d++)r[f++]=0;r[f++]=0,r[f++]=0,r[f++]=0,r[f++]=0,r[f++]=e>>>24&255,r[f++]=e>>>16&255,r[f++]=e>>>8&255,r[f++]=255&e}else for(r[f++]=255&e,r[f++]=e>>>8&255,r[f++]=e>>>16&255,r[f++]=e>>>24&255,r[f++]=0,r[f++]=0,r[f++]=0,r[f++]=0,d=8;d<this.padLength;d++)r[f++]=0;return r}},{"./utils":30,"minimalistic-assert":33}],21:[function(e,t,i){"use strict";var r=e("./utils"),f=e("minimalistic-assert");function d(e,t,i){if(!(this instanceof d))return new d(e,t,i);this.Hash=e,this.blockSize=e.blockSize/8,this.outSize=e.outSize/8,this.inner=null,this.outer=null,this._init(r.toArray(t,i))}(t.exports=d).prototype._init=function(e){e.length>this.blockSize&&(e=(new this.Hash).update(e).digest()),f(e.length<=this.blockSize);for(var t=e.length;t<this.blockSize;t++)e.push(0);for(t=0;t<e.length;t++)e[t]^=54;for(this.inner=(new this.Hash).update(e),t=0;t<e.length;t++)e[t]^=106;this.outer=(new this.Hash).update(e)},d.prototype.update=function(e,t){return this.inner.update(e,t),this},d.prototype.digest=function(e){return this.outer.update(this.inner.digest()),this.outer.digest(e)}},{"./utils":30,"minimalistic-assert":33}],22:[function(e,t,i){"use strict";var r=e("./utils"),e=e("./common"),p=r.rotl32,m=r.sum32,v=r.sum32_3,g=r.sum32_4,f=e.BlockHash;function d(){if(!(this instanceof d))return new d;f.call(this),this.h=[1732584193,4023233417,2562383102,271733878,3285377520],this.endian="little"}function y(e,t,i,r){return e<=15?t^i^r:e<=31?t&i|~t&r:e<=47?(t|~i)^r:e<=63?t&r|i&~r:t^(i|~r)}r.inherits(d,f),(i.ripemd160=d).blockSize=512,d.outSize=160,d.hmacStrength=192,d.padLength=64,d.prototype._update=function(e,t){for(var i,r=h=this.h[0],f=l=this.h[1],d=b=this.h[2],n=u=this.h[3],a=o=this.h[4],s=0;s<80;s++)var c=m(p(g(h,y(s,l,b,u),e[M[s]+t],(i=s)<=15?0:i<=31?1518500249:i<=47?1859775393:i<=63?2400959708:2840853838),S[s]),o),h=o,o=u,u=p(b,10),b=l,l=c,c=m(p(g(r,y(79-s,f,d,n),e[w[s]+t],(i=s)<=15?1352829926:i<=31?1548603684:i<=47?1836072691:i<=63?2053994217:0),_[s]),a),r=a,a=n,n=p(d,10),d=f,f=c;c=v(this.h[1],b,n),this.h[1]=v(this.h[2],u,a),this.h[2]=v(this.h[3],o,r),this.h[3]=v(this.h[4],h,f),this.h[4]=v(this.h[0],l,d),this.h[0]=c},d.prototype._digest=function(e){return"hex"===e?r.toHex32(this.h,"little"):r.split32(this.h,"little")};var M=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13],w=[5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11],S=[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6],_=[8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11]},{"./common":20,"./utils":30}],23:[function(e,t,i){"use strict";i.sha1=e("./sha/1"),i.sha224=e("./sha/224"),i.sha256=e("./sha/256"),i.sha384=e("./sha/384"),i.sha512=e("./sha/512")},{"./sha/1":24,"./sha/224":25,"./sha/256":26,"./sha/384":27,"./sha/512":28}],24:[function(e,t,i){"use strict";var r=e("../utils"),f=e("../common"),e=e("./common"),h=r.rotl32,o=r.sum32,u=r.sum32_5,b=e.ft_1,d=f.BlockHash,l=[1518500249,1859775393,2400959708,3395469782];function n(){if(!(this instanceof n))return new n;d.call(this),this.h=[1732584193,4023233417,2562383102,271733878,3285377520],this.W=new Array(80)}r.inherits(n,d),(t.exports=n).blockSize=512,n.outSize=160,n.hmacStrength=80,n.padLength=64,n.prototype._update=function(e,t){for(var i=this.W,r=0;r<16;r++)i[r]=e[t+r];for(;r<i.length;r++)i[r]=h(i[r-3]^i[r-8]^i[r-14]^i[r-16],1);for(var f=this.h[0],d=this.h[1],n=this.h[2],a=this.h[3],s=this.h[4],r=0;r<i.length;r++)var c=~~(r/20),c=u(h(f,5),b(c,d,n,a),s,i[r],l[c]),s=a,a=n,n=h(d,30),d=f,f=c;this.h[0]=o(this.h[0],f),this.h[1]=o(this.h[1],d),this.h[2]=o(this.h[2],n),this.h[3]=o(this.h[3],a),this.h[4]=o(this.h[4],s)},n.prototype._digest=function(e){return"hex"===e?r.toHex32(this.h,"big"):r.split32(this.h,"big")}},{"../common":20,"../utils":30,"./common":29}],25:[function(e,t,i){"use strict";var r=e("../utils"),f=e("./256");function d(){if(!(this instanceof d))return new d;f.call(this),this.h=[3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428]}r.inherits(d,f),(t.exports=d).blockSize=512,d.outSize=224,d.hmacStrength=192,d.padLength=64,d.prototype._digest=function(e){return"hex"===e?r.toHex32(this.h.slice(0,7),"big"):r.split32(this.h.slice(0,7),"big")}},{"../utils":30,"./256":26}],26:[function(e,t,i){"use strict";var r=e("../utils"),f=e("../common"),d=e("./common"),l=e("minimalistic-assert"),p=r.sum32,m=r.sum32_4,v=r.sum32_5,g=d.ch32,y=d.maj32,M=d.s0_256,w=d.s1_256,S=d.g0_256,_=d.g1_256,n=f.BlockHash,a=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298];function s(){if(!(this instanceof s))return new s;n.call(this),this.h=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225],this.k=a,this.W=new Array(64)}r.inherits(s,n),(t.exports=s).blockSize=512,s.outSize=256,s.hmacStrength=192,s.padLength=64,s.prototype._update=function(e,t){for(var i=this.W,r=0;r<16;r++)i[r]=e[t+r];for(;r<i.length;r++)i[r]=m(_(i[r-2]),i[r-7],S(i[r-15]),i[r-16]);var f=this.h[0],d=this.h[1],n=this.h[2],a=this.h[3],s=this.h[4],c=this.h[5],h=this.h[6],o=this.h[7];for(l(this.k.length===i.length),r=0;r<i.length;r++)var u=v(o,w(s),g(s,c,h),this.k[r],i[r]),b=p(M(f),y(f,d,n)),o=h,h=c,c=s,s=p(a,u),a=n,n=d,d=f,f=p(u,b);this.h[0]=p(this.h[0],f),this.h[1]=p(this.h[1],d),this.h[2]=p(this.h[2],n),this.h[3]=p(this.h[3],a),this.h[4]=p(this.h[4],s),this.h[5]=p(this.h[5],c),this.h[6]=p(this.h[6],h),this.h[7]=p(this.h[7],o)},s.prototype._digest=function(e){return"hex"===e?r.toHex32(this.h,"big"):r.split32(this.h,"big")}},{"../common":20,"../utils":30,"./common":29,"minimalistic-assert":33}],27:[function(e,t,i){"use strict";var r=e("../utils"),f=e("./512");function d(){if(!(this instanceof d))return new d;f.call(this),this.h=[3418070365,3238371032,1654270250,914150663,2438529370,812702999,355462360,4144912697,1731405415,4290775857,2394180231,1750603025,3675008525,1694076839,1203062813,3204075428]}r.inherits(d,f),(t.exports=d).blockSize=1024,d.outSize=384,d.hmacStrength=192,d.padLength=128,d.prototype._digest=function(e){return"hex"===e?r.toHex32(this.h.slice(0,12),"big"):r.split32(this.h.slice(0,12),"big")}},{"../utils":30,"./512":28}],28:[function(e,t,i){"use strict";var r=e("../utils"),f=e("../common"),P=e("minimalistic-assert"),j=r.rotr64_hi,N=r.rotr64_lo,u=r.shr64_hi,b=r.shr64_lo,E=r.sum64,B=r.sum64_hi,L=r.sum64_lo,l=r.sum64_4_hi,p=r.sum64_4_lo,O=r.sum64_5_hi,F=r.sum64_5_lo,d=f.BlockHash,n=[1116352408,3609767458,1899447441,602891725,3049323471,3964484399,3921009573,2173295548,961987163,4081628472,1508970993,3053834265,2453635748,2937671579,2870763221,3664609560,3624381080,2734883394,310598401,1164996542,607225278,1323610764,1426881987,3590304994,1925078388,4068182383,2162078206,991336113,2614888103,633803317,3248222580,3479774868,3835390401,2666613458,4022224774,944711139,264347078,2341262773,604807628,2007800933,770255983,1495990901,1249150122,1856431235,1555081692,3175218132,1996064986,2198950837,2554220882,3999719339,2821834349,766784016,2952996808,2566594879,3210313671,3203337956,3336571891,1034457026,3584528711,2466948901,113926993,3758326383,338241895,168717936,666307205,1188179964,773529912,1546045734,1294757372,1522805485,1396182291,2643833823,1695183700,2343527390,1986661051,1014477480,2177026350,1206759142,2456956037,344077627,2730485921,1290863460,2820302411,3158454273,3259730800,3505952657,3345764771,106217008,3516065817,3606008344,3600352804,1432725776,4094571909,1467031594,275423344,851169720,430227734,3100823752,506948616,1363258195,659060556,3750685593,883997877,3785050280,958139571,3318307427,1322822218,3812723403,1537002063,2003034995,1747873779,3602036899,1955562222,1575990012,2024104815,1125592928,2227730452,2716904306,2361852424,442776044,2428436474,593698344,2756734187,3733110249,3204031479,2999351573,3329325298,3815920427,3391569614,3928383900,3515267271,566280711,3940187606,3454069534,4118630271,4000239992,116418474,1914138554,174292421,2731055270,289380356,3203993006,460393269,320620315,685471733,587496836,852142971,1086792851,1017036298,365543100,1126000580,2618297676,1288033470,3409855158,1501505948,4234509866,1607167915,987167468,1816402316,1246189591];function a(){if(!(this instanceof a))return new a;d.call(this),this.h=[1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209],this.k=n,this.W=new Array(160)}r.inherits(a,d),(t.exports=a).blockSize=1024,a.outSize=512,a.hmacStrength=192,a.padLength=128,a.prototype._prepareBlock=function(e,t){for(var i=this.W,r=0;r<32;r++)i[r]=e[t+r];for(;r<i.length;r+=2){var f=function(e,t){var i=j(e,t,19),r=j(t,e,29),t=u(e,t,6),t=i^r^t;t<0&&(t+=4294967296);return t}(i[r-4],i[r-3]),d=function(e,t){var i=N(e,t,19),r=N(t,e,29),t=b(e,t,6),t=i^r^t;t<0&&(t+=4294967296);return t}(i[r-4],i[r-3]),n=i[r-14],a=i[r-13],s=function(e,t){var i=j(e,t,1),r=j(e,t,8),t=u(e,t,7),t=i^r^t;t<0&&(t+=4294967296);return t}(i[r-30],i[r-29]),c=function(e,t){var i=N(e,t,1),r=N(e,t,8),t=b(e,t,7),t=i^r^t;t<0&&(t+=4294967296);return t}(i[r-30],i[r-29]),h=i[r-32],o=i[r-31];i[r]=l(f,d,n,a,s,c,h,o),i[r+1]=p(f,d,n,a,s,c,h,o)}},a.prototype._update=function(e,t){this._prepareBlock(e,t);var i=this.W,r=this.h[0],f=this.h[1],d=this.h[2],n=this.h[3],a=this.h[4],s=this.h[5],c=this.h[6],h=this.h[7],o=this.h[8],u=this.h[9],b=this.h[10],l=this.h[11],p=this.h[12],m=this.h[13],v=this.h[14],g=this.h[15];P(this.k.length===i.length);for(var y=0;y<i.length;y+=2)var M=v,w=g,S=function(e,t){var i=j(e,t,14),r=j(e,t,18),e=j(t,e,9),e=i^r^e;e<0&&(e+=4294967296);return e}(o,u),_=function(e,t){var i=N(e,t,14),r=N(e,t,18),e=N(t,e,9),e=i^r^e;e<0&&(e+=4294967296);return e}(o,u),A=function(e,t,i){i=e&t^~e&i;i<0&&(i+=4294967296);return i}(o,b,p),x=function(e,t,i){i=e&t^~e&i;i<0&&(i+=4294967296);return i}(u,l,m),I=this.k[y],z=this.k[y+1],q=i[y],R=i[y+1],k=O(M,w,S,_,A,x,I,z,q,R),q=F(M,w,S,_,A,x,I,z,q,R),M=function(e,t){var i=j(e,t,28),r=j(t,e,2),e=j(t,e,7),e=i^r^e;e<0&&(e+=4294967296);return e}(r,f),w=function(e,t){var i=N(e,t,28),r=N(t,e,2),e=N(t,e,7),e=i^r^e;e<0&&(e+=4294967296);return e}(r,f),S=function(e,t,i){i=e&t^e&i^t&i;i<0&&(i+=4294967296);return i}(r,d,a),_=function(e,t,i){i=e&t^e&i^t&i;i<0&&(i+=4294967296);return i}(f,n,s),R=B(M,w,S,_),_=L(M,w,S,_),v=p,g=m,p=b,m=l,b=o,l=u,o=B(c,h,k,q),u=L(h,h,k,q),c=a,h=s,a=d,s=n,d=r,n=f,r=B(k,q,R,_),f=L(k,q,R,_);E(this.h,0,r,f),E(this.h,2,d,n),E(this.h,4,a,s),E(this.h,6,c,h),E(this.h,8,o,u),E(this.h,10,b,l),E(this.h,12,p,m),E(this.h,14,v,g)},a.prototype._digest=function(e){return"hex"===e?r.toHex32(this.h,"big"):r.split32(this.h,"big")}},{"../common":20,"../utils":30,"minimalistic-assert":33}],29:[function(e,t,i){"use strict";var r=e("../utils").rotr32;function f(e,t,i){return e&t^~e&i}function d(e,t,i){return e&t^e&i^t&i}function n(e,t,i){return e^t^i}i.ft_1=function(e,t,i,r){return 0===e?f(t,i,r):1===e||3===e?t^i^r:2===e?d(t,i,r):void 0},i.ch32=f,i.maj32=d,i.p32=n,i.s0_256=function(e){return r(e,2)^r(e,13)^r(e,22)},i.s1_256=function(e){return r(e,6)^r(e,11)^r(e,25)},i.g0_256=function(e){return r(e,7)^r(e,18)^e>>>3},i.g1_256=function(e){return r(e,17)^r(e,19)^e>>>10}},{"../utils":30}],30:[function(e,t,i){"use strict";var s=e("minimalistic-assert"),e=e("inherits");function d(e){return(e>>>24|e>>>8&65280|e<<8&16711680|(255&e)<<24)>>>0}function r(e){return 1===e.length?"0"+e:e}function n(e){return 7===e.length?"0"+e:6===e.length?"00"+e:5===e.length?"000"+e:4===e.length?"0000"+e:3===e.length?"00000"+e:2===e.length?"000000"+e:1===e.length?"0000000"+e:e}i.inherits=e,i.toArray=function(e,t){if(Array.isArray(e))return e.slice();if(!e)return[];var i,r,f=[];if("string"==typeof e)if(t){if("hex"===t)for((e=e.replace(/[^a-z0-9]+/gi,"")).length%2!=0&&(e="0"+e),n=0;n<e.length;n+=2)f.push(parseInt(e[n]+e[n+1],16))}else for(var d=0,n=0;n<e.length;n++){var a=e.charCodeAt(n);a<128?f[d++]=a:a<2048?(f[d++]=a>>6|192,f[d++]=63&a|128):(r=n,55296!=(64512&(i=e).charCodeAt(r))||r<0||r+1>=i.length||56320!=(64512&i.charCodeAt(r+1))?f[d++]=a>>12|224:(a=65536+((1023&a)<<10)+(1023&e.charCodeAt(++n)),f[d++]=a>>18|240,f[d++]=a>>12&63|128),f[d++]=a>>6&63|128,f[d++]=63&a|128)}else for(n=0;n<e.length;n++)f[n]=0|e[n];return f},i.toHex=function(e){for(var t="",i=0;i<e.length;i++)t+=r(e[i].toString(16));return t},i.htonl=d,i.toHex32=function(e,t){for(var i="",r=0;r<e.length;r++){var f=e[r];i+=n((f="little"===t?d(f):f).toString(16))}return i},i.zero2=r,i.zero8=n,i.join32=function(e,t,i,r){s((i-=t)%4==0);for(var f=new Array(i/4),d=0,n=t;d<f.length;d++,n+=4){var a="big"===r?e[n]<<24|e[n+1]<<16|e[n+2]<<8|e[n+3]:e[n+3]<<24|e[n+2]<<16|e[n+1]<<8|e[n];f[d]=a>>>0}return f},i.split32=function(e,t){for(var i=new Array(4*e.length),r=0,f=0;r<e.length;r++,f+=4){var d=e[r];"big"===t?(i[f]=d>>>24,i[f+1]=d>>>16&255,i[f+2]=d>>>8&255,i[f+3]=255&d):(i[f+3]=d>>>24,i[f+2]=d>>>16&255,i[f+1]=d>>>8&255,i[f]=255&d)}return i},i.rotr32=function(e,t){return e>>>t|e<<32-t},i.rotl32=function(e,t){return e<<t|e>>>32-t},i.sum32=function(e,t){return e+t>>>0},i.sum32_3=function(e,t,i){return e+t+i>>>0},i.sum32_4=function(e,t,i,r){return e+t+i+r>>>0},i.sum32_5=function(e,t,i,r,f){return e+t+i+r+f>>>0},i.sum64=function(e,t,i,r){var f=e[t],d=r+e[t+1]>>>0,f=(d<r?1:0)+i+f;e[t]=f>>>0,e[t+1]=d},i.sum64_hi=function(e,t,i,r){return(t+r>>>0<t?1:0)+e+i>>>0},i.sum64_lo=function(e,t,i,r){return t+r>>>0},i.sum64_4_hi=function(e,t,i,r,f,d,n,a){var s=0,c=t;return s+=(c=c+r>>>0)<t?1:0,s+=(c=c+d>>>0)<d?1:0,e+i+f+n+(s+=(c=c+a>>>0)<a?1:0)>>>0},i.sum64_4_lo=function(e,t,i,r,f,d,n,a){return t+r+d+a>>>0},i.sum64_5_hi=function(e,t,i,r,f,d,n,a,s,c){var h=0,o=t;return h+=(o=o+r>>>0)<t?1:0,h+=(o=o+d>>>0)<d?1:0,h+=(o=o+a>>>0)<a?1:0,e+i+f+n+s+(h+=(o=o+c>>>0)<c?1:0)>>>0},i.sum64_5_lo=function(e,t,i,r,f,d,n,a,s,c){return t+r+d+a+c>>>0},i.rotr64_hi=function(e,t,i){return(t<<32-i|e>>>i)>>>0},i.rotr64_lo=function(e,t,i){return(e<<32-i|t>>>i)>>>0},i.shr64_hi=function(e,t,i){return e>>>i},i.shr64_lo=function(e,t,i){return(e<<32-i|t>>>i)>>>0}},{inherits:32,"minimalistic-assert":33}],31:[function(e,t,i){"use strict";var r=e("hash.js"),d=e("minimalistic-crypto-utils"),f=e("minimalistic-assert");function n(e){if(!(this instanceof n))return new n(e);this.hash=e.hash,this.predResist=!!e.predResist,this.outLen=this.hash.outSize,this.minEntropy=e.minEntropy||this.hash.hmacStrength,this._reseed=null,this.reseedInterval=null,this.K=null,this.V=null;var t=d.toArray(e.entropy,e.entropyEnc||"hex"),i=d.toArray(e.nonce,e.nonceEnc||"hex"),e=d.toArray(e.pers,e.persEnc||"hex");f(t.length>=this.minEntropy/8,"Not enough entropy. Minimum is: "+this.minEntropy+" bits"),this._init(t,i,e)}(t.exports=n).prototype._init=function(e,t,i){i=e.concat(t).concat(i);this.K=new Array(this.outLen/8),this.V=new Array(this.outLen/8);for(var r=0;r<this.V.length;r++)this.K[r]=0,this.V[r]=1;this._update(i),this._reseed=1,this.reseedInterval=281474976710656},n.prototype._hmac=function(){return new r.hmac(this.hash,this.K)},n.prototype._update=function(e){var t=this._hmac().update(this.V).update([0]);e&&(t=t.update(e)),this.K=t.digest(),this.V=this._hmac().update(this.V).digest(),e&&(this.K=this._hmac().update(this.V).update([1]).update(e).digest(),this.V=this._hmac().update(this.V).digest())},n.prototype.reseed=function(e,t,i,r){"string"!=typeof t&&(r=i,i=t,t=null),e=d.toArray(e,t),i=d.toArray(i,r),f(e.length>=this.minEntropy/8,"Not enough entropy. Minimum is: "+this.minEntropy+" bits"),this._update(e.concat(i||[])),this._reseed=1},n.prototype.generate=function(e,t,i,r){if(this._reseed>this.reseedInterval)throw new Error("Reseed is required");"string"!=typeof t&&(r=i,i=t,t=null),i&&(i=d.toArray(i,r||"hex"),this._update(i));for(var f=[];f.length<e;)this.V=this._hmac().update(this.V).digest(),f=f.concat(this.V);r=f.slice(0,e);return this._update(i),this._reseed++,d.encode(r,t)}},{"hash.js":19,"minimalistic-assert":33,"minimalistic-crypto-utils":34}],32:[function(e,t,i){"function"==typeof Object.create?t.exports=function(e,t){t&&(e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}))}:t.exports=function(e,t){var i;t&&(e.super_=t,(i=function(){}).prototype=t.prototype,e.prototype=new i,e.prototype.constructor=e)}},{}],33:[function(e,t,i){function r(e,t){if(!e)throw new Error(t||"Assertion failed")}(t.exports=r).equal=function(e,t,i){if(e!=t)throw new Error(i||"Assertion failed: "+e+" != "+t)}},{}],34:[function(e,t,i){"use strict";function r(e){return 1===e.length?"0"+e:e}function f(e){for(var t="",i=0;i<e.length;i++)t+=r(e[i].toString(16));return t}i.toArray=function(e,t){if(Array.isArray(e))return e.slice();if(!e)return[];var i=[];if("string"!=typeof e){for(var r=0;r<e.length;r++)i[r]=0|e[r];return i}if("hex"===t){(e=e.replace(/[^a-z0-9]+/gi,"")).length%2!=0&&(e="0"+e);for(r=0;r<e.length;r+=2)i.push(parseInt(e[r]+e[r+1],16))}else for(r=0;r<e.length;r++){var f=e.charCodeAt(r),d=f>>8,f=255&f;d?i.push(d,f):i.push(f)}return i},i.zero2=r,i.toHex=f,i.encode=function(e,t){return"hex"===t?f(e):e}},{}],35:[function(e,t,i){t.exports={name:"elliptic",version:"6.5.4",description:"EC cryptography",main:"lib/elliptic.js",files:["lib"],scripts:{lint:"eslint lib test","lint:fix":"npm run lint -- --fix",unit:"istanbul test _mocha --reporter=spec test/index.js",test:"npm run lint && npm run unit",version:"grunt dist && git add dist/"},repository:{type:"git",url:"git@github.com:indutny/elliptic"},keywords:["EC","Elliptic","curve","Cryptography"],author:"Fedor Indutny <fedor@indutny.com>",license:"MIT",bugs:{url:"https://github.com/indutny/elliptic/issues"},homepage:"https://github.com/indutny/elliptic",devDependencies:{brfs:"^2.0.2",coveralls:"^3.1.0",eslint:"^7.6.0",grunt:"^1.2.1","grunt-browserify":"^5.3.0","grunt-cli":"^1.3.2","grunt-contrib-connect":"^3.0.0","grunt-contrib-copy":"^1.0.0","grunt-contrib-uglify":"^5.0.0","grunt-mocha-istanbul":"^5.0.2","grunt-saucelabs":"^9.0.1",istanbul:"^0.4.5",mocha:"^8.0.1"},dependencies:{"bn.js":"^4.11.9",brorand:"^1.1.0","hash.js":"^1.0.0","hmac-drbg":"^1.0.1",inherits:"^2.0.4","minimalistic-assert":"^1.0.1","minimalistic-crypto-utils":"^1.0.1"}}},{}]},{},[1])(1)});
    </script>
    
    <!-- 
    Library: QRCode.js v1.0.0
    Description: Cross-browser QRCode generator for JavaScript
    Source: https://github.com/davidshimjs/qrcodejs
    License: MIT License
    Downloaded from: https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js
    Last verified: April 23, 2025
    -->
    <script>
        var QRCode;!function(){function a(a){this.mode=c.MODE_8BIT_BYTE,this.data=a,this.parsedData=[];for(var b=[],d=0,e=this.data.length;e>d;d++){var f=this.data.charCodeAt(d);f>65536?(b[0]=240|(1835008&f)>>>18,b[1]=128|(258048&f)>>>12,b[2]=128|(4032&f)>>>6,b[3]=128|63&f):f>2048?(b[0]=224|(61440&f)>>>12,b[1]=128|(4032&f)>>>6,b[2]=128|63&f):f>128?(b[0]=192|(1984&f)>>>6,b[1]=128|63&f):b[0]=f,this.parsedData=this.parsedData.concat(b)}this.parsedData.length!=this.data.length&&(this.parsedData.unshift(191),this.parsedData.unshift(187),this.parsedData.unshift(239))}function b(a,b){this.typeNumber=a,this.errorCorrectLevel=b,this.modules=null,this.moduleCount=0,this.dataCache=null,this.dataList=[]}function i(a,b){if(void 0==a.length)throw new Error(a.length+"/"+b);for(var c=0;c<a.length&&0==a[c];)c++;this.num=new Array(a.length-c+b);for(var d=0;d<a.length-c;d++)this.num[d]=a[d+c]}function j(a,b){this.totalCount=a,this.dataCount=b}function k(){this.buffer=[],this.length=0}function m(){return"undefined"!=typeof CanvasRenderingContext2D}function n(){var a=!1,b=navigator.userAgent;return/android/i.test(b)&&(a=!0,aMat=b.toString().match(/android ([0-9]\.[0-9])/i),aMat&&aMat[1]&&(a=parseFloat(aMat[1]))),a}function r(a,b){for(var c=1,e=s(a),f=0,g=l.length;g>=f;f++){var h=0;switch(b){case d.L:h=l[f][0];break;case d.M:h=l[f][1];break;case d.Q:h=l[f][2];break;case d.H:h=l[f][3]}if(h>=e)break;c++}if(c>l.length)throw new Error("Too long data");return c}function s(a){var b=encodeURI(a).toString().replace(/\%[0-9a-fA-F]{2}/g,"a");return b.length+(b.length!=a?3:0)}a.prototype={getLength:function(){return this.parsedData.length},write:function(a){for(var b=0,c=this.parsedData.length;c>b;b++)a.put(this.parsedData[b],8)}},b.prototype={addData:function(b){var c=new a(b);this.dataList.push(c),this.dataCache=null},isDark:function(a,b){if(0>a||this.moduleCount<=a||0>b||this.moduleCount<=b)throw new Error(a+","+b);return this.modules[a][b]},getModuleCount:function(){return this.moduleCount},make:function(){this.makeImpl(!1,this.getBestMaskPattern())},makeImpl:function(a,c){this.moduleCount=4*this.typeNumber+17,this.modules=new Array(this.moduleCount);for(var d=0;d<this.moduleCount;d++){this.modules[d]=new Array(this.moduleCount);for(var e=0;e<this.moduleCount;e++)this.modules[d][e]=null}this.setupPositionProbePattern(0,0),this.setupPositionProbePattern(this.moduleCount-7,0),this.setupPositionProbePattern(0,this.moduleCount-7),this.setupPositionAdjustPattern(),this.setupTimingPattern(),this.setupTypeInfo(a,c),this.typeNumber>=7&&this.setupTypeNumber(a),null==this.dataCache&&(this.dataCache=b.createData(this.typeNumber,this.errorCorrectLevel,this.dataList)),this.mapData(this.dataCache,c)},setupPositionProbePattern:function(a,b){for(var c=-1;7>=c;c++)if(!(-1>=a+c||this.moduleCount<=a+c))for(var d=-1;7>=d;d++)-1>=b+d||this.moduleCount<=b+d||(this.modules[a+c][b+d]=c>=0&&6>=c&&(0==d||6==d)||d>=0&&6>=d&&(0==c||6==c)||c>=2&&4>=c&&d>=2&&4>=d?!0:!1)},getBestMaskPattern:function(){for(var a=0,b=0,c=0;8>c;c++){this.makeImpl(!0,c);var d=f.getLostPoint(this);(0==c||a>d)&&(a=d,b=c)}return b},createMovieClip:function(a,b,c){var d=a.createEmptyMovieClip(b,c),e=1;this.make();for(var f=0;f<this.modules.length;f++)for(var g=f*e,h=0;h<this.modules[f].length;h++){var i=h*e,j=this.modules[f][h];j&&(d.beginFill(0,100),d.moveTo(i,g),d.lineTo(i+e,g),d.lineTo(i+e,g+e),d.lineTo(i,g+e),d.endFill())}return d},setupTimingPattern:function(){for(var a=8;a<this.moduleCount-8;a++)null==this.modules[a][6]&&(this.modules[a][6]=0==a%2);for(var b=8;b<this.moduleCount-8;b++)null==this.modules[6][b]&&(this.modules[6][b]=0==b%2)},setupPositionAdjustPattern:function(){for(var a=f.getPatternPosition(this.typeNumber),b=0;b<a.length;b++)for(var c=0;c<a.length;c++){var d=a[b],e=a[c];if(null==this.modules[d][e])for(var g=-2;2>=g;g++)for(var h=-2;2>=h;h++)this.modules[d+g][e+h]=-2==g||2==g||-2==h||2==h||0==g&&0==h?!0:!1}},setupTypeNumber:function(a){for(var b=f.getBCHTypeNumber(this.typeNumber),c=0;18>c;c++){var d=!a&&1==(1&b>>c);this.modules[Math.floor(c/3)][c%3+this.moduleCount-8-3]=d}for(var c=0;18>c;c++){var d=!a&&1==(1&b>>c);this.modules[c%3+this.moduleCount-8-3][Math.floor(c/3)]=d}},setupTypeInfo:function(a,b){for(var c=this.errorCorrectLevel<<3|b,d=f.getBCHTypeInfo(c),e=0;15>e;e++){var g=!a&&1==(1&d>>e);6>e?this.modules[e][8]=g:8>e?this.modules[e+1][8]=g:this.modules[this.moduleCount-15+e][8]=g}for(var e=0;15>e;e++){var g=!a&&1==(1&d>>e);8>e?this.modules[8][this.moduleCount-e-1]=g:9>e?this.modules[8][15-e-1+1]=g:this.modules[8][15-e-1]=g}this.modules[this.moduleCount-8][8]=!a},mapData:function(a,b){for(var c=-1,d=this.moduleCount-1,e=7,g=0,h=this.moduleCount-1;h>0;h-=2)for(6==h&&h--;;){for(var i=0;2>i;i++)if(null==this.modules[d][h-i]){var j=!1;g<a.length&&(j=1==(1&a[g]>>>e));var k=f.getMask(b,d,h-i);k&&(j=!j),this.modules[d][h-i]=j,e--,-1==e&&(g++,e=7)}if(d+=c,0>d||this.moduleCount<=d){d-=c,c=-c;break}}}},b.PAD0=236,b.PAD1=17,b.createData=function(a,c,d){for(var e=j.getRSBlocks(a,c),g=new k,h=0;h<d.length;h++){var i=d[h];g.put(i.mode,4),g.put(i.getLength(),f.getLengthInBits(i.mode,a)),i.write(g)}for(var l=0,h=0;h<e.length;h++)l+=e[h].dataCount;if(g.getLengthInBits()>8*l)throw new Error("code length overflow. ("+g.getLengthInBits()+">"+8*l+")");for(g.getLengthInBits()+4<=8*l&&g.put(0,4);0!=g.getLengthInBits()%8;)g.putBit(!1);for(;;){if(g.getLengthInBits()>=8*l)break;if(g.put(b.PAD0,8),g.getLengthInBits()>=8*l)break;g.put(b.PAD1,8)}return b.createBytes(g,e)},b.createBytes=function(a,b){for(var c=0,d=0,e=0,g=new Array(b.length),h=new Array(b.length),j=0;j<b.length;j++){var k=b[j].dataCount,l=b[j].totalCount-k;d=Math.max(d,k),e=Math.max(e,l),g[j]=new Array(k);for(var m=0;m<g[j].length;m++)g[j][m]=255&a.buffer[m+c];c+=k;var n=f.getErrorCorrectPolynomial(l),o=new i(g[j],n.getLength()-1),p=o.mod(n);h[j]=new Array(n.getLength()-1);for(var m=0;m<h[j].length;m++){var q=m+p.getLength()-h[j].length;h[j][m]=q>=0?p.get(q):0}}for(var r=0,m=0;m<b.length;m++)r+=b[m].totalCount;for(var s=new Array(r),t=0,m=0;d>m;m++)for(var j=0;j<b.length;j++)m<g[j].length&&(s[t++]=g[j][m]);for(var m=0;e>m;m++)for(var j=0;j<b.length;j++)m<h[j].length&&(s[t++]=h[j][m]);return s};for(var c={MODE_NUMBER:1,MODE_ALPHA_NUM:2,MODE_8BIT_BYTE:4,MODE_KANJI:8},d={L:1,M:0,Q:3,H:2},e={PATTERN000:0,PATTERN001:1,PATTERN010:2,PATTERN011:3,PATTERN100:4,PATTERN101:5,PATTERN110:6,PATTERN111:7},f={PATTERN_POSITION_TABLE:[[],[6,18],[6,22],[6,26],[6,30],[6,34],[6,22,38],[6,24,42],[6,26,46],[6,28,50],[6,30,54],[6,32,58],[6,34,62],[6,26,46,66],[6,26,48,70],[6,26,50,74],[6,30,54,78],[6,30,56,82],[6,30,58,86],[6,34,62,90],[6,28,50,72,94],[6,26,50,74,98],[6,30,54,78,102],[6,28,54,80,106],[6,32,58,84,110],[6,30,58,86,114],[6,34,62,90,118],[6,26,50,74,98,122],[6,30,54,78,102,126],[6,26,52,78,104,130],[6,30,56,82,108,134],[6,34,60,86,112,138],[6,30,58,86,114,142],[6,34,62,90,118,146],[6,30,54,78,102,126,150],[6,24,50,76,102,128,154],[6,28,54,80,106,132,158],[6,32,58,84,110,136,162],[6,26,54,82,110,138,166],[6,30,58,86,114,142,170]],G15:1335,G18:7973,G15_MASK:21522,getBCHTypeInfo:function(a){for(var b=a<<10;f.getBCHDigit(b)-f.getBCHDigit(f.G15)>=0;)b^=f.G15<<f.getBCHDigit(b)-f.getBCHDigit(f.G15);return(a<<10|b)^f.G15_MASK},getBCHTypeNumber:function(a){for(var b=a<<12;f.getBCHDigit(b)-f.getBCHDigit(f.G18)>=0;)b^=f.G18<<f.getBCHDigit(b)-f.getBCHDigit(f.G18);return a<<12|b},getBCHDigit:function(a){for(var b=0;0!=a;)b++,a>>>=1;return b},getPatternPosition:function(a){return f.PATTERN_POSITION_TABLE[a-1]},getMask:function(a,b,c){switch(a){case e.PATTERN000:return 0==(b+c)%2;case e.PATTERN001:return 0==b%2;case e.PATTERN010:return 0==c%3;case e.PATTERN011:return 0==(b+c)%3;case e.PATTERN100:return 0==(Math.floor(b/2)+Math.floor(c/3))%2;case e.PATTERN101:return 0==b*c%2+b*c%3;case e.PATTERN110:return 0==(b*c%2+b*c%3)%2;case e.PATTERN111:return 0==(b*c%3+(b+c)%2)%2;default:throw new Error("bad maskPattern:"+a)}},getErrorCorrectPolynomial:function(a){for(var b=new i([1],0),c=0;a>c;c++)b=b.multiply(new i([1,g.gexp(c)],0));return b},getLengthInBits:function(a,b){if(b>=1&&10>b)switch(a){case c.MODE_NUMBER:return 10;case c.MODE_ALPHA_NUM:return 9;case c.MODE_8BIT_BYTE:return 8;case c.MODE_KANJI:return 8;default:throw new Error("mode:"+a)}else if(27>b)switch(a){case c.MODE_NUMBER:return 12;case c.MODE_ALPHA_NUM:return 11;case c.MODE_8BIT_BYTE:return 16;case c.MODE_KANJI:return 10;default:throw new Error("mode:"+a)}else{if(!(41>b))throw new Error("type:"+b);switch(a){case c.MODE_NUMBER:return 14;case c.MODE_ALPHA_NUM:return 13;case c.MODE_8BIT_BYTE:return 16;case c.MODE_KANJI:return 12;default:throw new Error("mode:"+a)}}},getLostPoint:function(a){for(var b=a.getModuleCount(),c=0,d=0;b>d;d++)for(var e=0;b>e;e++){for(var f=0,g=a.isDark(d,e),h=-1;1>=h;h++)if(!(0>d+h||d+h>=b))for(var i=-1;1>=i;i++)0>e+i||e+i>=b||(0!=h||0!=i)&&g==a.isDark(d+h,e+i)&&f++;f>5&&(c+=3+f-5)}for(var d=0;b-1>d;d++)for(var e=0;b-1>e;e++){var j=0;a.isDark(d,e)&&j++,a.isDark(d+1,e)&&j++,a.isDark(d,e+1)&&j++,a.isDark(d+1,e+1)&&j++,(0==j||4==j)&&(c+=3)}for(var d=0;b>d;d++)for(var e=0;b-6>e;e++)a.isDark(d,e)&&!a.isDark(d,e+1)&&a.isDark(d,e+2)&&a.isDark(d,e+3)&&a.isDark(d,e+4)&&!a.isDark(d,e+5)&&a.isDark(d,e+6)&&(c+=40);for(var e=0;b>e;e++)for(var d=0;b-6>d;d++)a.isDark(d,e)&&!a.isDark(d+1,e)&&a.isDark(d+2,e)&&a.isDark(d+3,e)&&a.isDark(d+4,e)&&!a.isDark(d+5,e)&&a.isDark(d+6,e)&&(c+=40);for(var k=0,e=0;b>e;e++)for(var d=0;b>d;d++)a.isDark(d,e)&&k++;var l=Math.abs(100*k/b/b-50)/5;return c+=10*l}},g={glog:function(a){if(1>a)throw new Error("glog("+a+")");return g.LOG_TABLE[a]},gexp:function(a){for(;0>a;)a+=255;for(;a>=256;)a-=255;return g.EXP_TABLE[a]},EXP_TABLE:new Array(256),LOG_TABLE:new Array(256)},h=0;8>h;h++)g.EXP_TABLE[h]=1<<h;for(var h=8;256>h;h++)g.EXP_TABLE[h]=g.EXP_TABLE[h-4]^g.EXP_TABLE[h-5]^g.EXP_TABLE[h-6]^g.EXP_TABLE[h-8];for(var h=0;255>h;h++)g.LOG_TABLE[g.EXP_TABLE[h]]=h;i.prototype={get:function(a){return this.num[a]},getLength:function(){return this.num.length},multiply:function(a){for(var b=new Array(this.getLength()+a.getLength()-1),c=0;c<this.getLength();c++)for(var d=0;d<a.getLength();d++)b[c+d]^=g.gexp(g.glog(this.get(c))+g.glog(a.get(d)));return new i(b,0)},mod:function(a){if(this.getLength()-a.getLength()<0)return this;for(var b=g.glog(this.get(0))-g.glog(a.get(0)),c=new Array(this.getLength()),d=0;d<this.getLength();d++)c[d]=this.get(d);for(var d=0;d<a.getLength();d++)c[d]^=g.gexp(g.glog(a.get(d))+b);return new i(c,0).mod(a)}},j.RS_BLOCK_TABLE=[[1,26,19],[1,26,16],[1,26,13],[1,26,9],[1,44,34],[1,44,28],[1,44,22],[1,44,16],[1,70,55],[1,70,44],[2,35,17],[2,35,13],[1,100,80],[2,50,32],[2,50,24],[4,25,9],[1,134,108],[2,67,43],[2,33,15,2,34,16],[2,33,11,2,34,12],[2,86,68],[4,43,27],[4,43,19],[4,43,15],[2,98,78],[4,49,31],[2,32,14,4,33,15],[4,39,13,1,40,14],[2,121,97],[2,60,38,2,61,39],[4,40,18,2,41,19],[4,40,14,2,41,15],[2,146,116],[3,58,36,2,59,37],[4,36,16,4,37,17],[4,36,12,4,37,13],[2,86,68,2,87,69],[4,69,43,1,70,44],[6,43,19,2,44,20],[6,43,15,2,44,16],[4,101,81],[1,80,50,4,81,51],[4,50,22,4,51,23],[3,36,12,8,37,13],[2,116,92,2,117,93],[6,58,36,2,59,37],[4,46,20,6,47,21],[7,42,14,4,43,15],[4,133,107],[8,59,37,1,60,38],[8,44,20,4,45,21],[12,33,11,4,34,12],[3,145,115,1,146,116],[4,64,40,5,65,41],[11,36,16,5,37,17],[11,36,12,5,37,13],[5,109,87,1,110,88],[5,65,41,5,66,42],[5,54,24,7,55,25],[11,36,12],[5,122,98,1,123,99],[7,73,45,3,74,46],[15,43,19,2,44,20],[3,45,15,13,46,16],[1,135,107,5,136,108],[10,74,46,1,75,47],[1,50,22,15,51,23],[2,42,14,17,43,15],[5,150,120,1,151,121],[9,69,43,4,70,44],[17,50,22,1,51,23],[2,42,14,19,43,15],[3,141,113,4,142,114],[3,70,44,11,71,45],[17,47,21,4,48,22],[9,39,13,16,40,14],[3,135,107,5,136,108],[3,67,41,13,68,42],[15,54,24,5,55,25],[15,43,15,10,44,16],[4,144,116,4,145,117],[17,68,42],[17,50,22,6,51,23],[19,46,16,6,47,17],[2,139,111,7,140,112],[17,74,46],[7,54,24,16,55,25],[34,37,13],[4,151,121,5,152,122],[4,75,47,14,76,48],[11,54,24,14,55,25],[16,45,15,14,46,16],[6,147,117,4,148,118],[6,73,45,14,74,46],[11,54,24,16,55,25],[30,46,16,2,47,17],[8,132,106,4,133,107],[8,75,47,13,76,48],[7,54,24,22,55,25],[22,45,15,13,46,16],[10,142,114,2,143,115],[19,74,46,4,75,47],[28,50,22,6,51,23],[33,46,16,4,47,17],[8,152,122,4,153,123],[22,73,45,3,74,46],[8,53,23,26,54,24],[12,45,15,28,46,16],[3,147,117,10,148,118],[3,73,45,23,74,46],[4,54,24,31,55,25],[11,45,15,31,46,16],[7,146,116,7,147,117],[21,73,45,7,74,46],[1,53,23,37,54,24],[19,45,15,26,46,16],[5,145,115,10,146,116],[19,75,47,10,76,48],[15,54,24,25,55,25],[23,45,15,25,46,16],[13,145,115,3,146,116],[2,74,46,29,75,47],[42,54,24,1,55,25],[23,45,15,28,46,16],[17,145,115],[10,74,46,23,75,47],[10,54,24,35,55,25],[19,45,15,35,46,16],[17,145,115,1,146,116],[14,74,46,21,75,47],[29,54,24,19,55,25],[11,45,15,46,46,16],[13,145,115,6,146,116],[14,74,46,23,75,47],[44,54,24,7,55,25],[59,46,16,1,47,17],[12,151,121,7,152,122],[12,75,47,26,76,48],[39,54,24,14,55,25],[22,45,15,41,46,16],[6,151,121,14,152,122],[6,75,47,34,76,48],[46,54,24,10,55,25],[2,45,15,64,46,16],[17,152,122,4,153,123],[29,74,46,14,75,47],[49,54,24,10,55,25],[24,45,15,46,46,16],[4,152,122,18,153,123],[13,74,46,32,75,47],[48,54,24,14,55,25],[42,45,15,32,46,16],[20,147,117,4,148,118],[40,75,47,7,76,48],[43,54,24,22,55,25],[10,45,15,67,46,16],[19,148,118,6,149,119],[18,75,47,31,76,48],[34,54,24,34,55,25],[20,45,15,61,46,16]],j.getRSBlocks=function(a,b){var c=j.getRsBlockTable(a,b);if(void 0==c)throw new Error("bad rs block @ typeNumber:"+a+"/errorCorrectLevel:"+b);for(var d=c.length/3,e=[],f=0;d>f;f++)for(var g=c[3*f+0],h=c[3*f+1],i=c[3*f+2],k=0;g>k;k++)e.push(new j(h,i));return e},j.getRsBlockTable=function(a,b){switch(b){case d.L:return j.RS_BLOCK_TABLE[4*(a-1)+0];case d.M:return j.RS_BLOCK_TABLE[4*(a-1)+1];case d.Q:return j.RS_BLOCK_TABLE[4*(a-1)+2];case d.H:return j.RS_BLOCK_TABLE[4*(a-1)+3];default:return void 0}},k.prototype={get:function(a){var b=Math.floor(a/8);return 1==(1&this.buffer[b]>>>7-a%8)},put:function(a,b){for(var c=0;b>c;c++)this.putBit(1==(1&a>>>b-c-1))},getLengthInBits:function(){return this.length},putBit:function(a){var b=Math.floor(this.length/8);this.buffer.length<=b&&this.buffer.push(0),a&&(this.buffer[b]|=128>>>this.length%8),this.length++}};var l=[[17,14,11,7],[32,26,20,14],[53,42,32,24],[78,62,46,34],[106,84,60,44],[134,106,74,58],[154,122,86,64],[192,152,108,84],[230,180,130,98],[271,213,151,119],[321,251,177,137],[367,287,203,155],[425,331,241,177],[458,362,258,194],[520,412,292,220],[586,450,322,250],[644,504,364,280],[718,560,394,310],[792,624,442,338],[858,666,482,382],[929,711,509,403],[1003,779,565,439],[1091,857,611,461],[1171,911,661,511],[1273,997,715,535],[1367,1059,751,593],[1465,1125,805,625],[1528,1190,868,658],[1628,1264,908,698],[1732,1370,982,742],[1840,1452,1030,790],[1952,1538,1112,842],[2068,1628,1168,898],[2188,1722,1228,958],[2303,1809,1283,983],[2431,1911,1351,1051],[2563,1989,1423,1093],[2699,2099,1499,1139],[2809,2213,1579,1219],[2953,2331,1663,1273]],o=function(){var a=function(a,b){this._el=a,this._htOption=b};return a.prototype.draw=function(a){function g(a,b){var c=document.createElementNS("http://www.w3.org/2000/svg",a);for(var d in b)b.hasOwnProperty(d)&&c.setAttribute(d,b[d]);return c}var b=this._htOption,c=this._el,d=a.getModuleCount();Math.floor(b.width/d),Math.floor(b.height/d),this.clear();var h=g("svg",{viewBox:"0 0 "+String(d)+" "+String(d),width:"100%",height:"100%",fill:b.colorLight});h.setAttributeNS("http://www.w3.org/2000/xmlns/","xmlns:xlink","http://www.w3.org/1999/xlink"),c.appendChild(h),h.appendChild(g("rect",{fill:b.colorDark,width:"1",height:"1",id:"template"}));for(var i=0;d>i;i++)for(var j=0;d>j;j++)if(a.isDark(i,j)){var k=g("use",{x:String(i),y:String(j)});k.setAttributeNS("http://www.w3.org/1999/xlink","href","#template"),h.appendChild(k)}},a.prototype.clear=function(){for(;this._el.hasChildNodes();)this._el.removeChild(this._el.lastChild)},a}(),p="svg"===document.documentElement.tagName.toLowerCase(),q=p?o:m()?function(){function a(){this._elImage.src=this._elCanvas.toDataURL("image/png"),this._elImage.style.display="block",this._elCanvas.style.display="none"}function d(a,b){var c=this;if(c._fFail=b,c._fSuccess=a,null===c._bSupportDataURI){var d=document.createElement("img"),e=function(){c._bSupportDataURI=!1,c._fFail&&_fFail.call(c)},f=function(){c._bSupportDataURI=!0,c._fSuccess&&c._fSuccess.call(c)};return d.onabort=e,d.onerror=e,d.onload=f,d.src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==",void 0}c._bSupportDataURI===!0&&c._fSuccess?c._fSuccess.call(c):c._bSupportDataURI===!1&&c._fFail&&c._fFail.call(c)}if(this._android&&this._android<=2.1){var b=1/window.devicePixelRatio,c=CanvasRenderingContext2D.prototype.drawImage;CanvasRenderingContext2D.prototype.drawImage=function(a,d,e,f,g,h,i,j){if("nodeName"in a&&/img/i.test(a.nodeName))for(var l=arguments.length-1;l>=1;l--)arguments[l]=arguments[l]*b;else"undefined"==typeof j&&(arguments[1]*=b,arguments[2]*=b,arguments[3]*=b,arguments[4]*=b);c.apply(this,arguments)}}var e=function(a,b){this._bIsPainted=!1,this._android=n(),this._htOption=b,this._elCanvas=document.createElement("canvas"),this._elCanvas.width=b.width,this._elCanvas.height=b.height,a.appendChild(this._elCanvas),this._el=a,this._oContext=this._elCanvas.getContext("2d"),this._bIsPainted=!1,this._elImage=document.createElement("img"),this._elImage.style.display="none",this._el.appendChild(this._elImage),this._bSupportDataURI=null};return e.prototype.draw=function(a){var b=this._elImage,c=this._oContext,d=this._htOption,e=a.getModuleCount(),f=d.width/e,g=d.height/e,h=Math.round(f),i=Math.round(g);b.style.display="none",this.clear();for(var j=0;e>j;j++)for(var k=0;e>k;k++){var l=a.isDark(j,k),m=k*f,n=j*g;c.strokeStyle=l?d.colorDark:d.colorLight,c.lineWidth=1,c.fillStyle=l?d.colorDark:d.colorLight,c.fillRect(m,n,f,g),c.strokeRect(Math.floor(m)+.5,Math.floor(n)+.5,h,i),c.strokeRect(Math.ceil(m)-.5,Math.ceil(n)-.5,h,i)}this._bIsPainted=!0},e.prototype.makeImage=function(){this._bIsPainted&&d.call(this,a)},e.prototype.isPainted=function(){return this._bIsPainted},e.prototype.clear=function(){this._oContext.clearRect(0,0,this._elCanvas.width,this._elCanvas.height),this._bIsPainted=!1},e.prototype.round=function(a){return a?Math.floor(1e3*a)/1e3:a},e}():function(){var a=function(a,b){this._el=a,this._htOption=b};return a.prototype.draw=function(a){for(var b=this._htOption,c=this._el,d=a.getModuleCount(),e=Math.floor(b.width/d),f=Math.floor(b.height/d),g=['<table style="border:0;border-collapse:collapse;">'],h=0;d>h;h++){g.push("<tr>");for(var i=0;d>i;i++)g.push('<td style="border:0;border-collapse:collapse;padding:0;margin:0;width:'+e+"px;height:"+f+"px;background-color:"+(a.isDark(h,i)?b.colorDark:b.colorLight)+';"></td>');g.push("</tr>")}g.push("</table>"),c.innerHTML=g.join("");var j=c.childNodes[0],k=(b.width-j.offsetWidth)/2,l=(b.height-j.offsetHeight)/2;k>0&&l>0&&(j.style.margin=l+"px "+k+"px")},a.prototype.clear=function(){this._el.innerHTML=""},a}();QRCode=function(a,b){if(this._htOption={width:256,height:256,typeNumber:4,colorDark:"#000000",colorLight:"#ffffff",correctLevel:d.H},"string"==typeof b&&(b={text:b}),b)for(var c in b)this._htOption[c]=b[c];"string"==typeof a&&(a=document.getElementById(a)),this._android=n(),this._el=a,this._oQRCode=null,this._oDrawing=new q(this._el,this._htOption),this._htOption.text&&this.makeCode(this._htOption.text)},QRCode.prototype.makeCode=function(a){this._oQRCode=new b(r(a,this._htOption.correctLevel),this._htOption.correctLevel),this._oQRCode.addData(a),this._oQRCode.make(),this._el.title=a,this._oDrawing.draw(this._oQRCode),this.makeImage()},QRCode.prototype.makeImage=function(){"function"==typeof this._oDrawing.makeImage&&(!this._android||this._android>=3)&&this._oDrawing.makeImage()},QRCode.prototype.clear=function(){this._oDrawing.clear()},QRCode.CorrectLevel=d}();
    </script>
    <style>
        :root {
            --primary-color: #3a86ff;
            --secondary-color: #8338ec;
            --accent-color: #ffbe0b;
            --danger-color: #ff006e;
            --success-color: #06d6a0;
            --light-bg: #f8f9fa;
            --dark-bg: #212529;
            --text-color: #212529;
            --light-text: #f8f9fa;
            --border-radius: 8px;
            --box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s ease;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: var(--light-bg);
            color: var(--text-color);
            line-height: 1.6;
        }
        .wallet-container {
            background-color: white;
            border-radius: var(--border-radius);
            padding: 30px;
            box-shadow: var(--box-shadow);
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid #eee;
        }
        .header h1 {
            color: var(--primary-color);
            font-weight: 700;
            margin-bottom: 10px;
        }
        .key-display {
            margin: 20px 0;
            padding: 15px;
            background-color: var(--light-bg);
            border-radius: var(--border-radius);
            word-break: break-all;
            border: 1px solid #e9ecef;
            font-family: monospace;
            font-size: 14px;
        }
        .button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 16px;
            margin-right: 10px;
            margin-bottom: 10px;
            font-weight: 600;
            transition: var(--transition);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .button:hover {
            background-color: #2878f0;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        .button:disabled {
            background-color: #d0d0d0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .delete-btn {
            background-color: var(--danger-color);
        }
        .delete-btn:disabled {
            background-color: #d0d0d0;
        }
        .button-container {
            margin-top: 25px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        .wallet-button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 3px 6px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 10px;
            margin-right: 3px;
            margin-bottom: 3px;
            font-weight: 600;
            transition: var(--transition);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }
        .wallet-button:hover {
            background-color: #2878f0;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        .wallet-button:disabled {
            background-color: #d0d0d0 !important;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            opacity: 0.6;
        }
        .wallet-button.delete-btn {
            background-color: var(--danger-color);
        }
        .wallet-button.encrypt-btn {
            background-color: #06d6a0;
        }
        .wallet-button.restore-btn {
            background-color: #8338ec;
        }
        .wallet-button.migrate-btn {
            background-color: #666;
        }
        .wallet-button svg {
            width: 10px;
            height: 10px;
        }
        .wallet-actions-container {
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
            margin-top: 20px;
            align-items: center;
        }
        .warning {
            color: var(--danger-color);
            font-weight: bold;
            margin: 20px 0;
            padding: 15px;
            background-color: rgba(255, 0, 110, 0.05);
            border-radius: var(--border-radius);
            border-left: 4px solid var(--danger-color);
        }
        .masked {
            filter: blur(8px);
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .key-display-container {
            display: flex;
            align-items: center;
        }
        
        @media (max-width: 600px) {
            .key-display-container {
                flex-direction: column;
                align-items: stretch;
            }
            .key-display-container .key-display {
                margin-bottom: 15px;
            }
            .key-display-container .small-button {
                margin-left: 0;
                align-self: center;
            }
        }
        .small-button {
            background-color: var(--secondary-color);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 14px;
            margin-left: 10px;
            min-width: 120px;
            transition: var(--transition);
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .small-button:hover {
            background-color: #722fd3;
            transform: translateY(-1px);
        }
        .small-button:disabled {
            background-color: #7a7a7a;
            cursor: not-allowed;
            transform: none;
        }
        .input-group {
            margin-bottom: 20px;
        }
        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #444;
        }
        .input-group input {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: var(--border-radius);
            font-size: 16px;
            transition: var(--transition);
        }
        .input-group input:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(58, 134, 255, 0.2);
            outline: none;
        }
        .address-list {
            margin-top: 25px;
        }
        .address-item {
            background-color: var(--light-bg);
            padding: 20px;
            border-radius: var(--border-radius);
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            word-break: break-all;
            border: 1px solid #e9ecef;
            transition: var(--transition);
        }
        .address-item:hover {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            transform: translateY(-2px);
        }
        .address-item button {
            min-width: auto;
            margin-left: 10px;
            white-space: nowrap;
        }
        
        /* Mobile responsive adjustments */
        @media (max-width: 600px) {
            .address-item {
                flex-direction: column;
                align-items: flex-start;
            }
            .address-item > div:first-child {
                margin-bottom: 15px;
                width: 100%;
            }
            .address-item button {
                margin-left: 0;
                align-self: center;
            }
        }
        .path-info {
            margin-top: 8px;
            font-size: 13px;
            color: #666;
            font-family: monospace;
        }
        .qr-modal {
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
        }
        .qr-content {
            background-color: #fff;
            padding: 30px;
            border-radius: var(--border-radius);
            text-align: center;
            max-width: 90%;
            box-shadow: var(--box-shadow);
            animation: modalFadeIn 0.3s ease;
        }
        @keyframes modalFadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .qr-content h3 {
            margin-top: 0;
            color: var(--primary-color);
        }
        .close-modal {
            position: absolute;
            top: 20px;
            right: 30px;
            font-size: 30px;
            color: #fff;
            cursor: pointer;
            transition: var(--transition);
        }
        .close-modal:hover {
            transform: scale(1.1);
        }
        .qr-container {
            margin: 25px auto;
            padding: 0;
            background: white;
            border-radius: var(--border-radius);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .qr-container img {
            width: 100%;
            height: 100%;
            display: block;
        }
        .info-box {
            background-color: rgba(58, 134, 255, 0.1);
            border-left: 4px solid var(--primary-color);
            border-radius: var(--border-radius);
            padding: 15px 20px;
            margin: 20px 0;
            font-size: 15px;
            line-height: 1.6;
            color: #444;
        }
        .info-box h4 {
            margin-top: 0;
            margin-bottom: 10px;
            color: var(--primary-color);
            font-weight: 600;
        }
        .card-section {
            margin-top: 30px;
            background: white;
            border-radius: var(--border-radius);
            padding: 25px;
            box-shadow: var(--box-shadow);
        }
        .card-section h2 {
            color: var(--primary-color);
            margin-top: 0;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }
        #passwordStrength {
            margin-top: 8px;
            font-size: 14px;
            font-weight: 600;
        }
        /* In-browser notifications */
        .notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            max-width: 400px;
        }
        
        .notification {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            padding: 16px 20px;
            margin-bottom: 10px;
            display: flex;
            align-items: flex-start;
            animation: slideIn 0.3s ease-out;
            transition: all 0.3s ease;
            border-left: 4px solid #3a86ff;
            min-width: 320px;
        }
        
        .notification.success {
            border-left-color: #06d6a0;
        }
        
        .notification.error {
            border-left-color: #ef476f;
        }
        
        .notification.warning {
            border-left-color: #ffba08;
        }
        
        .notification.info {
            border-left-color: #3a86ff;
        }
        
        .notification-icon {
            font-size: 24px;
            margin-right: 12px;
            flex-shrink: 0;
        }
        
        .notification-content {
            flex: 1;
            margin-right: 12px;
        }
        
        .notification-title {
            font-weight: 600;
            margin-bottom: 4px;
            color: #333;
        }
        
        .notification-message {
            font-size: 14px;
            color: #666;
            line-height: 1.4;
        }
        
        .notification-close {
            background: none;
            border: none;
            font-size: 20px;
            color: #999;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s;
            flex-shrink: 0;
        }
        
        .notification-close:hover {
            background-color: #f0f0f0;
            color: #333;
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }
        
        .notification.removing {
            animation: slideOut 0.3s ease-in;
        }
        
        /* Mobile responsive */
        @media (max-width: 600px) {
            .notification-container {
                top: 10px;
                right: 10px;
                left: 10px;
                max-width: none;
            }
            
            .notification {
                min-width: auto;
            }
        }
        
        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }
        
        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            border-radius: 8px;
            width: 90%;
            max-width: 700px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }
        
        .close-modal {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 20px;
        }
        
        .close-modal:hover,
        .close-modal:focus {
            color: #000;
            text-decoration: none;
        }
        
        .help-link {
            color: #3b82f6;
            text-decoration: none;
            cursor: pointer;
            font-size: 14px;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }
        
        .help-link:hover {
            text-decoration: underline;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- Version Number -->
    <div style="position: fixed; top: 10px; right: 10px; font-size: 10px; color: #999; z-index: 1000; font-family: monospace;">v0.1.2</div>
    
    <!-- Notification Container -->
    <div id="notificationContainer" class="notification-container"></div>
    
    <!-- QR Code Modal -->
    <div id="qrModal" class="qr-modal" style="display: none;">
        <span class="close-modal" onclick="document.getElementById('qrModal').style.display='none'; document.body.style.overflow='';">&times;</span>
        <div class="qr-content">
            <h3>Address QR Code</h3>
            <p style="font-family: monospace; margin: 15px 0; font-size: 15px; word-break: break-all; background: var(--light-bg); padding: 10px; border-radius: var(--border-radius); border: 1px solid #e9ecef;" id="qrAddress"></p>
            <div id="qrContainer" class="qr-container"></div>
            <p style="margin-top: 15px; color: #666;">Use this QR code to share your address with mining services</p>
            <button class="button" onclick="document.getElementById('qrModal').style.display='none'; document.body.style.overflow='';">Close</button>
        </div>
    </div>

    <!-- Password Modal -->
    <div id="passwordModal" class="qr-modal" style="display: none;">
        <div class="qr-content" style="max-width: 400px;">
            <h3 id="passwordModalTitle">Enter Password</h3>
            <p id="passwordModalMessage" style="margin: 15px 0; color: #666;">Please enter your wallet password:</p>
            
            <div class="input-group" style="margin-bottom: 15px;">
                <input type="password" id="passwordModalInput" placeholder="Enter your password" style="width: 100%;">
                <div id="passwordStrength" class="password-strength"></div>
            </div>
            
            <div style="display: flex; justify-content: space-between; gap: 10px;">
                <button class="button" style="background-color: #d0d0d0;" id="passwordModalCancelBtn">Cancel</button>
                <button class="button" id="passwordModalSubmitBtn">Submit</button>
            </div>
        </div>
    </div>

    <!-- Save Modal -->
    <div id="saveModal" class="qr-modal" style="display: none;">
        <div class="qr-content" style="max-width: 500px;">
            <h3 style="margin: 0 0 10px 0;">Save Wallet to File</h3>
            <p style="margin: 0 0 10px 0; color: #666; font-size: 14px;">Save your wallet with optional password protection.</p>
            
            <div class="input-group" style="margin-bottom: 10px;">
                <label for="savePasswordInput" style="font-size: 14px;">Password (optional):</label>
                <input type="password" id="savePasswordInput" placeholder="Leave empty for no encryption" style="width: 100%; font-size: 14px;">
                <div id="savePasswordStrength" style="margin-top: 5px;"></div>
            </div>
            
            <div class="input-group" style="margin-bottom: 10px;">
                <label for="saveFilenameInput" style="font-size: 14px;">Filename:</label>
                <input type="text" id="saveFilenameInput" value="alpha_wallet_backup.txt" style="width: 100%; font-size: 14px;">
            </div>
            
            <div style="display: flex; justify-content: space-between; gap: 10px;">
                <button class="button" style="background-color: #d0d0d0; font-size: 14px;" onclick="closeSaveModal()">Cancel</button>
                <button class="button" style="font-size: 14px;" onclick="saveWallet()">Save</button>
            </div>
        </div>
    </div>

    <!-- Restore Modal -->
    <div id="restoreModal" class="qr-modal" style="display: none;">
        <div class="qr-content" style="max-width: 700px; max-height: 90vh; overflow-y: auto;">
            <h3 style="margin: 0 0 10px 0;">Load Wallet from File</h3>
            <p style="margin: 0 0 10px 0; color: #666; font-size: 14px;">Upload a wallet backup file (.txt) or BIP32 wallet.dat file to load your wallet.</p>
            
            <div class="input-group" style="margin-bottom: 10px;">
                <label for="restoreFileInput" style="font-size: 14px;">Backup File:</label>
                <input type="file" id="restoreFileInput" accept=".txt,.dat" style="width: 100%; font-size: 14px;">
            </div>
            
            <div class="input-group" style="margin-bottom: 10px;">
                <label for="restorePasswordInput" style="font-size: 14px;">Password (if encrypted):</label>
                <input type="password" id="restorePasswordInput" placeholder="Enter wallet password" style="width: 100%; font-size: 14px;">
            </div>
            
            <!-- Wallet Scan Results -->
            <div id="walletScanResults" style="display: none; margin: 10px 0;">
                <h4 style="margin: 0 0 8px 0; font-size: 16px;">Found Wallets</h4>
                <div id="scanProgressBar" style="margin-bottom: 10px;">
                    <div style="height: 16px; background-color: #e9e9e9; border-radius: 8px; overflow: hidden;">
                        <div id="scanProgress" style="width: 0%; height: 100%; background-color: var(--primary-color); transition: width 0.3s;"></div>
                    </div>
                    <div style="margin-top: 4px; font-size: 11px; color: #666;">
                        <span id="scanStatus">Scanning...</span>
                        <span id="scanCounter" style="float: right;">0 / 100</span>
                    </div>
                    <div style="margin-top: 8px; text-align: center;">
                        <button class="button" id="stopScanBtn" onclick="scanningActive = false;" style="background-color: #d0d0d0; padding: 4px 12px; font-size: 12px;">Stop Scan</button>
                    </div>
                </div>
                <div id="foundWalletsList" style="max-height: 250px; overflow-y: auto; border: 1px solid #ddd; border-radius: 6px; padding: 8px; margin-top: 10px;">
                    <!-- Found wallets will be listed here -->
                </div>
            </div>
            
            <div id="restoreStatus" class="info-box" style="display: none; margin-bottom: 10px;"></div>
            
            <div style="display: flex; justify-content: space-between; gap: 10px; margin-bottom: 10px;">
                <button class="button" style="background-color: #d0d0d0; font-size: 14px;" id="restoreModalCancelBtn">Cancel</button>
                <button class="button" id="restoreModalSubmitBtn" style="font-size: 14px;">Load</button>
                <button class="button" id="scanWalletsBtn" style="display: none; font-size: 14px;">Rescan Wallets</button>
            </div>
            
            <!-- Wallet Scanning Options -->
            <div id="walletScanOptions" style="display: none; margin: 10px 0; padding: 10px; background-color: #f8f9fa; border-radius: 6px;">
                <h4 style="margin: 0 0 8px 0; font-size: 14px;">Wallet Discovery Settings</h4>
                <div class="input-group" style="margin-bottom: 8px;">
                    <label for="scanCountInput" style="font-size: 13px;">Number of addresses to scan:</label>
                    <input type="number" id="scanCountInput" value="100" min="1" max="1000" style="width: 80px; font-size: 13px;">
                    <span style="margin-left: 8px; color: #666; font-size: 11px;">Scan multiple addresses to find wallets with funds</span>
                </div>
                <div style="margin-top: 6px;">
                    <label style="font-size: 13px;">
                        <input type="checkbox" id="scanChangeAddresses" checked>
                        Also scan change addresses (internal chain)
                    </label>
                </div>
                <div style="margin-top: 6px;">
                    <label style="font-size: 13px;">
                        <input type="checkbox" id="scanOnlineCheckbox" checked>
                        Check balances online (requires Fulcrum connection)
                    </label>
                </div>
            </div>
        </div>
    </div>

    <div class="wallet-container">
        <div class="header">
            <h1>
                <svg xmlns="http://www.w3.org/2000/svg" width="36" height="36" viewBox="0 0 24 24" fill="none" stroke="var(--primary-color)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 10px;">
                    <rect x="2" y="6" width="20" height="12" rx="2"></rect>
                    <circle cx="12" cy="12" r="2"></circle>
                    <path d="M6 12h.01M18 12h.01"></path>
                </svg>
                Unicity WEB GUI Wallet
            </h1>
        </div>
        
        <div style="text-align: right; margin-bottom: 5px; margin-top: -5px;">
            <a href="#" class="help-link" onclick="showHelpModal(); return false;" style="font-size: 12px;">
                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="10"></circle>
                    <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
                    <line x1="12" y1="17" x2="12.01" y2="17"></line>
                </svg>
                How to use
            </a>
            <a href="#" class="help-link" onclick="openDisclaimerModal(); return false;" style="font-size: 12px; margin-left: 20px;">
                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/>
                </svg>
                Disclaimer
            </a>
            <a href="#" class="help-link" onclick="openSecurityNotesModal(); return false;" style="font-size: 12px; margin-left: 20px;">
                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                    <path d="M7 11V7a5 5 0 0110 0v4"></path>
                </svg>
                Security Notes
            </a>
        </div>

        <div id="wallet-section" class="card-section">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="margin: 0;">My Wallet</h2>
                <div id="walletQrCode" style="display: none;">
                    <!-- QR code will be generated here -->
                </div>
            </div>
            
            <!-- Compact Endpoint Section -->
            <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 15px; padding: 6px 8px; background-color: #f8f9fa; border-radius: 4px;">
                <label for="rpcServer" style="margin: 0; font-weight: 600; white-space: nowrap; font-size: 10px;">Endpoint:</label>
                <input type="text" id="rpcServer" placeholder="wss://fulcrum.unicity.network:50004" value="wss://fulcrum.unicity.network:50004" style="flex: 1; padding: 3px 6px; border: 1px solid #ddd; border-radius: 3px; font-size: 10px;">
                <button id="connectRpcBtn" class="wallet-button">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
                        <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
                    </svg>
                    Connect
                </button>
                <button id="disconnectRpcBtn" class="wallet-button" style="display: none; background-color: #ff006e;">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M18 6 6 18"></path>
                        <path d="m6 6 12 12"></path>
                    </svg>
                    Disconnect
                </button>
            </div>
            
            <!-- Wallet Info Section -->
            <div id="walletInfo" style="display: none; margin-bottom: 15px; padding: 15px; background-color: rgba(52, 211, 153, 0.05); border-radius: 8px; border: 1px solid rgba(52, 211, 153, 0.2);">
                <div style="display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 10px;">
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <a id="walletAddressLink" href="#" target="_blank" style="color: var(--primary-color); text-decoration: none; font-family: monospace;">
                                <span id="walletAddress">-</span>
                            </a>
                            <button onclick="copyAddress('wallet')" style="background: none; border: none; cursor: pointer; padding: 4px; display: flex; align-items: center;" title="Copy address">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                                </svg>
                            </button>
                        </div>
                        <div>
                            <span id="walletBalance" style="font-weight: 600;">0 ALPHA</span>
                            <span id="walletUnconfirmed" style="color: #999;">(0)</span>
                            <span id="totalScannedBalance" style="display: none; margin-left: 15px;">
                                | Total: <span style="font-weight: 600;" id="totalScannedAmount">0 ALPHA</span>
                                <a href="#" onclick="showScannedWalletsDialog(); return false;" style="color: var(--primary-color); text-decoration: none; margin-left: 5px;" title="View all scanned wallets">[view all]</a>
                            </span>
                            <span id="totalScannedLoading" style="display: none; margin-left: 15px; color: #666;">
                                | <span id="scanStatusText">Scanning wallets <span id="scanPercentage">0%</span></span>... <span style="display: inline-block; width: 12px; height: 12px; border: 2px solid #f3f3f3; border-top: 2px solid #666; border-radius: 50%; animation: spin 1s linear infinite;"></span>
                            </span>
                        </div>
                    </div>
                    <div>
                        <span style="font-size: 12px; color: #999;">Last update: <span id="lastUpdateTime">-</span></span>
                    </div>
                </div>
            </div>
            
            <!-- Watch-Only Address Input -->
            <div id="watchOnlySection" style="display: none; margin-bottom: 15px;">
                <div style="display: flex; align-items: center; gap: 6px; padding: 6px 8px; background-color: #f8f9fa; border-radius: 4px;">
                    <label style="margin: 0; font-weight: 600; white-space: nowrap; font-size: 10px;">Watch:</label>
                    <input type="text" id="watchOnlyAddress" placeholder="alpha1..." style="flex: 1; padding: 3px 6px; border: 1px solid #ddd; border-radius: 3px; font-family: monospace; font-size: 10px;">
                    <div style="display: flex; align-items: center; gap: 4px;">
                        <span id="watchOnlyBalance" style="font-weight: 600; font-size: 10px;">-</span>
                        <span id="watchOnlyUnconfirmed" style="color: #999; font-size: 10px;"></span>
                    </div>
                </div>
                <div style="margin-top: 4px; padding-left: 8px;">
                    <span style="font-size: 9px; color: #666;">Enter any Alpha address to monitor its balance and UTXOs</span>
                </div>
            </div>
            
            <div class="wallet-actions-container">
                <button id="initializeWalletBtn" class="wallet-button" title="Creates a new wallet with a secure private key. This is the first step to use this wallet.">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                        <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
                    </svg>
                    Create
                </button>
                <button id="restoreWalletBtn" class="wallet-button restore-btn" title="Load wallet from file">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="17 8 12 3 7 8"></polyline>
                        <line x1="12" y1="3" x2="12" y2="15"></line>
                    </svg>
                    Load
                </button>
                <button id="saveWalletBtn" class="wallet-button" disabled title="Save wallet to file with optional encryption">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                        <polyline points="17 21 17 13 7 13 7 21"></polyline>
                        <polyline points="7 3 7 8 15 8"></polyline>
                    </svg>
                    Save
                </button>
                <button id="deleteWalletBtn" class="wallet-button delete-btn" disabled title="Reset wallet data in your browser. This will clear the current wallet.">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16"></path>
                        <path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path>
                        <path d="M14 3h7v7"></path>
                        <path d="M10 21H3v-7"></path>
                    </svg>
                    Reset
                </button>
            </div>

            <!-- Compact Send Transaction -->
            <div id="sendTransactionSection" style="margin-top: 15px; margin-bottom: 15px;">
                <div style="display: flex; align-items: center; gap: 6px; padding: 6px 8px; background-color: #f8f9fa; border-radius: 4px;">
                    <label for="recipientAddress" style="margin: 0; font-weight: 600; white-space: nowrap; font-size: 10px;">Destination:</label>
                    <input type="text" id="recipientAddress" placeholder="alpha1..." style="flex: 1; padding: 3px 6px; border: 1px solid #ddd; border-radius: 3px; font-size: 10px; font-family: monospace;">
                    <input type="number" id="sendAmount" placeholder="0.00000000" step="0.00000001" min="0" style="width: 100px; padding: 3px 6px; border: 1px solid #ddd; border-radius: 3px; font-size: 10px;">
                    <button onclick="calculateMaxAmount()" class="wallet-button" style="background-color: #60a5fa; font-size: 9px; padding: 4px 8px;" title="Calculate maximum sendable amount">Max</button>
                    <button id="sendTransactionBtn" onclick="prepareSendTransaction()" class="wallet-button" style="background-color: #34d399;">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="22" y1="2" x2="11" y2="13"></line>
                            <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                        </svg>
                        Send
                    </button>
                </div>
            </div>

            <!-- Transaction History -->
            <div id="transactionHistoryContainer" style="margin-top: 20px; display: none;">
                <h4 style="margin-bottom: 10px;">Transaction History</h4>
                <div id="transactionHistoryList" style="max-height: 400px; overflow-y: auto; border: 1px solid #e9ecef; border-radius: 8px; padding: 10px; background-color: #f9fafb;">
                    <p style="color: #999; text-align: center;">Loading transactions...</p>
                </div>
            </div>
        </div>
        
        
        <!-- RPC Connection Section -->
        <div id="rpc-section" class="card-section">
            <h2>Cold Wallet</h2>
            
            <div id="connectionStatus" style="margin-top: 20px; display: none;">
                <div class="info-box" style="background-color: rgba(255, 186, 8, 0.1); border-left: 4px solid #ffba08;">
                    <p id="connectionStatusText">Connecting...</p>
                </div>
            </div>
            
            <!-- Import & Broadcast Transactions -->
            <div style="margin-top: 20px;">
                <input type="file" id="txFileInput" accept=".json" style="display: none;">
                <button id="importBroadcastBtn" onclick="document.getElementById('txFileInput').click()" class="wallet-button" style="background-color: #fbbf24;" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="7 10 12 15 17 10"></polyline>
                        <line x1="12" y1="15" x2="12" y2="3"></line>
                    </svg>
                    Import & Broadcast Transactions
                </button>
            </div>
            
            <!-- UTXO List Display -->
            <div id="utxoListContainer" style="margin-top: 15px;">
                <h4 style="margin-bottom: 10px;">Loaded UTXOs</h4>
                <div id="currentUtxoList" style="max-height: 300px; overflow-y: auto; border: 1px solid #e9ecef; border-radius: 8px; padding: 10px; background-color: #f9fafb; font-size: 12px; font-family: monospace;">
                    <p style="color: #999; text-align: center;">No UTXOs loaded</p>
                </div>
            </div>
            
            <!-- UTXO Import/Export Buttons -->
            <div style="margin-top: 15px; display: flex; gap: 3px;">
                <button id="exportUtxoBtn" onclick="exportUtxoData()" class="wallet-button" style="background-color: #06d6a0;">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="7 10 12 15 17 10"></polyline>
                        <line x1="12" y1="15" x2="12" y2="3"></line>
                    </svg>
                    Export UTXO Data
                </button>
                <button id="importUtxoBtn" onclick="importUtxoData()" class="wallet-button" style="background-color: #8338ec;">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="17 8 12 3 7 8"></polyline>
                        <line x1="12" y1="3" x2="12" y2="15"></line>
                    </svg>
                    Import UTXO Data
                </button>
                <button id="clearUtxoBtn" onclick="clearOfflineUtxoData()" class="wallet-button" style="background-color: #ef476f; display: none;">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="3 6 5 6 21 6"></polyline>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                    </svg>
                    Clear UTXOs
                </button>
            </div>
            
            <!-- Hidden file input for UTXO import -->
            <input type="file" id="utxoFileInput" accept=".json" style="display: none;">
        </div>
        
    </div>


    <script>
        // Character set for Bech32 encoding
        const CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
        
        // Save Modal Functions (global scope for onclick handlers)
        function showSaveModal() {
            const saveModal = document.getElementById('saveModal');
            const savePasswordInput = document.getElementById('savePasswordInput');
            const saveFilenameInput = document.getElementById('saveFilenameInput');
            
            // Generate filename from first address if available
            let filename = 'alpha_wallet_backup.txt';
            const wallet = window.walletGlobal;
            if (wallet && wallet.addresses && wallet.addresses.length > 0) {
                const firstAddress = wallet.addresses[0].address;
                // Get first 10 letters and last 6 letters
                const first10 = firstAddress.substring(0, 10);
                const last6 = firstAddress.substring(firstAddress.length - 6);
                
                // Add wallet type suffix
                let walletType = '_wif'; // Default for standard wallets
                if (wallet.isImportedAlphaWallet && wallet.masterChainCode) {
                    walletType = '_bip32';
                }
                
                filename = `${first10}_${last6}${walletType}.txt`;
            }
            
            saveModal.style.display = 'flex';
            document.body.style.overflow = 'hidden';
            savePasswordInput.value = '';
            saveFilenameInput.value = filename;
            savePasswordInput.focus();
        }
        
        function closeSaveModal() {
            const saveModal = document.getElementById('saveModal');
            saveModal.style.display = 'none';
            document.body.style.overflow = '';
        }
        
        function saveWallet() {
            const savePasswordInput = document.getElementById('savePasswordInput');
            const saveFilenameInput = document.getElementById('saveFilenameInput');
            const password = savePasswordInput.value;
            const filename = saveFilenameInput.value || 'alpha_wallet_backup.txt';
            
            // Access wallet from global scope or window
            const wallet = window.walletGlobal;
            
            if (!wallet || !wallet.masterPrivateKey) {
                window.showInAppNotification('No Wallet', 'No wallet to save', 'error');
                closeSaveModal();
                return;
            }
            
            let content;
            
            if (password) {
                // Encrypt the wallet with password
                const walletData = {
                    masterPrivateKey: wallet.masterPrivateKey,
                    masterChainCode: wallet.masterChainCode,
                    isImportedAlphaWallet: wallet.isImportedAlphaWallet,
                    addresses: wallet.addresses
                };
                
                // Use same encryption method as old format for backward compatibility
                const salt = "alpha_wallet_salt";
                const passwordKey = CryptoJS.PBKDF2(password, salt, { keySize: 256/32, iterations: 100000 }).toString();
                
                // Encrypt only the master private key for backward compatibility
                const encryptedMasterKey = CryptoJS.AES.encrypt(wallet.masterPrivateKey, passwordKey).toString();
                
                // Get addresses text - different format for BIP32 vs standard wallets
                let addressesText;
                if (wallet.isImportedAlphaWallet) {
                    addressesText = wallet.addresses.map((addr, index) => 
                        `Address ${index + 1}: ${addr.address}`
                    ).join('\n');
                } else {
                    addressesText = wallet.addresses.map(a => 
                        `Address ${a.index + 1}: ${a.address} (Path: ${a.path})`
                    ).join('\n');
                }
                
                // Build content with wallet type info
                let encryptedContent = `ENCRYPTED MASTER KEY (password protected):
${encryptedMasterKey}`;
                
                // Add chain code and wallet type for BIP32 wallets
                if (wallet.isImportedAlphaWallet && wallet.masterChainCode) {
                    encryptedContent += `

MASTER CHAIN CODE (for BIP32 HD wallet compatibility):
${wallet.masterChainCode}

WALLET TYPE: BIP32 hierarchical deterministic wallet`;
                } else {
                    encryptedContent += `

WALLET TYPE: Standard wallet (HMAC-based)`;
                }
                
                content = `UNICITY WALLET DETAILS
===========================

${encryptedContent}

ENCRYPTION STATUS: Encrypted with password
To use this key, you will need the password you set in the wallet.

YOUR ADDRESSES:
${addressesText}

Generated on: ${new Date().toLocaleString()}

WARNING: Keep your master private key safe and secure.
Anyone with your master private key can access all your funds.`;
            } else {
                // Save unencrypted wallet
                const masterKeyWIF = window.hexToWIF ? window.hexToWIF(wallet.masterPrivateKey) : wallet.masterPrivateKey;
                
                let masterKeySection;
                let addressesText;
                
                if (wallet.isImportedAlphaWallet && wallet.masterChainCode) {
                    // Format for imported Alpha wallet.dat files - save HEX first for internal use
                    masterKeySection = `MASTER PRIVATE KEY (keep secret!):
${wallet.masterPrivateKey}

MASTER PRIVATE KEY IN WIF FORMAT (for importprivkey command):
${masterKeyWIF}

MASTER CHAIN CODE (for BIP32 HD wallet compatibility):
${wallet.masterChainCode}

WALLET TYPE: BIP32 hierarchical deterministic wallet

ENCRYPTION STATUS: Not encrypted
This key is in plaintext and not protected. Anyone with this file can access your wallet.`;
                    
                    addressesText = wallet.addresses.map((addr, index) => 
                        `Address ${index + 1}: ${addr.address}`
                    ).join('\n');
                } else {
                    // Format for HTML wallet app created wallets - use old format exactly
                    addressesText = wallet.addresses.map(a => 
                        `Address ${a.index + 1}: ${a.address} (Path: ${a.path})`
                    ).join('\n');
                    
                    masterKeySection = 
`MASTER PRIVATE KEY (keep secret!):
${wallet.masterPrivateKey}

MASTER PRIVATE KEY IN WIF FORMAT (for importprivkey command):
${masterKeyWIF}

WALLET TYPE: Standard wallet (HMAC-based)

ENCRYPTION STATUS: Not encrypted
This key is in plaintext and not protected. Anyone with this file can access your wallet.`;
                }
                
                content = `UNICITY WALLET DETAILS
===========================

${masterKeySection}

YOUR ADDRESSES:
${addressesText}

Generated on: ${new Date().toLocaleString()}

WARNING: Keep your master private key safe and secure.
Anyone with your master private key can access all your funds.`;
            }
            
            // Create and download the file
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            const finalFilename = filename.endsWith('.txt') ? filename : filename + '.txt';
            a.download = finalFilename;
            document.body.appendChild(a);
            a.click();
            
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
            
            closeSaveModal();
            
            // Automatically verify the content before user relies on it
            setTimeout(() => {
                if (password) {
                    // For encrypted wallets, automatically verify with a re-entered password
                    const verifyPassword = prompt('Please re-enter your password to verify the wallet was encrypted correctly:');
                    if (verifyPassword) {
                        // Simulate reading the saved file by using the exact content we saved
                        verifyEncryptedWalletContent(content, password, verifyPassword, wallet);
                    } else {
                        window.showInAppNotification('Verification Skipped', 
                            'Wallet saved but not verified. Please ensure you remember your password!', 
                            'warning');
                    }
                } else {
                    // For unencrypted wallets, verify immediately
                    verifyUnencryptedWalletContent(content, wallet);
                }
            }, 300);
        }
        
        // Verify encrypted wallet content (same process as loading from file)
        function verifyEncryptedWalletContent(savedContent, originalPassword, verifyPassword, originalWallet) {
            // This simulates the exact same process as loading the wallet from a file
            try {
                // Extract encrypted master key using the old format pattern
                const encryptedKeyMatch = savedContent.match(/ENCRYPTED MASTER KEY \(password protected\):\s*([^\n]+)/);
                
                if (!encryptedKeyMatch || !encryptedKeyMatch[1]) {
                    throw new Error('Invalid encrypted wallet format - would fail to load from file');
                }
                
                const encryptedMasterKey = encryptedKeyMatch[1].trim();
                
                // Try to decrypt using the same method as wallet loading
                try {
                    // Use PBKDF2 for backward compatibility
                    const salt = "alpha_wallet_salt";
                    const passwordKey = CryptoJS.PBKDF2(verifyPassword, salt, { keySize: 256/32, iterations: 100000 }).toString();
                    
                    // Decrypt the master key
                    const decryptedBytes = CryptoJS.AES.decrypt(encryptedMasterKey, passwordKey);
                    const decryptedMasterKey = decryptedBytes.toString(CryptoJS.enc.Utf8);
                    
                    // Check if decryption produced empty result (wrong password)
                    if (!decryptedMasterKey) {
                        if (verifyPassword !== originalPassword) {
                            window.showInAppNotification('Incorrect Password', 
                                'The verification password is incorrect. The wallet was encrypted with the first password.', 
                                'error');
                        } else {
                            // This shouldn't happen - same password but can't decrypt
                            showCriticalError('Encryption verification failed - unable to decrypt with the same password');
                        }
                        return;
                    }
                    
                    // Check if passwords match
                    if (originalPassword !== verifyPassword) {
                        window.showInAppNotification('Password Mismatch', 
                            'The verification password does not match. The wallet was encrypted with the first password you entered.', 
                            'warning');
                        return;
                    }
                    
                    // Verify master key matches
                    if (decryptedMasterKey !== originalWallet.masterPrivateKey) {
                        showCriticalError('Master key mismatch after decryption');
                        return;
                    }
                    
                    // Also verify addresses from the file content
                    const addressMatches = savedContent.match(/Address \d+: (alpha1[a-z0-9]{38,})/g);
                    if (addressMatches) {
                        const savedAddresses = addressMatches.map(match => {
                            const addrMatch = match.match(/Address \d+: (alpha1[a-z0-9]{38,})/);
                            return addrMatch ? addrMatch[1] : null;
                        }).filter(a => a).sort();
                        
                        const currentAddresses = originalWallet.addresses.map(a => a.address).sort();
                    
                        if (JSON.stringify(savedAddresses) !== JSON.stringify(currentAddresses)) {
                            showCriticalError('Address mismatch detected during verification');
                            return;
                        }
                    }
                    
                    window.showInAppNotification('✅ Wallet Verified', 
                        'Encrypted wallet saved successfully! Decryption and address derivation verified.', 
                        'success');
                        
                } catch (decryptError) {
                    console.error('Decryption error:', decryptError);
                    
                    // Check if it's a UTF-8 error (usually means wrong password or corrupted data)
                    if (decryptError.message && decryptError.message.includes('UTF-8')) {
                        if (verifyPassword !== originalPassword) {
                            window.showInAppNotification('Incorrect Password', 
                                'The verification password is incorrect. The wallet was encrypted with the first password.', 
                                'error');
                        } else {
                            // Both passwords are the same but still can't decrypt - this is a critical error
                            showCriticalError('Encryption failed - unable to decrypt with the correct password. Error: ' + decryptError.message);
                        }
                    } else if (decryptError.message && decryptError.message.includes('JSON')) {
                        showCriticalError('Decrypted data is not valid JSON: ' + decryptError.message);
                    } else {
                        showCriticalError('Decryption failed during verification: ' + decryptError.message);
                    }
                }
            } catch (error) {
                showCriticalError('Failed to verify encrypted wallet: ' + error.message);
            }
        }
        
        // Verify unencrypted wallet content
        function verifyUnencryptedWalletContent(savedContent, originalWallet) {
            try {
                // Extract addresses from saved content (same as file loading would do)
                const addressMatches = savedContent.match(/Address \d+: (alpha1[a-z0-9]{38,})/g);
                if (!addressMatches) {
                    showCriticalError('No addresses found in saved wallet content');
                    return;
                }
                
                const savedAddresses = addressMatches.map(match => {
                    const addrMatch = match.match(/Address \d+: (alpha1[a-z0-9]{38,})/);
                    return addrMatch ? addrMatch[1] : null;
                }).filter(a => a).sort();
                
                const currentAddresses = originalWallet.addresses.map(a => a.address).sort();
                
                if (JSON.stringify(savedAddresses) !== JSON.stringify(currentAddresses)) {
                    showCriticalError('Address mismatch detected in saved content');
                    return;
                }
                
                // Extract and verify master key
                const masterKeyMatch = savedContent.match(/MASTER PRIVATE KEY \(keep secret!\):\s*([^\n]+)/);
                if (masterKeyMatch) {
                    const savedMasterKey = masterKeyMatch[1].trim();
                    // The saved file has the hex key, we need to verify it matches
                    if (savedMasterKey !== originalWallet.masterPrivateKey && 
                        !verifyKeyEquivalence(savedMasterKey, originalWallet.masterPrivateKey)) {
                        showCriticalError('Master key mismatch detected in saved content');
                        return;
                    }
                }
                
                window.showInAppNotification('✅ Wallet Verified', 
                    'Wallet saved successfully! All addresses verified.', 
                    'success');
                    
            } catch (error) {
                showCriticalError('Failed to verify wallet: ' + error.message);
            }
        }
        
        // Helper to verify if two keys are equivalent (one might be WIF, other hex)
        function verifyKeyEquivalence(key1, key2) {
            // If they're exactly the same, they're equivalent
            if (key1 === key2) return true;
            
            // Try converting hex to WIF if one is hex
            if (key1.length === 64 && window.hexToWIF) {
                return window.hexToWIF(key1) === key2;
            }
            if (key2.length === 64 && window.hexToWIF) {
                return key1 === window.hexToWIF(key2);
            }
            
            return false;
        }
        
        // Keep old function for backward compatibility but it's not used anymore
        function verifyEncryptedWallet(savedContent, originalPassword, verifyPassword, originalWallet, isFromFile = false) {
            try {
                // Extract encrypted data from saved content
                const encryptedMatch = savedContent.match(/ENCRYPTED UNICITY WALLET[\s\S]*?\n\n([\s\S]+?)\n\nGenerated on:/);
                
                if (!encryptedMatch || !encryptedMatch[1]) {
                    throw new Error('Could not extract encrypted data from saved file');
                }
                
                const encryptedData = encryptedMatch[1].trim();
                
                // Try to decrypt with the verify password
                try {
                    const decryptedData = CryptoJS.AES.decrypt(encryptedData, verifyPassword).toString(CryptoJS.enc.Utf8);
                    const walletData = JSON.parse(decryptedData);
                    
                    // Check if passwords match
                    if (originalPassword !== verifyPassword) {
                        window.showInAppNotification('Password Mismatch', 
                            'The verification password does not match the encryption password. The wallet was saved with the first password you entered.', 
                            'warning');
                        return;
                    }
                    
                    // Verify addresses match
                    const savedAddresses = walletData.addresses.map(a => a.address).sort();
                    const currentAddresses = originalWallet.addresses.map(a => a.address).sort();
                    
                    if (JSON.stringify(savedAddresses) !== JSON.stringify(currentAddresses)) {
                        showCriticalError('Address mismatch detected');
                        return;
                    }
                    
                    // Verify master key matches
                    if (walletData.masterPrivateKey !== originalWallet.masterPrivateKey) {
                        showCriticalError('Master key mismatch detected');
                        return;
                    }
                    
                    window.showInAppNotification('Wallet Verified', 
                        isFromFile ? 'Encrypted wallet file read and verified successfully!' : 'Encrypted wallet saved and verified successfully!', 
                        'success');
                        
                } catch (decryptError) {
                    if (verifyPassword !== originalPassword) {
                        window.showInAppNotification('Incorrect Password', 
                            'The verification password is incorrect. The wallet was saved with the first password you entered.', 
                            'error');
                    } else {
                        showCriticalError('Decryption failed during verification');
                    }
                }
            } catch (error) {
                showCriticalError('Failed to verify encrypted wallet: ' + error.message);
            }
        }
        
        // Verify unencrypted wallet addresses match
        function verifyUnencryptedWallet(savedContent, originalWallet, isFromFile = false) {
            try {
                // Extract addresses from saved content
                const addressMatches = savedContent.match(/Address \d+: (alpha1[a-z0-9]{38,})/g);
                if (!addressMatches) {
                    showCriticalError('No addresses found in saved wallet file');
                    return;
                }
                
                const savedAddresses = addressMatches.map(match => {
                    const addrMatch = match.match(/Address \d+: (alpha1[a-z0-9]{38,})/);
                    return addrMatch ? addrMatch[1] : null;
                }).filter(a => a).sort();
                
                const currentAddresses = originalWallet.addresses.map(a => a.address).sort();
                
                if (JSON.stringify(savedAddresses) !== JSON.stringify(currentAddresses)) {
                    showCriticalError('Address mismatch detected in saved file');
                    return;
                }
                
                // Extract and verify master key
                const masterKeyMatch = savedContent.match(/MASTER PRIVATE KEY \(keep secret!\):\s*([^\n]+)/);
                if (masterKeyMatch) {
                    const savedMasterKey = masterKeyMatch[1].trim();
                    // Compare hex format if both are hex, or WIF if needed
                    if (savedMasterKey !== originalWallet.masterPrivateKey && 
                        savedMasterKey !== (window.hexToWIF ? window.hexToWIF(originalWallet.masterPrivateKey) : originalWallet.masterPrivateKey)) {
                        // It's OK if one is WIF and other is hex, as long as they represent the same key
                        // For now, we'll just log a warning
                        console.log('Master key format difference detected (hex vs WIF)');
                    }
                }
                
                window.showInAppNotification('Wallet Verified', 
                    isFromFile ? 'Wallet file read and verified successfully!' : 'Wallet saved and verified successfully!', 
                    'success');
                    
            } catch (error) {
                showCriticalError('Failed to verify wallet: ' + error.message);
            }
        }
        
        // Show critical error dialog
        function showCriticalError(details) {
            const errorModal = document.createElement('div');
            errorModal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;
            
            errorModal.innerHTML = `
                <div style="background: white; padding: 30px; border-radius: 10px; max-width: 600px; text-align: center;">
                    <div style="font-size: 48px; color: #ff0000; margin-bottom: 20px;">⚠️ CRITICAL ERROR</div>
                    <h2 style="color: #ff0000; margin-bottom: 20px;">WALLET SAVE VERIFICATION FAILED</h2>
                    <p style="font-size: 18px; margin-bottom: 20px; color: #333;">
                        The saved wallet file could not be verified. This is an internal application error.
                    </p>
                    <p style="font-size: 16px; margin-bottom: 20px; color: #666;">
                        <strong>Error details:</strong> ${details}
                    </p>
                    <div style="background: #ffe0e0; padding: 20px; border-radius: 5px; margin-bottom: 20px;">
                        <p style="font-size: 16px; color: #cc0000; margin: 0;">
                            <strong>IMPORTANT:</strong> Do not rely on this backup file!<br>
                            Please report this issue immediately to the developer (cryptohog) 
                            on the Discord helpdesk channel.
                        </p>
                    </div>
                    <button onclick="this.parentElement.parentElement.remove()" 
                            style="background: #ff0000; color: white; border: none; padding: 10px 30px; 
                                   border-radius: 5px; font-size: 16px; cursor: pointer;">
                        Close
                    </button>
                </div>
            `;
            
            document.body.appendChild(errorModal);
        }

        document.addEventListener('DOMContentLoaded', function() {
            // Global variables that need to be available throughout the app
            let currentBlockHeight = null;
            let currentBlockTime = null;
            let lastUpdateBlockHeight = null;
            let currentUtxos = [];
            let currentTransactions = [];
            let currentTransactionPage = 1;
            let currentUtxoPage = 1;
            let offlineUtxoData = null;
            let electrumConnected = false;
            let broadcastQueue = [];
            let isQueueProcessing = false;
            let lastBroadcastBlock = null;
            let transactionsInCurrentBlock = 0;
            const MAX_TRANSACTIONS_PER_BLOCK = 30;
            let queueStatusElement = null;
            let autoClearTimeout = null;
            
            // HTML elements
            // const masterKeyElement = document.getElementById('masterKey'); // Removed with Security section
            const addressList = document.getElementById('addressList');
            const passwordStrength = document.getElementById('passwordStrength');
            // const encryptionStatus = document.getElementById('encryptionStatus'); // Removed with Security section
            const walletInfo = document.getElementById('walletInfo');
            const walletAddress = document.getElementById('walletAddress');
            const walletAddressLink = document.getElementById('walletAddressLink');
            const walletBalance = document.getElementById('walletBalance');
            const walletUnconfirmed = document.getElementById('walletUnconfirmed');
            const lastUpdateTime = document.getElementById('lastUpdateTime');
            const walletQrCode = document.getElementById('walletQrCode');
            
            // Watch-only elements
            const watchOnlySection = document.getElementById('watchOnlySection');
            const watchOnlyAddress = document.getElementById('watchOnlyAddress');
            const watchOnlyBalance = document.getElementById('watchOnlyBalance');
            const watchOnlyUnconfirmed = document.getElementById('watchOnlyUnconfirmed');
            const sendTransactionBtn = document.getElementById('sendTransactionBtn');
            
            // Watch-only state
            let watchOnlyMode = false;
            let watchOnlyAddressValue = null;
            
            // Buttons
            const initializeWalletBtn = document.getElementById('initializeWalletBtn');
            const generateAddressBtn = document.getElementById('generateAddressBtn');
            // const toggleMasterKeyBtn = document.getElementById('toggleMasterKeyBtn'); // Removed with Security section
            const deleteWalletBtn = document.getElementById('deleteWalletBtn');
            const saveWalletBtn = document.getElementById('saveWalletBtn');
            const restoreWalletBtn = document.getElementById('restoreWalletBtn');
            const importUtxoBtn = document.getElementById('importUtxoBtn');
            const clearUtxoBtn = document.getElementById('clearUtxoBtn');
            
            // Password Modal Elements
            const passwordModal = document.getElementById('passwordModal');
            const passwordModalTitle = document.getElementById('passwordModalTitle');
            const passwordModalMessage = document.getElementById('passwordModalMessage');
            const passwordModalInput = document.getElementById('passwordModalInput');
            const passwordModalCancelBtn = document.getElementById('passwordModalCancelBtn');
            const passwordModalSubmitBtn = document.getElementById('passwordModalSubmitBtn');
            
            // Password Modal Promise Resolution
            let resolvePasswordPromise = null;

            // Wallet data
            let wallet = {
                masterPrivateKey: '',
                addresses: [],
                isEncrypted: false,
                encryptedMasterKey: ''
            };
            
            // Make wallet globally accessible for save modal
            window.walletGlobal = wallet;
            
            // Ensure encryption status is hidden by default
            // encryptionStatus.style.display = 'none'; // Removed with Security section
            
            // Helper function to update enabled/disabled state of buttons based on wallet state
            function updateButtonStates(walletExists) {
                saveWalletBtn.disabled = !walletExists;
                deleteWalletBtn.disabled = !walletExists;
                initializeWalletBtn.disabled = walletExists;
                restoreWalletBtn.disabled = walletExists;
                
                // Update button tooltips
                if (walletExists) {
                    initializeWalletBtn.title = "Wallet already created";
                    saveWalletBtn.title = "Save wallet to file with optional encryption";
                } else {
                    initializeWalletBtn.title = "Creates a new wallet with a secure private key. This is the first step to use this wallet.";
                    saveWalletBtn.title = "Create a wallet first";
                }
            }
            
            // Password modal functions
            function showPasswordModal(title, message) {
                return new Promise((resolve, reject) => {
                    // Set the title and message
                    passwordModalTitle.textContent = title || "Enter Password";
                    passwordModalMessage.textContent = message || "Please enter your wallet password:";
                    
                    // Clear any previous password
                    passwordModalInput.value = "";
                    
                    // Store the resolve function
                    resolvePasswordPromise = resolve;
                    
                    // Show the modal
                    passwordModal.style.display = "flex";
                    document.body.style.overflow = "hidden"; // Prevent scrolling
                    
                    // Focus the input field
                    passwordModalInput.focus();
                });
            }
            
            function closePasswordModal(success) {
                // Hide the modal
                passwordModal.style.display = "none";
                document.body.style.overflow = ""; // Restore scrolling
                
                // Resolve the promise with success/failure
                if (resolvePasswordPromise) {
                    if (success) {
                        resolvePasswordPromise(passwordModalInput.value);
                    } else {
                        resolvePasswordPromise(null);
                    }
                    resolvePasswordPromise = null;
                }
            }
            
            // Set up password modal event listeners
            passwordModalCancelBtn.addEventListener('click', () => closePasswordModal(false));
            passwordModalSubmitBtn.addEventListener('click', () => closePasswordModal(true));
            
            // Handle Enter key in password modal
            passwordModalInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    closePasswordModal(true);
                }
            });
            
            // Load wallet data from IndexedDB or localStorage if available
            function loadWalletData() {
                // Start with buttons disabled by default
                updateButtonStates(false);
                try {
                    // Try to load from IndexedDB first
                    const request = indexedDB.open("AlphaWalletDB", 1);
                    
                    request.onupgradeneeded = function(event) {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('wallet')) {
                            db.createObjectStore('wallet', { keyPath: 'id' });
                        }
                    };
                    
                    request.onerror = function(event) {
                        console.error("IndexedDB error:", event.target.error);
                        // Fall back to localStorage
                        loadFromLocalStorage();
                    };
                    
                    request.onsuccess = function(event) {
                        const db = event.target.result;
                        const transaction = db.transaction(['wallet'], 'readonly');
                        const store = transaction.objectStore('wallet');
                        const getRequest = store.get('main-wallet');
                        
                        getRequest.onsuccess = function(event) {
                            if (event.target.result) {
                                // Data found in IndexedDB
                                const savedWallet = event.target.result;
                                // Remove the ID property we added for IndexedDB
                                delete savedWallet.id;
                                wallet = savedWallet;
                                // Update global reference
                                window.walletGlobal = wallet;
                                updateUIFromWallet();
                            } else {
                                // No data in IndexedDB, try localStorage
                                loadFromLocalStorage();
                            }
                        };
                        
                        getRequest.onerror = function() {
                            // Error getting data from IndexedDB, fall back to localStorage
                            loadFromLocalStorage();
                        };
                    };
                } catch (e) {
                    console.error("Error accessing IndexedDB:", e);
                    // Fall back to localStorage
                    loadFromLocalStorage();
                }
                
                // Helper function to load from localStorage
                function loadFromLocalStorage() {
                    const savedWallet = localStorage.getItem('alphaWallet');
                    if (savedWallet) {
                        try {
                            const parsedWallet = JSON.parse(savedWallet);
                            wallet = parsedWallet;
                            // Update global reference
                            window.walletGlobal = wallet;
                            updateUIFromWallet();
                        } catch (e) {
                            console.error("Error parsing wallet data from localStorage", e);
                        }
                    }
                }
                
                // Helper function to update UI based on wallet data
                function updateUIFromWallet() {
                    // Update UI if wallet exists
                    if (wallet.masterPrivateKey) {
                        // Update regular master key display
                        // masterKeyElement.textContent = wallet.masterPrivateKey; // Removed with Security section
                        // masterKeyElement.classList.add('masked'); // Removed with Security section
                        
                        // Generate the child key for the first address
                        let childPrivateKey;
                        let wifKey;
                        
                        if (wallet.isImportedAlphaWallet && wallet.masterChainCode) {
                            // For BIP32 wallets, don't generate here - it's already in the address
                            if (wallet.addresses && wallet.addresses.length > 0 && wallet.childPrivateKey) {
                                childPrivateKey = wallet.childPrivateKey;
                                wifKey = hexToWIF(childPrivateKey);
                            } else {
                                // If no address yet, we'll generate one later
                                wifKey = "Generate an address to see the key";
                            }
                        } else {
                            // For standard wallets, use HMAC derivation
                            const addressIndex = 0;
                            const derivationPath = `m/44'/0'/${addressIndex}'`;
                            const hmacInput = CryptoJS.enc.Hex.parse(wallet.masterPrivateKey);
                            const hmacKey = CryptoJS.enc.Utf8.parse(derivationPath);
                            const hmacOutput = CryptoJS.HmacSHA512(hmacInput, hmacKey).toString();
                            childPrivateKey = hmacOutput.substring(0, 64);
                            wifKey = hexToWIF(childPrivateKey);
                        }
                        // const wifKeyElement = document.getElementById('wifMasterKey'); // Removed with Security section
                        // wifKeyElement.textContent = wifKey; // Removed with Security section
                        // wifKeyElement.classList.add('masked'); // Removed with Security section
                        
                        // Enable buttons
                        updateButtonStates(true);
                        
                        // Render address (just the first one)
                        if (wallet.addresses && wallet.addresses.length > 0) {
                            addAddressToUI(wallet.addresses[0]);
                            
                            // Check if this wallet is part of scanned wallets and sync balance
                            if (lastScannedWalletData && lastScannedWalletData.wallets) {
                                const currentAddress = wallet.addresses[0].address;
                                const scannedWallet = lastScannedWalletData.wallets.find(w => w.address === currentAddress);
                                
                                if (scannedWallet) {
                                    
                                    // Update master keys if not already set
                                    if (!lastScannedWalletData.masterKey && wallet.masterPrivateKey) {
                                        lastScannedWalletData.masterKey = wallet.masterPrivateKey;
                                        lastScannedWalletData.masterChainCode = wallet.masterChainCode;
                                        lastScannedWalletData.isAlphaWallet = wallet.isImportedAlphaWallet;
                                        
                                        // Save updated data with master keys
                                        const fingerprint = generateWalletFingerprint(
                                            lastScannedWalletData.masterKey,
                                            lastScannedWalletData.masterChainCode
                                        );
                                        if (fingerprint) {
                                            saveScanResultsToCache(fingerprint, lastScannedWalletData);
                                        }
                                    }
                                }
                            }
                            
                            // Update balance display
                            updateCommonBalance();
                            
                            // If already connected to Fulcrum, refresh balance
                            if (electrumConnected) {
                                refreshBalance();
                                updateTransactionHistory();
                            }
                        }
                    } else {
                        // No wallet, disable buttons
                        updateButtonStates(false);
                    }
                    
                    // Check if wallet is encrypted and update UI
                    if (wallet.isEncrypted) {
                        // encryptionStatus.style.display = 'block'; // Removed with Security section
                        // Hide password strength indicator when wallet is encrypted
                        passwordStrength.innerHTML = '';
                    } else {
                        // encryptionStatus.style.display = 'none'; // Removed with Security section
                    }
                }
            }

            // Initialize wallet with master key using secure randomness
            function initializeWallet() {
                // Add confirmation dialog if wallet is being re-created
                if (wallet.masterPrivateKey) {
                    const confirmReset = confirm("This will reset your wallet and generate a new private key. Any existing addresses will be lost. Are you sure you want to continue?");
                    if (!confirmReset) {
                        return;
                    }
                }
                
                // Use Web Crypto API for cryptographically secure random number generation
                const randomBytes = new Uint8Array(32); // 256 bits for the private key
                window.crypto.getRandomValues(randomBytes);
                
                // Convert random bytes to hex string
                const randomHex = Array.from(randomBytes)
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join('');
                
                // Create key pair from the secure random bytes
                const ec = new elliptic.ec('secp256k1');
                const keyPair = ec.keyFromPrivate(randomHex);
                
                wallet.masterPrivateKey = randomHex;
                wallet.addresses = [];
                wallet.isEncrypted = false;
                wallet.encryptedMasterKey = '';
                wallet.childPrivateKey = null; // Will be set when generating first address
                
                // Update global reference
                window.walletGlobal = wallet;
                
                // masterKeyElement.textContent = wallet.masterPrivateKey; // Removed with Security section
                // masterKeyElement.classList.add('masked'); // Removed with Security section
                // toggleMasterKeyBtn.textContent = 'Show'; // Removed with Security section
                
                // We'll update the WIF key after generating an address
                // This placeholder will be replaced with the child key's WIF
                // const wifKeyElement = document.getElementById('wifMasterKey'); // Removed with Security section
                // wifKeyElement.textContent = "Generate an address to see the key"; // Removed with Security section
                // wifKeyElement.classList.add('masked'); // Removed with Security section
                
                
                // Enable/disable buttons
                updateButtonStates(true);
                
                // Generate first address
                generateNewAddress();
                
                // Save wallet to local storage
                saveWalletData();
                
                // Close any open sections to maintain a clean UI
                // document.getElementById('keys-section').style.display = 'none'; // Removed with Security section
                
                // Make sure encryption status is hidden for new wallets
                // encryptionStatus.style.display = 'none'; // Removed with Security section
                
                
                // Reset section button text - Removed with Security section
                /*
                document.getElementById('showEncryptionBtn').innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                        <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
                    </svg>
                    Encrypt`;
                    
                document.getElementById('showRestoreBtn').innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="17 8 12 3 7 8"></polyline>
                        <line x1="12" y1="3" x2="12" y2="15"></line>
                    </svg>
                    Restore Wallet`;
                */
                    
                /* // Removed with Security section
                document.getElementById('showAdvancedBtn').innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                        <path d="M12 20h9"></path>
                        <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>
                    </svg>
                    Migrate Wallet`;
                */
            }
            
            // BIP32 key derivation for imported wallets
            function deriveKeyBIP32(parentKey, parentChainCode, index, hardened = false) {
                // Proper BIP32 child key derivation
                const secp256k1_n = BigInt('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141');
                
                // Create data for HMAC
                let data;
                if (hardened) {
                    // Hardened: 0x00 || parentKey || index
                    data = new Uint8Array(37);
                    data[0] = 0x00;
                    const keyBytes = hexToBytes(parentKey);
                    data.set(keyBytes, 1);
                    // Set index as big-endian 32-bit integer with hardened bit
                    const indexBytes = new Uint8Array(4);
                    const hardenedIndex = index + 0x80000000;
                    indexBytes[0] = (hardenedIndex >> 24) & 0xff;
                    indexBytes[1] = (hardenedIndex >> 16) & 0xff;
                    indexBytes[2] = (hardenedIndex >> 8) & 0xff;
                    indexBytes[3] = hardenedIndex & 0xff;
                    data.set(indexBytes, 33);
                } else {
                    // Non-hardened: publicKey || index
                    const ec = new elliptic.ec('secp256k1');
                    const keyPair = ec.keyFromPrivate(parentKey);
                    const pubKey = keyPair.getPublic(true, 'hex');
                    const pubKeyBytes = hexToBytes(pubKey);
                    
                    data = new Uint8Array(37);
                    data.set(pubKeyBytes, 0);
                    // Set index as big-endian 32-bit integer
                    const indexBytes = new Uint8Array(4);
                    indexBytes[0] = (index >> 24) & 0xff;
                    indexBytes[1] = (index >> 16) & 0xff;
                    indexBytes[2] = (index >> 8) & 0xff;
                    indexBytes[3] = index & 0xff;
                    data.set(indexBytes, 33);
                }
                
                // HMAC-SHA512 with parent chain code
                const hmacKey = CryptoJS.enc.Hex.parse(parentChainCode);
                const hmacData = CryptoJS.enc.Hex.parse(bytesToHex(data));
                const I = CryptoJS.HmacSHA512(hmacData, hmacKey).toString();
                
                const IL = I.substring(0, 64);  // Left 32 bytes (256 bits)
                const IR = I.substring(64);      // Right 32 bytes (chain code)
                
                // Calculate child private key: (IL + parentKey) mod n
                const ILBigInt = BigInt('0x' + IL);
                const parentKeyBigInt = BigInt('0x' + parentKey);
                const childKeyBigInt = (ILBigInt + parentKeyBigInt) % secp256k1_n;
                
                // Convert back to hex string (padded to 64 chars)
                const childKey = childKeyBigInt.toString(16).padStart(64, '0');
                
                return {
                    key: childKey,
                    chainCode: IR
                };
            }
            
            // Derive HD wallet path
            function deriveHDPath(masterKey, masterChainCode, path) {
                // Parse path like "m/84'/1'/0'/0/0"
                const parts = path.split('/').slice(1); // Remove 'm'
                
                let currentKey = masterKey;
                let currentChainCode = masterChainCode;
                
                for (const part of parts) {
                    const hardened = part.endsWith("'");
                    const index = parseInt(hardened ? part.slice(0, -1) : part);
                    
                    const result = deriveKeyBIP32(currentKey, currentChainCode, index, hardened);
                    currentKey = result.key;
                    currentChainCode = result.chainCode;
                }
                
                return currentKey;
            }
            
            // Generate a new address from master key
            function generateNewAddress() {
                if (!wallet.masterPrivateKey) {
                    alert('Please create a wallet first');
                    return;
                }
                
                const addressIndex = wallet.addresses.length;
                const ec = new elliptic.ec('secp256k1');
                
                let childPrivateKey;
                let derivationPath;
                let publicKey;
                
                // Check if this is an imported Alpha wallet
                if (wallet.isImportedAlphaWallet && wallet.masterChainCode) {
                    // For imported BIP32 HD wallets, use proper BIP32 derivation
                    // Default to BIP84 path for native SegWit: m/84'/1'/0'/0/index
                    // Note: Using testnet (1') as seen in the descriptors
                    
                    // Derive the path step by step
                    let key = wallet.masterPrivateKey;
                    let chainCode = wallet.masterChainCode;
                    
                    // m/84' - Purpose (native SegWit)
                    let result = deriveKeyBIP32(key, chainCode, 84, true);
                    key = result.key;
                    chainCode = result.chainCode;
                    
                    // m/84'/1' - Coin type (1 = testnet)
                    result = deriveKeyBIP32(key, chainCode, 1, true);
                    key = result.key;
                    chainCode = result.chainCode;
                    
                    // m/84'/1'/0' - Account
                    result = deriveKeyBIP32(key, chainCode, 0, true);
                    key = result.key;
                    chainCode = result.chainCode;
                    
                    // m/84'/1'/0'/0 - External chain
                    result = deriveKeyBIP32(key, chainCode, 0, false);
                    key = result.key;
                    chainCode = result.chainCode;
                    
                    // m/84'/1'/0'/0/index - Address index
                    result = deriveKeyBIP32(key, chainCode, addressIndex, false);
                    childPrivateKey = result.key;
                    
                    derivationPath = `m/84'/1'/0'/0/${addressIndex}`;
                    
                    const keyPair = ec.keyFromPrivate(childPrivateKey);
                    publicKey = keyPair.getPublic(true, 'hex');
                } else {
                    // Original HMAC-based derivation for wallets created in this app
                    derivationPath = `m/44'/0'/${addressIndex}'`;
                    
                    // Improved HMAC-based derivation for better security
                    // Using HMAC-SHA512 for more secure key derivation
                    const hmacInput = CryptoJS.enc.Hex.parse(wallet.masterPrivateKey);
                    const hmacKey = CryptoJS.enc.Utf8.parse(derivationPath);
                    const hmacOutput = CryptoJS.HmacSHA512(hmacInput, hmacKey).toString();
                    
                    // Use left 32 bytes for private key, right 32 bytes could be used for chain code in a full HD wallet
                    childPrivateKey = hmacOutput.substring(0, 64);
                    
                    // Generate key pair from the derived key
                    const keyPair = ec.keyFromPrivate(childPrivateKey);
                    publicKey = keyPair.getPublic(true, 'hex');
                }
                
                // Store the child private key for the first address (used for transactions)
                if (addressIndex === 0) {
                    wallet.childPrivateKey = childPrivateKey;
                }
                
                // Generate address according to BIP-173 SegWit standard
                const sha256Hash = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(publicKey));
                const ripemd160Hash = CryptoJS.RIPEMD160(sha256Hash);
                const programData = ripemd160Hash.toString();
                
                // According to BIP-173, for P2WPKH (witness version 0), the witness program must be exactly 20 bytes
                // For other witness versions (1-16), the program can be 2-40 bytes
                const witnessVersion = 0;
                
                // Create the standard compliant bech32 address
                const address = createBech32('alpha', witnessVersion, hexToBytes(programData));
                
                // Add to wallet with additional security metadata
                wallet.addresses.push({
                    index: addressIndex,
                    address: address,
                    publicKey: publicKey,
                    path: derivationPath,
                    createdAt: new Date().toISOString()
                });
                
                // Add to UI
                addAddressToUI(wallet.addresses[addressIndex]);
                
                // Save wallet to local storage
                saveWalletData();
                
                // Show notification
                if (addressIndex === 0) {
                    showInAppNotification('Wallet Created', 'Your new wallet has been created successfully', 'success');
                } else {
                    showInAppNotification('Address Generated', `New address generated at index ${addressIndex}`, 'success');
                }
                
                // If already connected to Fulcrum, refresh balance for new address
                if (electrumConnected) {
                    setTimeout(() => {
                        refreshBalance();
                        updateTransactionHistory();
                    }, 500); // Small delay to ensure UI is updated
                }
            }
            
            // Add address to UI
            function addAddressToUI(addressInfo) {
                // Show wallet info section
                walletInfo.style.display = 'block';
                
                // Update address
                walletAddress.textContent = addressInfo.address;
                walletAddressLink.href = `https://www.unicity.network/address/${addressInfo.address}`;
                
                // Generate QR code
                generateWalletQRCode(addressInfo.address);
                
                // Update balance display
                updateCommonBalance();
                
                // Update UTXO list display
                updateUtxoListDisplay();
                
                // If already connected to Fulcrum, refresh balance
                if (electrumConnected && !wallet.addresses.find(a => a.address.toLowerCase() === addressInfo.address.toLowerCase())) {
                    setTimeout(() => {
                        refreshBalance();
                        updateTransactionHistory();
                    }, 500);
                }
            }
            
            // Generate QR code for wallet address
            function generateWalletQRCode(address) {
                // Clear existing QR code
                walletQrCode.innerHTML = '';
                
                // Create QR code with smaller size
                new QRCode(walletQrCode, {
                    text: address,
                    width: 100,
                    height: 100,
                    colorDark: "#3a86ff",
                    colorLight: "#ffffff",
                    correctLevel: QRCode.CorrectLevel.M
                });
                
                walletQrCode.style.display = 'block';
            }
            
            
            // Show QR code for an address
            function showQRCode(address) {
                const modal = document.getElementById('qrModal');
                const qrAddress = document.getElementById('qrAddress');
                const qrContainer = document.getElementById('qrContainer');
                
                // Display the address without spacing
                qrAddress.textContent = address;
                
                // Clear previous QR code
                qrContainer.innerHTML = '';
                
                // Generate QR code with improved styling
                const qrCode = new QRCode(qrContainer, {
                    text: address,
                    width: 320,
                    height: 320,
                    colorDark: "#3a86ff",
                    colorLight: "#ffffff",
                    correctLevel: QRCode.CorrectLevel.H
                });
                
                // Show modal with animation
                modal.style.display = 'flex';
                document.body.style.overflow = 'hidden'; // Prevent scrolling while modal is open
                
                // Add event listener to close modal when clicking outside
                modal.onclick = function(e) {
                    if (e.target === modal) {
                        document.getElementById('qrModal').style.display = 'none';
                        document.body.style.overflow = '';
                    }
                };
                
                // Add escape key listener
                document.onkeydown = function(e) {
                    if (e.key === 'Escape') {
                        document.getElementById('qrModal').style.display = 'none';
                        document.body.style.overflow = '';
                    }
                };
            }
            
            // Close QR modal
            function closeQRModal() {
                const modal = document.getElementById('qrModal');
                modal.style.display = 'none';
                document.body.style.overflow = ''; // Restore scrolling
            }
            
            // Toggle master key visibility
            /* // Removed with Security section
            async function toggleMasterKey() {
                if (masterKeyElement.classList.contains('masked')) {
                    // Check if wallet is encrypted
                    if (wallet.isEncrypted) {
                        // Ask for password with custom modal
                        const password = await showPasswordModal(
                            "Enter Password",
                            "Your wallet is encrypted. Please enter your password to view the private key:"
                        );
                        
                        if (!password) {
                            return; // User cancelled
                        }
                        
                        try {
                            // Generate key from password
                            const salt = "alpha_wallet_salt";
                            const passwordKey = CryptoJS.PBKDF2(password, salt, { keySize: 256/32, iterations: 100000 }).toString();
                            
                            // Try to decrypt the master key
                            const decryptedKey = CryptoJS.AES.decrypt(wallet.encryptedMasterKey, passwordKey).toString(CryptoJS.enc.Utf8);
                            
                            // If decryption failed, this will be an empty string
                            if (!decryptedKey) {
                                alert("Incorrect password. Access denied.");
                                return;
                            }
                            
                            // Check if the decrypted key matches our stored key
                            if (decryptedKey !== wallet.masterPrivateKey) {
                                alert("Incorrect password. Access denied.");
                                return;
                            }
                            
                            // Password verified, proceed with normal confirmation
                        } catch (e) {
                            console.error("Error decrypting private key:", e);
                            alert("Error verifying password. Access denied.");
                            return;
                        }
                    }
                    
                    // Show a confirmation dialog
                    const shouldShow = confirm("You are about to reveal your private key. Make sure no one is looking at your screen. Continue?");
                    
                    if (shouldShow) {
                        masterKeyElement.classList.remove('masked');
                        // toggleMasterKeyBtn.textContent = 'Hide'; // Removed with Security section
                        
                        // Auto-hide after 30 seconds for security
                        setTimeout(() => {
                            if (!masterKeyElement.classList.contains('masked')) {
                                masterKeyElement.classList.add('masked');
                                // toggleMasterKeyBtn.textContent = 'Show'; // Removed with Security section
                            }
                        }, 30000);
                    }
                } else {
                    masterKeyElement.classList.add('masked');
                    // toggleMasterKeyBtn.textContent = 'Show'; // Removed with Security section
                }
            }
            */ // End of removed toggleMasterKey function
            
            // Convert hex private key to WIF format for importprivkey compatibility
            function hexToWIF(hexPrivateKey) {
                // Version byte for mainnet private key
                const versionByte = "80";
                
                // Add version byte
                let extendedKey = versionByte + hexPrivateKey;
                
                // Add compression flag (optional - for compressed keys)
                const compressionFlag = "01";
                extendedKey = extendedKey + compressionFlag;
                
                // Calculate SHA-256 hash
                const firstSHA = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(extendedKey));
                
                // Calculate SHA-256 hash again
                const secondSHA = CryptoJS.SHA256(firstSHA);
                
                // Get checksum (first 4 bytes of double-SHA)
                const checksum = secondSHA.toString().substring(0, 8);
                
                // Append checksum to extended key
                const keyWithChecksum = extendedKey + checksum;
                
                // Convert to Base58
                // We need to convert hex to bytes first
                const bytes = [];
                for (let i = 0; i < keyWithChecksum.length; i += 2) {
                    bytes.push(parseInt(keyWithChecksum.substr(i, 2), 16));
                }
                
                // Base58 encoding
                const ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
                
                // Count leading zeros
                let zeros = 0;
                for (let i = 0; i < bytes.length && bytes[i] === 0; i++) {
                    zeros++;
                }
                
                // Convert to base58
                let val = BigInt(0);
                for (let i = 0; i < bytes.length; i++) {
                    val = val * BigInt(256) + BigInt(bytes[i]);
                }
                
                let result = '';
                while (val > 0) {
                    const remainder = Number(val % BigInt(58));
                    val = val / BigInt(58);
                    result = ALPHABET[remainder] + result;
                }
                
                // Add leading '1's for each leading zero byte
                for (let i = 0; i < zeros; i++) {
                    result = '1' + result;
                }
                
                return result;
            }
            
            // Make hexToWIF globally accessible
            window.hexToWIF = hexToWIF;

            // Download wallet info (replaced by saveWallet)
            /* function downloadWallet() {
                // Convert the master key to WIF format
                const masterKeyWIF = hexToWIF(wallet.masterPrivateKey);
                
                // Get addresses info
                const addressesText = wallet.addresses.map(a => 
                    `Address ${a.index + 1}: ${a.address} (Path: ${a.path})`
                ).join('\n');
                
                // Determine what to include based on encryption status
                let masterKeySection;
                
                if (wallet.isEncrypted) {
                    masterKeySection = 
`ENCRYPTED MASTER KEY (password protected):
${wallet.encryptedMasterKey}

ENCRYPTION STATUS: Encrypted with password
To use this key, you will need the password you set in the wallet.`;
                } else {
                    masterKeySection = 
`MASTER PRIVATE KEY (keep secret!):
${wallet.masterPrivateKey}

MASTER PRIVATE KEY IN WIF FORMAT (for importprivkey command):
${masterKeyWIF}

${wallet.isImportedAlphaWallet && wallet.masterChainCode ? `MASTER CHAIN CODE (for BIP32 HD wallet compatibility):
${wallet.masterChainCode}

WALLET TYPE: BIP32 hierarchical deterministic wallet` : 'WALLET TYPE: Standard wallet (HMAC-based)'}

ENCRYPTION STATUS: Not encrypted
This key is in plaintext and not protected. Anyone with this file can access your wallet.`;
                }
                
                const content = 
`UNICITY WALLET DETAILS
===========================

${masterKeySection}

YOUR ADDRESSES:
${addressesText}

Generated on: ${new Date().toLocaleString()}

WARNING: Keep your master private key safe and secure.
Anyone with your master private key can access all your funds.`;
                
                const blob = new Blob([content], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = 'alpha-wallet.txt';
                document.body.appendChild(a);
                a.click();
                
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
                
                showInAppNotification('Wallet Backed Up', 'Wallet backup file has been downloaded', 'success');
            } */
            
            // Check password strength
            function checkPasswordStrength(password) {
                let strength = 0;
                
                if (password.length >= 8) strength += 1;
                if (password.length >= 12) strength += 1;
                if (/[A-Z]/.test(password)) strength += 1;
                if (/[a-z]/.test(password)) strength += 1;
                if (/[0-9]/.test(password)) strength += 1;
                if (/[^A-Za-z0-9]/.test(password)) strength += 1;
                
                let strengthText = '';
                let color = '';
                let strengthBar = '';
                
                if (strength < 3) {
                    strengthText = 'Weak';
                    color = 'var(--danger-color)';
                    strengthBar = '<div style="width: 30%; background-color: var(--danger-color);"></div>';
                } else if (strength < 5) {
                    strengthText = 'Medium';
                    color = 'var(--accent-color)';
                    strengthBar = '<div style="width: 60%; background-color: var(--accent-color);"></div>';
                } else {
                    strengthText = 'Strong';
                    color = 'var(--success-color)';
                    strengthBar = '<div style="width: 100%; background-color: var(--success-color);"></div>';
                }
                
                // Visual password strength meter
                const meterHTML = `
                    <div style="margin-top: 10px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                            <span style="color: ${color}; font-weight: 600;">Password Strength: ${strengthText}</span>
                            <span style="font-size: 12px; color: #666;">${strength}/6 criteria met</span>
                        </div>
                        <div style="height: 6px; background-color: #e9e9e9; border-radius: 3px; overflow: hidden;">
                            ${strengthBar}
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-top: 8px; font-size: 12px; color: #666;">
                            <span>Weak</span>
                            <span>Medium</span>
                            <span>Strong</span>
                        </div>
                    </div>
                `;
                
                passwordStrength.innerHTML = meterHTML;
            }
            
            // Encrypt wallet with password (replaced by saveWallet)
            /* function encryptWallet(password) {
                if (!password) {
                    alert('Please enter a password');
                    return;
                }
                
                if (!wallet.masterPrivateKey) {
                    alert('Please initialize a wallet first');
                    return;
                }
                
                try {
                    // Generate a key from the password
                    const salt = "alpha_wallet_salt"; // In a real app, use a random salt and store it
                    const passwordKey = CryptoJS.PBKDF2(password, salt, { keySize: 256/32, iterations: 100000 }).toString();
                    
                    // Encrypt the master private key
                    const encryptedKey = CryptoJS.AES.encrypt(wallet.masterPrivateKey, passwordKey).toString();
                    
                    // Update wallet object
                    wallet.encryptedMasterKey = encryptedKey;
                    wallet.isEncrypted = true;
                    
                    // Save to local storage
                    saveWalletData();
                    
                    // Update UI
                    // encryptionStatus.style.display = 'block'; // Removed with Security section
                    // Clear password strength indicator when wallet is encrypted
                    if (passwordStrength) {
                        passwordStrength.innerHTML = '';
                    }
                    
                    showInAppNotification('Wallet Encrypted', 'Your private key is now protected by your password', 'success');
                } catch (e) {
                    console.error("Error encrypting wallet", e);
                    showInAppNotification('Encryption Error', e.message, 'error');
                }
            } */
            
            // Reset wallet
            function deleteWallet() {
                if (!wallet.masterPrivateKey) {
                    alert('No wallet to reset');
                    return;
                }
                
                const confirmation = confirm('WARNING: You are about to reset your wallet. This will clear the current wallet from your browser. Make sure you have saved your wallet data before proceeding.\n\nAre you sure you want to reset your wallet?');
                
                if (confirmation) {
                    // Clear wallet data
                    wallet = {
                        masterPrivateKey: '',
                        addresses: [],
                        isEncrypted: false,
                        encryptedMasterKey: '',
                        childPrivateKey: null
                    };
                    
                    // Update global reference
                    window.walletGlobal = wallet;
                    
                    // Clear UI for both key displays
                    // masterKeyElement.textContent = 'Generate a wallet to see your private key'; // Removed with Security section
                    // masterKeyElement.classList.add('masked'); // Removed with Security section
                    
                    // const wifKeyElement = document.getElementById('wifMasterKey'); // Removed with Security section
                    // wifKeyElement.textContent = 'Generate a wallet to see your private key'; // Removed with Security section
                    // wifKeyElement.classList.add('masked'); // Removed with Security section
                    
                    // Hide wallet info and QR code
                    walletInfo.style.display = 'none';
                    walletQrCode.style.display = 'none';
                    
                    // Clear transaction history and UTXOs
                    currentTransactions = [];
                    currentUtxos = [];
                    offlineUtxoData = null;
                    // Reset pagination
                    currentTransactionPage = 1;
                    currentUtxoPage = 1;
                    updateTransactionHistory();
                    updateCommonBalance();
                    updateUtxoListDisplay();
                    document.getElementById('transactionHistoryContainer').style.display = 'none';
                    
                    // Reset button text for toggle buttons
                    // toggleMasterKeyBtn.textContent = 'Show'; // Removed with Security section
                    // toggleWifKeyBtn.textContent = 'Show'; // Removed with Security section
                    
                    // Update all button states
                    updateButtonStates(false);
                    
                    // Hide encryption status message
                    // encryptionStatus.style.display = 'none'; // Removed with Security section
                    
                    // Clear password strength indicator
                    passwordStrength.innerHTML = '';
                    
                    
                    // Close all open sections
                    // document.getElementById('keys-section').style.display = 'none'; // Removed with Security section
                    
                    // Reset toggle buttons text
                    // document.getElementById('showEncryptionBtn').innerHTML = ` // Removed with Security section
                        /* <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                            <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                            <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
                        </svg>
                        Encrypt Wallet`; */
                        
                    // document.getElementById('showRestoreBtn').innerHTML = ` // Removed with Security section
                        /* <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="17 8 12 3 7 8"></polyline>
                            <line x1="12" y1="3" x2="12" y2="15"></line>
                        </svg>
                        Restore Wallet`; */
                        
                    // document.getElementById('showAdvancedBtn').innerHTML = ` // Removed with Security section
                        /* <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                            <path d="M12 20h9"></path>
                            <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>
                        </svg>
                        Migrate Wallet`; */
                    
                    try {
                        // Remove from IndexedDB
                        const request = indexedDB.open("AlphaWalletDB", 1);
                        
                        request.onsuccess = function(event) {
                            const db = event.target.result;
                            const transaction = db.transaction(['wallet'], 'readwrite');
                            const store = transaction.objectStore('wallet');
                            store.delete('main-wallet');
                        };
                        
                        // Also remove from localStorage as fallback
                        localStorage.removeItem('alphaWallet');
                    } catch (e) {
                        console.error("Error removing wallet data", e);
                        // Fallback to just localStorage
                        localStorage.removeItem('alphaWallet');
                    }
                    
                    // Clear cached scan data
                    if (lastScannedWalletData && lastScannedWalletData.masterKey) {
                        const fingerprint = generateWalletFingerprint(
                            lastScannedWalletData.masterKey,
                            lastScannedWalletData.masterChainCode
                        );
                        if (fingerprint) {
                            const cacheKey = `walletScanCache_${fingerprint}`;
                            localStorage.removeItem(cacheKey);
                        }
                    }
                    
                    // Clear scan data from memory
                    lastScannedWalletData = null;
                    updateScannedWalletsDisplay(); // This will hide the total balance display
                    
                    // Clear lazy scan interval if running
                    if (lazyScanInterval) {
                        clearInterval(lazyScanInterval);
                        lazyScanInterval = null;
                    }
                    
                    // Also hide loading indicator
                    document.getElementById('totalScannedLoading').style.display = 'none';
                    
                    showInAppNotification('Wallet Reset', 'Your wallet has been reset successfully', 'success');
                }
            }
            
            // Bech32 implementation for segwit addresses (following BIP-173 standard)
            function createBech32(hrp, witnessVersion, data) {
                // BIP-173 constraints:
                // 1. Witness version must be between 0 and 16
                if (witnessVersion < 0 || witnessVersion > 16) {
                    throw new Error('Invalid witness version');
                }
                
                // 2. For version 0, program length must be 20 or 32 bytes
                if (witnessVersion === 0 && data.length !== 20 && data.length !== 32) {
                    console.warn(`Warning: For witness version 0, program length should be 20 or 32 bytes, but got ${data.length} bytes`);
                }
                
                // 3. For version 1-16, program length must be 2-40 bytes
                if (witnessVersion > 0 && (data.length < 2 || data.length > 40)) {
                    throw new Error(`Invalid program length for witness version ${witnessVersion}`);
                }
                
                // 4. Convert 8-bit program data to 5-bit values according to BIP-173
                const data5bit = convertBits(Array.from(data), 8, 5, true);
                
                // 5. The final data to encode starts with the witness version
                const values = [witnessVersion].concat(data5bit);
                
                // 6. Calculate checksum according to BIP-173
                const checksum = bech32Checksum(hrp, values);
                const combined = values.concat(checksum);
                
                // 7. Encode as per BIP-173: hrp + '1' + data + checksum
                let result = hrp + '1';
                for (let i = 0; i < combined.length; i++) {
                    result += CHARSET.charAt(combined[i]);
                }
                
                return result;
            }
            
            // Convert between bit sizes
            function convertBits(data, fromBits, toBits, pad) {
                let acc = 0;
                let bits = 0;
                const ret = [];
                const maxv = (1 << toBits) - 1;
                
                for (let i = 0; i < data.length; i++) {
                    const value = data[i];
                    acc = (acc << fromBits) | value;
                    bits += fromBits;
                    
                    while (bits >= toBits) {
                        bits -= toBits;
                        ret.push((acc >> bits) & maxv);
                    }
                }
                
                if (pad && bits > 0) {
                    ret.push((acc << (toBits - bits)) & maxv);
                }
                
                return ret;
            }
            
            // Generate Bech32 checksum
            function bech32Checksum(hrp, data) {
                const values = hrpExpand(hrp).concat(data).concat([0, 0, 0, 0, 0, 0]);
                const polymod = bech32Polymod(values) ^ 1;
                const result = [];
                for (let i = 0; i < 6; i++) {
                    result.push((polymod >> 5 * (5 - i)) & 31);
                }
                return result;
            }
            
            // Expand the HRP into values for checksum computation
            function hrpExpand(hrp) {
                const result = [];
                for (let i = 0; i < hrp.length; i++) {
                    result.push(hrp.charCodeAt(i) >> 5);
                }
                result.push(0);
                for (let i = 0; i < hrp.length; i++) {
                    result.push(hrp.charCodeAt(i) & 31);
                }
                return result;
            }
            
            // Bech32 checksum computation
            function bech32Polymod(values) {
                const GENERATOR = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];
                let chk = 1;
                for (let i = 0; i < values.length; i++) {
                    const top = chk >> 25;
                    chk = (chk & 0x1ffffff) << 5 ^ values[i];
                    for (let j = 0; j < 5; j++) {
                        if ((top >> j) & 1) {
                            chk ^= GENERATOR[j];
                        }
                    }
                }
                return chk;
            }
            
            // Helper function to convert bytes to hex string
            function bytesToHex(bytes) {
                return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
            }
            
            // Helper function to convert hex to byte array
            function hexToBytes(hex) {
                const bytes = [];
                for (let i = 0; i < hex.length; i += 2) {
                    bytes.push(parseInt(hex.substring(i, i + 2), 16));
                }
                return new Uint8Array(bytes);
            }
            
            // Base58 decode function for decoding extended keys
            function base58Decode(str) {
                const ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
                const ALPHABET_MAP = {};
                for (let i = 0; i < ALPHABET.length; i++) {
                    ALPHABET_MAP[ALPHABET[i]] = i;
                }
                
                // Count leading zeros (represented as '1' in base58)
                let zeros = 0;
                for (let i = 0; i < str.length && str[i] === '1'; i++) {
                    zeros++;
                }
                
                // Decode from base58 to number
                let num = BigInt(0);
                for (let i = 0; i < str.length; i++) {
                    const char = str[i];
                    if (!(char in ALPHABET_MAP)) {
                        throw new Error('Invalid base58 character: ' + char);
                    }
                    num = num * BigInt(58) + BigInt(ALPHABET_MAP[char]);
                }
                
                // Convert to bytes
                const bytes = [];
                while (num > 0) {
                    bytes.unshift(Number(num % BigInt(256)));
                    num = num / BigInt(256);
                }
                
                // Add leading zeros
                for (let i = 0; i < zeros; i++) {
                    bytes.unshift(0);
                }
                
                return new Uint8Array(bytes);
            }
            
            // Restore Modal Elements
            const restoreModal = document.getElementById('restoreModal');
            const restoreFileInput = document.getElementById('restoreFileInput');
            const restorePasswordInput = document.getElementById('restorePasswordInput');
            const restoreModalCancelBtn = document.getElementById('restoreModalCancelBtn');
            const restoreModalSubmitBtn = document.getElementById('restoreModalSubmitBtn');
            const restoreStatus = document.getElementById('restoreStatus');
            const scanWalletsBtn = document.getElementById('scanWalletsBtn');
            const walletScanOptions = document.getElementById('walletScanOptions');
            const walletScanResults = document.getElementById('walletScanResults');
            const scanCountInput = document.getElementById('scanCountInput');
            const scanOnlineCheckbox = document.getElementById('scanOnlineCheckbox');
            const foundWalletsList = document.getElementById('foundWalletsList');
            const scanProgress = document.getElementById('scanProgress');
            const scanStatus = document.getElementById('scanStatus');
            const scanCounter = document.getElementById('scanCounter');
            
            function showRestoreModal() {
                restoreModal.style.display = 'flex';
                document.body.style.overflow = 'hidden';
                restoreFileInput.value = '';
                restorePasswordInput.value = '';
                restoreStatus.style.display = 'none';
                walletScanOptions.style.display = 'none';
                walletScanResults.style.display = 'none';
                scanWalletsBtn.style.display = 'none';
                restoreModalSubmitBtn.style.display = 'inline-block';
            }
            
            function closeRestoreModal() {
                restoreModal.style.display = 'none';
                document.body.style.overflow = '';
            }
            
            
            // Helper function to read binary data
            function readBinaryFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = e => resolve(new Uint8Array(e.target.result));
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(file);
                });
            }
            
            // Helper function to find pattern in Uint8Array
            function findPattern(data, pattern, startIndex = 0) {
                for (let i = startIndex; i <= data.length - pattern.length; i++) {
                    let found = true;
                    for (let j = 0; j < pattern.length; j++) {
                        if (data[i + j] !== pattern[j]) {
                            found = false;
                            break;
                        }
                    }
                    if (found) return i;
                }
                return -1;
            }

            // Parse DER-encoded EC private key
            function parseDERPrivateKey(derData) {
                // DER structure for EC private key:
                // SEQUENCE {
                //   version INTEGER (1)
                //   privateKey OCTET STRING (32 bytes)
                //   parameters [0] (optional)
                //   publicKey [1] (optional)
                // }
                
                let offset = 0;
                
                // Check SEQUENCE tag (0x30)
                if (derData[offset] !== 0x30) return null;
                offset++;
                
                // Skip length
                if (derData[offset] & 0x80) {
                    const lengthBytes = derData[offset] & 0x7f;
                    offset += lengthBytes + 1;
                } else {
                    offset++;
                }
                
                // Check version (0x02 0x01 0x01)
                if (derData[offset] === 0x02 && derData[offset+1] === 0x01 && derData[offset+2] === 0x01) {
                    offset += 3;
                }
                
                // Find OCTET STRING (0x04) containing private key
                while (offset < derData.length - 33) {
                    if (derData[offset] === 0x04 && derData[offset+1] === 0x20) {
                        // Found 32-byte octet string
                        return derData.slice(offset + 2, offset + 34);
                    }
                    offset++;
                }
                
                return null;
            }

            // Enhanced SQLite parser for wallet.dat files
            async function restoreFromWalletDat(file) {
                try {
                    restoreStatus.className = 'info-box info';
                    restoreStatus.textContent = 'Reading BIP32 wallet.dat file...';
                    restoreStatus.style.display = 'block';
                    
                    const data = await readBinaryFile(file);
                    
                    // Check SQLite header
                    const header = new TextDecoder().decode(data.slice(0, 16));
                    if (!header.startsWith('SQLite format 3')) {
                        throw new Error('Invalid wallet.dat file - not an SQLite database');
                    }
                    
                    restoreStatus.textContent = 'Analyzing wallet structure...';
                    
                    // Look for different wallet record types
                    const walletInfo = {
                        descriptorKeys: [],
                        hdChain: null,
                        legacyKeys: [],
                        isDescriptorWallet: false
                    };
                    
                    // Pattern 1: Search for walletdescriptorkey records (modern descriptor wallets)
                    const descriptorKeyPattern = new TextEncoder().encode('walletdescriptorkey');
                    
                    let index = 0;
                    while ((index = findPattern(data, descriptorKeyPattern, index)) !== -1) {
                        walletInfo.isDescriptorWallet = true;
                        
                        // Search for DER-encoded private key directly after walletdescriptorkey
                        // Based on our analysis, the key can be up to 200 bytes after the pattern
                        let privKeyFound = false;
                        for (let checkPos = index + descriptorKeyPattern.length; 
                             checkPos < Math.min(index + descriptorKeyPattern.length + 200, data.length - 40); 
                             checkPos++) {
                            
                            // Look for DER sequence markers
                            // Pattern: d30201010420 (the pattern that actually works)
                            if (data[checkPos] === 0xd3 &&
                                data[checkPos + 1] === 0x02 &&
                                data[checkPos + 2] === 0x01 &&
                                data[checkPos + 3] === 0x01 &&
                                data[checkPos + 4] === 0x04 &&
                                data[checkPos + 5] === 0x20) {
                                
                                // Extract the 32-byte private key
                                const privKey = data.slice(checkPos + 6, checkPos + 38);
                                const privKeyHex = Array.from(privKey).map(b => b.toString(16).padStart(2, '0')).join('');
                                
                                if (isValidPrivateKey(privKeyHex)) {
                                    walletInfo.descriptorKeys.push(privKeyHex);
                                    privKeyFound = true;
                                    break;
                                }
                            }
                        }
                        
                        index++;
                    }
                    
                    // Pattern 2: Search for hdchain records (legacy HD wallets)
                    const hdChainPattern = new TextEncoder().encode('hdchain');
                    index = findPattern(data, hdChainPattern);
                    if (index !== -1) {
                        walletInfo.hdChain = true;
                    }
                    
                    // Pattern 3: Search for regular key records (legacy format)
                    const keyPattern = new TextEncoder().encode('key');
                    index = 0;
                    while ((index = findPattern(data, keyPattern, index)) !== -1) {
                        // Extract private key using simple pattern search
                        const searchPattern = new Uint8Array([0x04, 0x20]); // DER encoding for 32-byte octet string
                        for (let i = index; i < Math.min(index + 200, data.length - 34); i++) {
                            if (data[i] === searchPattern[0] && data[i + 1] === searchPattern[1]) {
                                const privKey = data.slice(i + 2, i + 34);
                                const privKeyHex = Array.from(privKey).map(b => b.toString(16).padStart(2, '0')).join('');
                                
                                if (isValidPrivateKey(privKeyHex)) {
                                    walletInfo.legacyKeys.push(privKeyHex);
                                    break;
                                }
                            }
                        }
                        index++;
                    }
                    
                    // Determine what we found
                    let masterKey = null;
                    let importType = '';
                    
                    if (walletInfo.isDescriptorWallet && walletInfo.descriptorKeys.length > 0) {
                        // Modern descriptor wallet
                        masterKey = walletInfo.descriptorKeys[0]; // Use first key found
                        importType = 'descriptor wallet';
                        restoreStatus.textContent = `Found ${walletInfo.descriptorKeys.length} key(s) in descriptor wallet...`;
                    } else if (walletInfo.legacyKeys.length > 0) {
                        // Legacy wallet with individual keys
                        masterKey = walletInfo.legacyKeys[0]; // Use first key found
                        importType = walletInfo.hdChain ? 'HD wallet' : 'legacy wallet';
                        restoreStatus.textContent = `Found ${walletInfo.legacyKeys.length} key(s) in ${importType}...`;
                    } else {
                        throw new Error('No valid private keys found in wallet.dat file. The wallet might be encrypted or use an unsupported format.');
                    }
                    
                    // Confirmation before overwriting
                    if (wallet.masterPrivateKey) {
                        const confirmOverwrite = confirm(
                            `Found Alpha ${importType} with private key(s).\n\n` +
                            `This will overwrite your existing wallet. Are you sure you want to proceed?`
                        );
                        if (!confirmOverwrite) {
                            closeRestoreModal();
                            return;
                        }
                    }
                    
                    // Create wallet with the extracted key
                    wallet = {
                        masterPrivateKey: masterKey,
                        addresses: [],
                        isEncrypted: false,
                        encryptedMasterKey: null,
                        childPrivateKey: null,
                        isImportedAlphaWallet: true, // Mark as imported from Alpha wallet.dat
                        // For BIP32 HD wallets, we need the chain code
                        // This will be extracted from the wallet.dat file
                        masterChainCode: result.masterChainCode
                    };
                    
                    // Update global reference
                    window.walletGlobal = wallet;
                    
                    // Generate first address
                    generateNewAddress();
                    
                    // Save the wallet
                    saveWalletData();
                    
                    // Update UI - populate address list
                    if (wallet.addresses.length > 0) {
                        const addressList = document.getElementById('addressList');
                        if (addressList) {
                            addressList.innerHTML = ''; // Clear existing
                            wallet.addresses.forEach(addr => {
                                addAddressToUI(addr);
                            });
                        }
                    }
                    
                    // Update button states
                    updateButtonStates(true);
                    
                    restoreStatus.className = 'info-box success';
                    restoreStatus.innerHTML = `
                        <div>Wallet imported successfully from Alpha ${importType}!</div>
                        <div style="margin-top: 10px; font-size: 0.9em;">
                            <strong>Note:</strong> The imported master key has been recovered. 
                            The first address generated may differ from your original wallet's addresses 
                            due to derivation path differences. You can still use this wallet to manage funds.
                        </div>
                    `;
                    
                    // Close modal after 4 seconds (longer to read the note)
                    setTimeout(() => {
                        closeRestoreModal();
                    }, 4000);
                    
                } catch (error) {
                    restoreStatus.className = 'info-box error';
                    restoreStatus.textContent = 'Error importing wallet.dat: ' + error.message;
                    restoreStatus.style.display = 'block';
                }
            }
            
            // Validate if a hex string is a valid secp256k1 private key
            function isValidPrivateKey(hex) {
                try {
                    const n = BigInt('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141');
                    const key = BigInt('0x' + hex);
                    return key > 0n && key < n;
                } catch {
                    return false;
                }
            }
            
            // Derive address at specific index from master key
            function deriveAddressAtIndex(masterKey, masterChainCode, index, isAlphaWallet = true, isChange = false) {
                const ec = new elliptic.ec('secp256k1');
                let childPrivateKey;
                let derivationPath;
                
                if (isAlphaWallet && masterChainCode) {
                    // BIP32 derivation for Alpha wallets
                    let key = masterKey;
                    let chainCode = masterChainCode;
                    
                    // m/84'/1'/0'/chain/index
                    // where chain = 0 for external (receiving), 1 for internal (change)
                    let result = deriveKeyBIP32(key, chainCode, 84, true);
                    key = result.key;
                    chainCode = result.chainCode;
                    
                    result = deriveKeyBIP32(key, chainCode, 1, true);
                    key = result.key;
                    chainCode = result.chainCode;
                    
                    result = deriveKeyBIP32(key, chainCode, 0, true);
                    key = result.key;
                    chainCode = result.chainCode;
                    
                    result = deriveKeyBIP32(key, chainCode, isChange ? 1 : 0, false);
                    key = result.key;
                    chainCode = result.chainCode;
                    
                    result = deriveKeyBIP32(key, chainCode, index, false);
                    childPrivateKey = result.key;
                    derivationPath = `m/84'/1'/0'/${isChange ? 1 : 0}/${index}`;
                } else {
                    // HMAC-based derivation
                    derivationPath = `m/44'/0'/${index}'`;
                    const hmacInput = CryptoJS.enc.Hex.parse(masterKey);
                    const hmacKey = CryptoJS.enc.Utf8.parse(derivationPath);
                    const hmacOutput = CryptoJS.HmacSHA512(hmacInput, hmacKey).toString();
                    childPrivateKey = hmacOutput.substring(0, 64);
                }
                
                const keyPair = ec.keyFromPrivate(childPrivateKey);
                const publicKey = keyPair.getPublic(true, 'hex');
                
                // Create SegWit address
                const publicKeyBytes = hexToBytes(publicKey);
                const sha256Hash = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(publicKey)).toString();
                const ripemd160Hash = CryptoJS.RIPEMD160(CryptoJS.enc.Hex.parse(sha256Hash)).toString();
                const address = createBech32('alpha', 0, hexToBytes(ripemd160Hash));
                
                return {
                    index: index,
                    address: address,
                    publicKey: publicKey,
                    privateKey: childPrivateKey,
                    path: derivationPath,
                    balance: 0,
                    utxos: []
                };
            }
            
            // Check balance for an address using Fulcrum
            async function checkAddressBalance(address) {
                if (!electrumConnected) {
                    return { balance: 0, utxoCount: 0 };
                }
                
                try {
                    const scriptHash = addressToScriptHash(address);
                    if (!scriptHash) {
                        console.error('Failed to convert address to script hash:', address);
                        return { balance: 0, utxoCount: 0 };
                    }
                    
                    // Use get_balance which is more efficient than listing all UTXOs
                    const response = await new Promise((resolve, reject) => {
                        electrumRequest('blockchain.scripthash.get_balance', [scriptHash], function(result, error) {
                            if (error) {
                                reject(error);
                            } else {
                                resolve(result);
                            }
                        });
                    });
                    
                    if (!response) {
                        return { balance: 0, utxoCount: 0 };
                    }
                    
                    // get_balance returns {confirmed: number, unconfirmed: number}
                    const confirmed = response.confirmed || 0;
                    const unconfirmed = response.unconfirmed || 0;
                    const totalBalance = confirmed + unconfirmed;
                    
                    
                    return { balance: totalBalance, utxoCount: -1 }; // -1 indicates we didn't fetch UTXO count
                } catch (error) {
                    console.error('Error checking address balance:', error);
                    return { balance: 0, utxoCount: 0 };
                }
            }
            
            // Global variables for scanning
            let scanningActive = false;
            let scannedWallets = [];
            let extractedWalletData = null;
            let lastScannedWalletData = null; // Store scan results persistently
            let lazyScanInterval = null;
            let lastLazyScanTime = 0;
            let currentScanProgress = 0; // Track current scan progress percentage
            let totalScansCount = 0; // Track total number of scans
            
            // Save scan results to local storage
            function saveScanResultsToCache(walletFingerprint, scanData) {
                try {
                    const cacheKey = `walletScanCache_${walletFingerprint}`;
                    const cacheData = {
                        timestamp: Date.now(),
                        wallets: scanData.wallets,
                        totalBalance: scanData.totalBalance,
                        scanCount: scanData.wallets.length
                    };
                    localStorage.setItem(cacheKey, JSON.stringify(cacheData));
                } catch (e) {
                    console.error('Failed to save scan results to cache:', e);
                }
            }
            
            // Load scan results from cache
            function loadScanResultsFromCache(walletFingerprint) {
                try {
                    const cacheKey = `walletScanCache_${walletFingerprint}`;
                    const cached = localStorage.getItem(cacheKey);
                    if (cached) {
                        const data = JSON.parse(cached);
                        // Check if cache is not too old (7 days)
                        if (Date.now() - data.timestamp < 7 * 24 * 60 * 60 * 1000) {
                            return data;
                        }
                    }
                } catch (e) {
                    console.error('Failed to load scan results from cache:', e);
                }
                return null;
            }
            
            // Generate fingerprint for wallet
            function generateWalletFingerprint(masterKey, masterChainCode) {
                if (!masterKey) {
                    return null;
                }
                // Use first 8 chars of master key as fingerprint
                return masterKey.substring(0, 8);
            }
            
            // Start wallet scan with decrypted data
            async function startWalletScanWithDecryptedData(walletData) {
                try {
                    const masterKey = walletData.masterPrivateKey;
                    const masterChainCode = walletData.masterChainCode || null;
                    const isAlphaWallet = walletData.isImportedAlphaWallet || false;
                    
                    if (!masterKey) {
                        throw new Error('No master key found in decrypted wallet data');
                    }
                    
                    // Continue with normal scanning
                    performWalletScan(masterKey, masterChainCode, isAlphaWallet);
                } catch (error) {
                    restoreStatus.className = 'info-box error';
                    restoreStatus.textContent = 'Error: ' + error.message;
                    restoreStatus.style.display = 'block';
                }
            }
            
            // Start wallet scanning or decrypt
            async function startWalletScan() {
                const file = restoreFileInput.files[0];
                if (!file) {
                    alert('Please select a file first');
                    return;
                }
                
                // Check if this is a rescan - clear cache if so
                if (scanWalletsBtn.textContent === 'Rescan Wallets') {
                    // Clear all cached scan results from localStorage
                    const keysToRemove = [];
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key && (key.startsWith('walletScan_') || key === 'lastScannedWalletData' || key === 'lastLazyScanTime')) {
                            keysToRemove.push(key);
                        }
                    }
                    
                    // Remove all scan-related keys
                    keysToRemove.forEach(key => {
                        localStorage.removeItem(key);
                        console.log('Cleared cached data:', key);
                    });
                    
                    // Clear in-memory data
                    lastScannedWalletData = null;
                    scannedWallets = [];
                    
                    // Update UI to show we're doing a fresh scan
                    restoreStatus.className = 'info-box info';
                    restoreStatus.textContent = 'Cache cleared. Starting fresh wallet scan...';
                    restoreStatus.style.display = 'block';
                }
                
                // Check if we're in decrypt mode
                if (scanWalletsBtn.textContent === 'Decrypt') {
                    // Handle encrypted wallet decryption
                    const password = restorePasswordInput.value;
                    if (!password) {
                        restoreStatus.className = 'info-box error';
                        restoreStatus.textContent = 'Please enter the decryption password.';
                        restoreStatus.style.display = 'block';
                        return;
                    }
                    
                    try {
                        const fileContent = await file.text();
                        
                        // Check if it's the old format with ENCRYPTED MASTER KEY
                        if (fileContent.includes('ENCRYPTED MASTER KEY')) {
                            // Handle old format
                            const encryptedKeyMatch = fileContent.match(/ENCRYPTED MASTER KEY \(password protected\):\s*([^\n]+)/);
                            
                            if (!encryptedKeyMatch || !encryptedKeyMatch[1]) {
                                throw new Error('Invalid encrypted wallet format');
                            }
                            
                            const encryptedMasterKey = encryptedKeyMatch[1].trim();
                            
                            // Decrypt using PBKDF2 (old method)
                            try {
                                const salt = "alpha_wallet_salt";
                                const passwordKey = CryptoJS.PBKDF2(password, salt, { keySize: 256/32, iterations: 100000 }).toString();
                                
                                const decryptedBytes = CryptoJS.AES.decrypt(encryptedMasterKey, passwordKey);
                                const decryptedMasterKey = decryptedBytes.toString(CryptoJS.enc.Utf8);
                                
                                if (!decryptedMasterKey) {
                                    throw new Error('Incorrect password or corrupted wallet file');
                                }
                                
                                // Parse addresses from the file
                                const addressMatches = fileContent.match(/Address \d+: (alpha1[a-z0-9]{38,})/g);
                                const addresses = addressMatches ? addressMatches.map((match, index) => {
                                    const addrMatch = match.match(/Address \d+: (alpha1[a-z0-9]{38,})/);
                                    return {
                                        index: index,
                                        address: addrMatch ? addrMatch[1] : null
                                    };
                                }).filter(a => a.address) : [];
                                
                                // Check if this is a BIP32 wallet by looking for chain code
                                const chainCodeMatch = fileContent.match(/MASTER CHAIN CODE \(for Alpha wallet compatibility\):\s*([^\n]+)/);
                                const isAlphaWallet = chainCodeMatch && chainCodeMatch[1] && fileContent.includes('WALLET TYPE: Alpha descriptor wallet');
                                
                                // Create wallet data in the expected format
                                const walletData = {
                                    masterPrivateKey: decryptedMasterKey,
                                    masterChainCode: chainCodeMatch ? chainCodeMatch[1].trim() : null,
                                    isImportedAlphaWallet: isAlphaWallet,
                                    addresses: addresses,
                                    isEncrypted: false,
                                    encryptedMasterKey: ''
                                };
                            
                                // Successfully decrypted - update UI
                                restoreStatus.className = 'info-box success';
                                restoreStatus.textContent = 'Wallet decrypted successfully. Starting wallet scan...';
                                restoreStatus.style.display = 'block';
                                
                                // Change button back to Rescan Wallets
                                scanWalletsBtn.textContent = 'Rescan Wallets';
                                walletScanOptions.style.display = 'block';
                                
                                // Store decrypted data for scanning
                                window.decryptedWalletData = walletData;
                                
                                // Start normal scanning process
                                setTimeout(() => {
                                    startWalletScanWithDecryptedData(walletData);
                                }, 1000);
                                
                                return;
                            } catch (decryptError) {
                                throw new Error('Incorrect password or corrupted wallet file');
                            }
                        } else {
                            // New format handling (if we ever need it)
                            throw new Error('New encrypted format not supported in this version');
                        }
                    } catch (error) {
                        restoreStatus.className = 'info-box error';
                        restoreStatus.textContent = 'Decryption failed: ' + error.message;
                        restoreStatus.style.display = 'block';
                        return;
                    }
                }
                
                // Normal wallet scanning flow
                try {
                    let masterKey = '';
                    let masterChainCode = null;
                    let isAlphaWallet = false;
                    
                    if (file.name.endsWith('.dat')) {
                        // Extract from wallet.dat
                        const result = await extractFromWalletDat(file);
                        masterKey = result.masterKey;
                        masterChainCode = result.masterChainCode;
                        isAlphaWallet = true;
                    } else {
                        // Extract from text backup
                        const fileContent = await file.text();
                        const masterKeyMatch = fileContent.match(/MASTER PRIVATE KEY \(keep secret!\):\s*([^\n]+)/);
                        if (masterKeyMatch) {
                            masterKey = masterKeyMatch[1].trim();
                        }
                        
                        const chainCodeMatch = fileContent.match(/MASTER CHAIN CODE \(for Alpha wallet compatibility\):\s*([^\n]+)/);
                        if (chainCodeMatch) {
                            masterChainCode = chainCodeMatch[1].trim();
                            isAlphaWallet = true;
                        }
                    }
                    
                    if (!masterKey) {
                        throw new Error('Could not extract master key from file');
                    }
                    
                    // Store extracted data
                    extractedWalletData = {
                        masterKey,
                        masterChainCode,
                        isAlphaWallet
                    };
                    
                    console.log('Extracted wallet data:', {
                        masterKey: masterKey,
                        masterChainCode: masterChainCode,
                        isAlphaWallet: isAlphaWallet,
                        keyLength: masterKey ? masterKey.length : 0
                    });
                    
                    // Generate wallet fingerprint
                    const fingerprint = generateWalletFingerprint(masterKey, masterChainCode);
                    
                    // Check for cached results (skip if we just cleared the cache for rescan)
                    const isRescan = scanWalletsBtn.textContent === 'Rescan Wallets';
                    const cachedResults = !isRescan ? loadScanResultsFromCache(fingerprint) : null;
                    if (cachedResults && cachedResults.wallets && cachedResults.wallets.length > 0) {
                        
                        // Use cached results but deduplicate first
                        const uniqueWallets = [];
                        const addressSet = new Set();
                        
                        cachedResults.wallets.forEach(wallet => {
                            if (!addressSet.has(wallet.address)) {
                                addressSet.add(wallet.address);
                                uniqueWallets.push(wallet);
                            } else {
                                console.warn(`Removing duplicate cached address: ${wallet.address}`);
                            }
                        });
                        
                        scannedWallets = uniqueWallets;
                        
                        // Recalculate total balance from deduplicated wallets
                        let recalculatedTotal = 0;
                        uniqueWallets.forEach(wallet => {
                            if (wallet.balance > 0) {
                                recalculatedTotal += wallet.balance;
                            }
                        });
                        
                        lastScannedWalletData = {
                            wallets: uniqueWallets,
                            totalBalance: recalculatedTotal,
                            masterKey: extractedWalletData.masterKey,
                            masterChainCode: extractedWalletData.masterChainCode,
                            isAlphaWallet: extractedWalletData.isAlphaWallet
                        };
                        
                        // Display cached results
                        walletScanResults.style.display = 'block';
                        foundWalletsList.innerHTML = '';
                        uniqueWallets.forEach(wallet => {
                            addWalletToResults(wallet);
                        });
                        
                        // Update status
                        const deduplicationNote = cachedResults.wallets.length !== uniqueWallets.length 
                            ? `<br><em style="font-size: 11px; color: #ff6b6b;">Removed ${cachedResults.wallets.length - uniqueWallets.length} duplicate(s)</em>` 
                            : '';
                        scanStatus.innerHTML = `Found ${uniqueWallets.length} wallet(s) from cache<br>Total balance: <strong>${(recalculatedTotal / 100000000).toFixed(8)} ALPHA</strong>${deduplicationNote}<br><em style="font-size: 11px;">Last scan: ${new Date(cachedResults.timestamp).toLocaleString()}</em>`;
                        scanProgress.style.width = '100%';
                        scanCounter.textContent = `${uniqueWallets.length} cached`;
                        
                        // Update main UI
                        updateScannedWalletsDisplay();
                        
                        // Start lazy rescan in background if online
                        if (electrumConnected) {
                            // Show loading indicator if we'll be doing background scan and have multiple wallets
                            const nonZeroWallets = uniqueWallets.filter(w => w.balance > 0).length;
                            if (nonZeroWallets > 1) {
                                document.getElementById('totalScannedLoading').style.display = 'inline';
                                // Keep balance visible alongside loading
                                document.getElementById('totalScannedBalance').style.display = 'inline';
                            }
                            startLazyRescan();
                        }
                    } else {
                        // No cache, perform full scan
                        await performWalletScan();
                    }
                    
                } catch (error) {
                    restoreStatus.className = 'info-box error';
                    restoreStatus.textContent = 'Error: ' + error.message;
                    restoreStatus.style.display = 'block';
                }
            }
            
            // Extract from wallet.dat file
            async function extractFromWalletDat(file) {
                const data = await readBinaryFile(file);
                
                // Check SQLite header
                const header = new TextDecoder().decode(data.slice(0, 16));
                if (!header.startsWith('SQLite format 3')) {
                    throw new Error('Invalid wallet.dat file - not an SQLite database');
                }
                
                // Look for private keys (same logic as restoreFromWalletDat)
                const descriptorKeyPattern = new TextEncoder().encode('walletdescriptorkey');
                let masterKey = null;
                let foundCount = 0;
                
                let index = 0;
                while ((index = findPattern(data, descriptorKeyPattern, index)) !== -1) {
                    foundCount++;
                    console.log(`Found descriptor key pattern #${foundCount} at position ${index}`);
                    // Skip the pattern and look for public key
                    let offset = index + descriptorKeyPattern.length;
                    
                    // Find compressed public key (33 bytes starting with 0x02 or 0x03)
                    for (let skip = 0; skip < 100 && offset + skip + 33 < data.length; skip++) {
                        const pubKeyCandidate = data.slice(offset + skip, offset + skip + 33);
                        if ((pubKeyCandidate[0] === 0x02 || pubKeyCandidate[0] === 0x03)) {
                            // Look for private key after public key
                            for (let privOffset = 0; privOffset < 20 && offset + skip + 33 + privOffset + 50 < data.length; privOffset++) {
                                const checkPos = offset + skip + 33 + privOffset;
                                
                                // Look for DER sequence markers
                                // Pattern 1: d63081d30201010420 (full DER sequence)
                                if (data[checkPos] === 0xd6 && 
                                    data[checkPos + 1] === 0x30 && 
                                    data[checkPos + 2] === 0x81 && 
                                    data[checkPos + 3] === 0xd3 &&
                                    data[checkPos + 4] === 0x02 &&
                                    data[checkPos + 5] === 0x01 &&
                                    data[checkPos + 6] === 0x01 &&
                                    data[checkPos + 7] === 0x04 &&
                                    data[checkPos + 8] === 0x20) {
                                    
                                    // Extract the 32-byte private key
                                    const privKeyBytes = data.slice(checkPos + 9, checkPos + 41);
                                    const privKeyHex = Array.from(privKeyBytes).map(b => b.toString(16).padStart(2, '0')).join('');
                                    
                                    if (isValidPrivateKey(privKeyHex)) {
                                        masterKey = privKeyHex;
                                        console.log(`Found valid private key (pattern 1): ${privKeyHex}`);
                                        break;
                                    }
                                }
                                
                                // Pattern 2: d30201010420 (shorter DER sequence)
                                if (!masterKey &&
                                    data[checkPos] === 0xd3 &&
                                    data[checkPos + 1] === 0x02 &&
                                    data[checkPos + 2] === 0x01 &&
                                    data[checkPos + 3] === 0x01 &&
                                    data[checkPos + 4] === 0x04 &&
                                    data[checkPos + 5] === 0x20) {
                                    
                                    // Extract the 32-byte private key
                                    const privKeyBytes = data.slice(checkPos + 6, checkPos + 38);
                                    const privKeyHex = Array.from(privKeyBytes).map(b => b.toString(16).padStart(2, '0')).join('');
                                    
                                    if (isValidPrivateKey(privKeyHex)) {
                                        masterKey = privKeyHex;
                                        console.log(`Found valid private key (pattern 2): ${privKeyHex}`);
                                        break;
                                    }
                                }
                                
                                // Alternative: Look for standard DER SEQUENCE (0x30)
                                if (!masterKey && data[checkPos] === 0x30) {
                                    const derData = data.slice(checkPos, Math.min(checkPos + 200, data.length));
                                    const privKey = parseDERPrivateKey(derData);
                                    
                                    if (privKey) {
                                        const privKeyHex = Array.from(privKey).map(b => b.toString(16).padStart(2, '0')).join('');
                                        if (isValidPrivateKey(privKeyHex)) {
                                            masterKey = privKeyHex;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        if (masterKey) break;
                    }
                    if (masterKey) break;
                    index++;
                }
                
                // If no descriptor keys found, try legacy patterns
                if (!masterKey && foundCount === 0) {
                    // Try searching for raw private keys (32 bytes)
                    const keyPattern = new TextEncoder().encode('key');
                    index = 0;
                    while ((index = findPattern(data, keyPattern, index)) !== -1 && !masterKey) {
                        // Look for 32-byte sequences that could be private keys
                        for (let offset = index + keyPattern.length; offset < Math.min(index + 200, data.length - 32); offset++) {
                            const candidate = data.slice(offset, offset + 32);
                            const candidateHex = Array.from(candidate).map(b => b.toString(16).padStart(2, '0')).join('');
                            
                            if (isValidPrivateKey(candidateHex)) {
                                masterKey = candidateHex;
                                break;
                            }
                        }
                        index++;
                    }
                }
                
                if (!masterKey) {
                    if (foundCount === 0) {
                        throw new Error('No wallet descriptor keys found in wallet.dat. This might be a legacy or encrypted wallet.');
                    } else {
                        throw new Error(`Found ${foundCount} descriptor key(s) but could not extract private key. The wallet might be encrypted.`);
                    }
                }
                
                // For Alpha wallets, extract the chain code from xpub
                let masterChainCode = null;
                
                // Look for all xpubs in the wallet data and find the master (depth 0)
                const xpubPattern = new TextEncoder().encode('xpub');
                const base58Chars = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
                let searchPos = 0;
                let foundMasterChainCode = false;
                
                while (!foundMasterChainCode && searchPos < data.length) {
                    let xpubIndex = findPattern(data, xpubPattern, searchPos);
                    if (xpubIndex === -1) break;
                    
                    // Extract the full xpub (approximately 111 characters)
                    let xpubStr = 'xpub';
                    let pos = xpubIndex + 4;
                    
                    while (pos < data.length && xpubStr.length < 120) {
                        const char = String.fromCharCode(data[pos]);
                        if (base58Chars.includes(char)) {
                            xpubStr += char;
                            pos++;
                        } else {
                            break;
                        }
                    }
                    
                    if (xpubStr.length > 100) {
                        try {
                            // Decode the xpub to check depth and extract chain code
                            const decoded = base58Decode(xpubStr);
                            const depth = decoded[4];
                            
                            // We want the master key at depth 0
                            if (depth === 0) {
                                // Chain code is at bytes 13-45 (32 bytes)
                                const chainCodeBytes = decoded.slice(13, 45);
                                masterChainCode = Array.from(chainCodeBytes).map(b => b.toString(16).padStart(2, '0')).join('');
                                console.log('Extracted master chain code from depth 0 xpub:', masterChainCode);
                                foundMasterChainCode = true;
                            } else {
                                console.log('Found xpub at depth', depth, '- skipping, looking for master (depth 0)');
                            }
                        } catch (e) {
                            console.error('Failed to decode xpub:', e);
                        }
                    }
                    
                    searchPos = xpubIndex + 4;
                }
                
                if (!masterChainCode) {
                    console.warn('Could not extract chain code from wallet.dat - BIP32 derivation will not work correctly');
                }
                
                return {
                    masterKey,
                    masterChainCode,
                    isAlphaWallet: true
                };
            }
            
            // Perform the actual scanning
            async function performWalletScan(masterKey, masterChainCode, isAlphaWallet) {
                const scanCount = parseInt(scanCountInput.value) || 100;
                const checkOnline = scanOnlineCheckbox.checked;
                const scanChangeAddrs = document.getElementById('scanChangeAddresses').checked;
                
                // Set extracted wallet data if parameters provided
                if (masterKey) {
                    extractedWalletData = {
                        masterKey: masterKey,
                        masterChainCode: masterChainCode,
                        isAlphaWallet: isAlphaWallet
                    };
                }
                
                scanningActive = true;
                // IMPORTANT: Clear the scannedWallets array to prevent duplicates
                scannedWallets = [];
                walletScanResults.style.display = 'block';
                foundWalletsList.innerHTML = '';
                scanStatus.textContent = 'Scanning...';
                scanProgress.style.width = '0%';
                
                // Initialize scan data structure early
                lastScannedWalletData = {
                    wallets: [],
                    totalBalance: 0,
                    masterKey: extractedWalletData.masterKey,
                    masterChainCode: extractedWalletData.masterChainCode,
                    isAlphaWallet: extractedWalletData.isAlphaWallet
                };
                
                // Reset status text for new scan
                const statusTextEl = document.getElementById('scanStatusText');
                if (statusTextEl) {
                    statusTextEl.innerHTML = 'Scanning wallets <span id="scanPercentage">0%</span>';
                }
                
                // Update display to show loading indicator
                updateScannedWalletsDisplay();
                
                const dustThreshold = 1000; // satoshis
                const totalScans = scanChangeAddrs ? scanCount * 2 : scanCount;
                let scansDone = 0;
                totalScansCount = totalScans; // Store globally
                currentScanProgress = 0; // Reset progress
                
                // Scan external addresses (receiving)
                for (let i = 0; i < scanCount && scanningActive; i++) {
                    // Derive address at index
                    const walletInfo = deriveAddressAtIndex(
                        extractedWalletData.masterKey,
                        extractedWalletData.masterChainCode,
                        i,
                        extractedWalletData.isAlphaWallet,
                        false // external address
                    );
                    
                    // Skip logging each address to reduce clutter
                    
                    // Check balance if online
                    if (checkOnline && electrumConnected) {
                        const balanceInfo = await checkAddressBalance(walletInfo.address);
                        walletInfo.balance = balanceInfo.balance;
                        walletInfo.utxoCount = balanceInfo.utxoCount;
                    }
                    
                    // Add to results if has balance above dust threshold, if offline, or if it's the first address
                    if (!checkOnline || !electrumConnected || walletInfo.balance > dustThreshold || i === 0) {
                        // If offline, show all addresses
                        if (!checkOnline || !electrumConnected) {
                            walletInfo.balance = -1; // Indicate unknown balance
                        }
                        walletInfo.isChange = false;
                        // Check for duplicates before adding
                        const isDuplicate = scannedWallets.some(w => w.address === walletInfo.address);
                        if (!isDuplicate) {
                            scannedWallets.push(walletInfo);
                            addWalletToResults(walletInfo);
                        } else {
                            console.warn(`Skipping duplicate address: ${walletInfo.address}`);
                        }
                        
                        // Update total balance immediately if online and has balance
                        if (checkOnline && electrumConnected && walletInfo.balance > 0) {
                            let runningTotal = 0;
                            scannedWallets.forEach(w => {
                                if (w.balance > 0) runningTotal += w.balance;
                            });
                            
                            // Update status with running total
                            scanStatus.innerHTML = `Scanning... Found ${scannedWallets.length} wallet(s)<br>Current total: <strong>${(runningTotal / 100000000).toFixed(8)} ALPHA</strong>`;
                            
                            // Update lastScannedWalletData with current data
                            lastScannedWalletData = {
                                wallets: [...scannedWallets],
                                totalBalance: runningTotal,
                                masterKey: extractedWalletData.masterKey,
                                masterChainCode: extractedWalletData.masterChainCode,
                                isAlphaWallet: extractedWalletData.isAlphaWallet
                            };
                            
                            // Update display to reflect current scan state
                            updateScannedWalletsDisplay();
                        }
                    }
                    
                    scansDone++;
                    // Update progress
                    const progress = (scansDone / totalScans) * 100;
                    currentScanProgress = Math.floor(progress); // Store globally
                    scanProgress.style.width = progress + '%';
                    scanCounter.textContent = `${scansDone} / ${totalScans}`;
                    
                    // Update percentage in loading indicator
                    const percentageEl = document.getElementById('scanPercentage');
                    if (percentageEl) {
                        percentageEl.textContent = `${currentScanProgress}%`;
                    }
                    
                    // Small delay to not overwhelm the UI
                    if (i % 10 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }
                }
                
                // Scan change addresses if requested
                if (scanChangeAddrs && scanningActive) {
                    for (let i = 0; i < scanCount && scanningActive; i++) {
                        // Derive change address at index
                        const walletInfo = deriveAddressAtIndex(
                            extractedWalletData.masterKey,
                            extractedWalletData.masterChainCode,
                            i,
                            extractedWalletData.isAlphaWallet,
                            true // change address
                        );
                        
                        // Skip logging each address to reduce clutter
                        
                        // Check balance if online
                        if (checkOnline && electrumConnected) {
                            const balanceInfo = await checkAddressBalance(walletInfo.address);
                            walletInfo.balance = balanceInfo.balance;
                            walletInfo.utxoCount = balanceInfo.utxoCount;
                            }
                        
                        // Add to results if has balance above dust threshold, if offline, or if it's the first change address
                        if (!checkOnline || !electrumConnected || walletInfo.balance > dustThreshold || i === 0) {
                            // If offline, show all addresses
                            if (!checkOnline || !electrumConnected) {
                                walletInfo.balance = -1; // Indicate unknown balance
                            }
                            walletInfo.isChange = true;
                            // Check for duplicates before adding
                            const isDuplicate = scannedWallets.some(w => w.address === walletInfo.address);
                            if (!isDuplicate) {
                                scannedWallets.push(walletInfo);
                                addWalletToResults(walletInfo);
                            } else {
                                console.warn(`Skipping duplicate change address: ${walletInfo.address}`);
                            }
                            
                            // Update total balance immediately if online and has balance
                            if (checkOnline && electrumConnected && walletInfo.balance > 0) {
                                let runningTotal = 0;
                                scannedWallets.forEach(w => {
                                    if (w.balance > 0) runningTotal += w.balance;
                                });
                                
                                // Update status with running total
                                scanStatus.innerHTML = `Scanning... Found ${scannedWallets.length} wallet(s)<br>Current total: <strong>${(runningTotal / 100000000).toFixed(8)} ALPHA</strong>`;
                                
                                // Update lastScannedWalletData with current data
                                lastScannedWalletData = {
                                    wallets: [...scannedWallets],
                                    totalBalance: runningTotal,
                                    masterKey: extractedWalletData.masterKey,
                                    masterChainCode: extractedWalletData.masterChainCode,
                                    isAlphaWallet: extractedWalletData.isAlphaWallet
                                };
                                
                                // Update display to reflect current scan state
                                updateScannedWalletsDisplay();
                            }
                        }
                        
                        scansDone++;
                        // Update progress
                        const progress = (scansDone / totalScans) * 100;
                        currentScanProgress = Math.floor(progress); // Store globally
                        scanProgress.style.width = progress + '%';
                        scanCounter.textContent = `${scansDone} / ${totalScans}`;
                        
                        // Update percentage in loading indicator
                        const percentageEl = document.getElementById('scanPercentage');
                        if (percentageEl) {
                            percentageEl.textContent = `${currentScanProgress}%`;
                        }
                        
                        // Small delay to not overwhelm the UI
                        if (i % 10 === 0) {
                            await new Promise(resolve => setTimeout(resolve, 50));
                        }
                    }
                }
                
                scanningActive = false;
                currentScanProgress = 100; // Set to 100% when complete
                
                // Update percentage one last time
                const percentageEl = document.getElementById('scanPercentage');
                if (percentageEl) {
                    percentageEl.textContent = '100%';
                }
                
                // Calculate total balance of all scanned wallets
                let totalBalance = 0;
                scannedWallets.forEach(w => {
                    if (w.balance > 0) totalBalance += w.balance;
                });
                
                // Store scan results for later use
                lastScannedWalletData = {
                    wallets: scannedWallets,
                    totalBalance: totalBalance,
                    masterKey: extractedWalletData.masterKey,
                    masterChainCode: extractedWalletData.masterChainCode,
                    isAlphaWallet: extractedWalletData.isAlphaWallet
                };
                
                // Save to cache
                const fingerprint = generateWalletFingerprint(extractedWalletData.masterKey, extractedWalletData.masterChainCode);
                saveScanResultsToCache(fingerprint, lastScannedWalletData);
                
                // Update scan status with total balance
                if (scannedWallets.length > 0) {
                    scanStatus.innerHTML = `Found ${scannedWallets.length} wallet(s) with funds<br>Total balance: <strong>${(totalBalance / 100000000).toFixed(8)} ALPHA</strong>`;
                } else {
                    scanStatus.textContent = !checkOnline || !electrumConnected ? 'Scan complete (offline mode)' : 'No wallets with funds found';
                }
                
                if (scannedWallets.length === 0) {
                    foundWalletsList.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No wallets with funds found. Try increasing the scan count or check your connection.</div>';
                }
                
                // Update main UI if wallet is loaded
                updateScannedWalletsDisplay();
            }
            
            // Update the main UI to show total scanned balance
            function updateScannedWalletsDisplay() {
                const totalScannedBalance = document.getElementById('totalScannedBalance');
                const totalScannedLoading = document.getElementById('totalScannedLoading');
                
                if (!lastScannedWalletData || !lastScannedWalletData.wallets) {
                    // Hide both total balance and loading indicator if no scan data
                    totalScannedBalance.style.display = 'none';
                    totalScannedLoading.style.display = 'none';
                    return;
                }
                
                // Count non-zero balance wallets
                const nonZeroWallets = lastScannedWalletData.wallets.filter(w => w.balance > 0).length;
                
                if (nonZeroWallets <= 1 && !scanningActive) {
                    // Hide both if only one or no wallets with balance (unless actively scanning)
                    totalScannedBalance.style.display = 'none';
                    totalScannedLoading.style.display = 'none';
                    return;
                }
                
                // If actively scanning, show loading indicator
                if (scanningActive) {
                    totalScannedLoading.style.display = 'inline';
                    // Hide balance during scan
                    totalScannedBalance.style.display = 'none';
                } else if (nonZeroWallets > 1) {
                    // Show total balance if multiple wallets found and not scanning
                    const totalBalance = lastScannedWalletData.totalBalance || 0;
                    document.getElementById('totalScannedAmount').textContent = `${(totalBalance / 100000000).toFixed(8)} ALPHA`;
                    totalScannedBalance.style.display = 'inline';
                    totalScannedLoading.style.display = 'none';
                } else {
                    // Hide both if conditions not met
                    totalScannedBalance.style.display = 'none';
                    totalScannedLoading.style.display = 'none';
                }
            }
            
            // Check for cached scan data on page load
            function checkAndLoadCachedScanData() {
                // Look for any cached scan data in localStorage
                const keys = Object.keys(localStorage);
                const cacheKeys = keys.filter(k => k.startsWith('walletScanCache_'));
                
                if (cacheKeys.length > 0) {
                    // Use the most recent cache
                    let mostRecentCache = null;
                    let mostRecentTime = 0;
                    
                    cacheKeys.forEach(key => {
                        try {
                            const data = JSON.parse(localStorage.getItem(key));
                            if (data.timestamp > mostRecentTime) {
                                mostRecentTime = data.timestamp;
                                mostRecentCache = data;
                                // Extract fingerprint from key
                                const fingerprint = key.replace('walletScanCache_', '');
                                mostRecentCache.fingerprint = fingerprint;
                            }
                        } catch (e) {
                            console.error('Failed to parse cache:', e);
                        }
                    });
                    
                    if (mostRecentCache && mostRecentCache.wallets && mostRecentCache.wallets.length > 0) {
                        
                        // Set the cached data
                        lastScannedWalletData = {
                            wallets: mostRecentCache.wallets,
                            totalBalance: mostRecentCache.totalBalance,
                            // We don't have the master keys here, but that's ok for display
                            masterKey: null,
                            masterChainCode: null,
                            isAlphaWallet: true
                        };
                        
                        // Update UI
                        updateScannedWalletsDisplay();
                        
                        // Note: We can't start lazy rescan here because we don't have master keys
                        // It will start when a wallet is loaded or when connected to Fulcrum
                    }
                }
            }
            
            // Lazy rescan functionality
            async function startLazyRescan() {
                if (!lastScannedWalletData || !lastScannedWalletData.wallets || !electrumConnected) {
                    return;
                }
                
                
                // Clear any existing interval
                if (lazyScanInterval) {
                    clearInterval(lazyScanInterval);
                }
                
                // Perform immediate rescan if enough time has passed
                const timeSinceLastScan = Date.now() - lastLazyScanTime;
                if (timeSinceLastScan > 3600000) { // 1 hour
                    performLazyRescan();
                }
                
                // Set up periodic rescan every hour
                lazyScanInterval = setInterval(() => {
                    if (electrumConnected) {
                        performLazyRescan();
                    }
                }, 3600000); // 1 hour
            }
            
            async function performLazyRescan() {
                if (!lastScannedWalletData || !lastScannedWalletData.wallets) {
                    // Clear the interval since we have no data to scan
                    if (lazyScanInterval) {
                        clearInterval(lazyScanInterval);
                        lazyScanInterval = null;
                    }
                    return;
                }
                
                lastLazyScanTime = Date.now();
                
                // Update status text for lazy rescan
                const statusTextEl = document.getElementById('scanStatusText');
                if (statusTextEl) {
                    statusTextEl.innerHTML = 'Updating balances';
                }
                
                let totalBalance = 0;
                let updatedWallets = [];
                
                // Scan wallets with rate limiting
                for (let i = 0; i < lastScannedWalletData.wallets.length; i++) {
                    const wallet = lastScannedWalletData.wallets[i];
                    
                    try {
                        // Check balance
                        const balanceInfo = await checkAddressBalance(wallet.address);
                        const newBalance = balanceInfo.balance;
                        const oldBalance = wallet.balance || 0;
                        
                        const updatedWallet = {
                            ...wallet,
                            balance: newBalance,
                            utxoCount: balanceInfo.utxoCount
                        };
                        
                        updatedWallets.push(updatedWallet);
                        if (newBalance > 0) {
                            totalBalance += newBalance;
                        }
                        
                        // Check if balance changed
                        if (oldBalance !== newBalance) {
                            
                            // Update the stored data immediately
                            lastScannedWalletData.wallets[i] = updatedWallet;
                            
                            // Recalculate total balance from all wallets scanned so far
                            let currentTotal = 0;
                            // Add balances from already updated wallets
                            for (let j = 0; j < updatedWallets.length; j++) {
                                if (updatedWallets[j].balance > 0) {
                                    currentTotal += updatedWallets[j].balance;
                                }
                            }
                            // Add balances from remaining wallets (not yet scanned)
                            for (let j = i + 1; j < lastScannedWalletData.wallets.length; j++) {
                                if (lastScannedWalletData.wallets[j].balance > 0) {
                                    currentTotal += lastScannedWalletData.wallets[j].balance;
                                }
                            }
                            
                            lastScannedWalletData.totalBalance = currentTotal;
                            
                            // Update display immediately
                            updateScannedWalletsDisplay();
                        } else {
                        }
                        
                        // Rate limit: wait 10 seconds between addresses
                        if (i < lastScannedWalletData.wallets.length - 1) {
                            await new Promise(resolve => setTimeout(resolve, 10000));
                        }
                    } catch (error) {
                        console.error(`Failed to rescan address ${wallet.address}:`, error);
                        // Keep the old data if scan fails
                        updatedWallets.push(wallet);
                        if (wallet.balance > 0) {
                            totalBalance += wallet.balance;
                        }
                    }
                }
                
                // Update stored data
                lastScannedWalletData = {
                    ...lastScannedWalletData,
                    wallets: updatedWallets,
                    totalBalance: totalBalance
                };
                
                // Update cache only if we have master keys
                if (lastScannedWalletData.masterKey) {
                    const fingerprint = generateWalletFingerprint(
                        lastScannedWalletData.masterKey,
                        lastScannedWalletData.masterChainCode
                    );
                    if (fingerprint) {
                        saveScanResultsToCache(fingerprint, lastScannedWalletData);
                    }
                } else {
                }
                
                // Update UI
                updateScannedWalletsDisplay();
                
            }
            
            // Show dialog with all scanned wallets
            function showScannedWalletsDialog() {
                if (!lastScannedWalletData || !lastScannedWalletData.wallets) {
                    alert('No scanned wallets available. Please import a wallet.dat file first.');
                    return;
                }
                
                // Create a modal dialog
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background-color: rgba(0, 0, 0, 0.5);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                `;
                
                const dialog = document.createElement('div');
                dialog.style.cssText = `
                    background: white;
                    border-radius: 12px;
                    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
                    max-width: 600px;
                    width: 90%;
                    max-height: 80vh;
                    overflow: hidden;
                    display: flex;
                    flex-direction: column;
                `;
                
                const header = document.createElement('div');
                header.style.cssText = 'padding: 20px; border-bottom: 1px solid #e9ecef;';
                header.innerHTML = `
                    <h3 style="margin: 0;">Scanned Wallets</h3>
                    <p style="margin: 10px 0 0 0; color: #666;">Total balance: <strong>${(lastScannedWalletData.totalBalance / 100000000).toFixed(8)} ALPHA</strong></p>
                `;
                
                const content = document.createElement('div');
                content.style.cssText = 'padding: 20px; overflow-y: auto; flex: 1;';
                
                // Recreate the wallet list
                lastScannedWalletData.wallets.forEach(walletInfo => {
                    const walletDiv = document.createElement('div');
                    walletDiv.style.cssText = 'padding: 15px; margin-bottom: 10px; background: #f8f9fa; border-radius: 8px; cursor: pointer; transition: background 0.2s;';
                    walletDiv.onmouseover = () => walletDiv.style.background = '#e9ecef';
                    walletDiv.onmouseout = () => walletDiv.style.background = '#f8f9fa';
                    
                    walletDiv.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="font-weight: bold; margin-bottom: 5px;">
                                    ${walletInfo.isChange ? 'Change ' : ''}Address #${walletInfo.index}
                                    ${walletInfo.isChange ? '<span style="background: #ffa500; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-left: 5px;">CHANGE</span>' : ''}
                                </div>
                                <div style="font-family: monospace; font-size: 12px; color: #666; word-break: break-all;">${walletInfo.address}</div>
                                <div style="font-size: 11px; color: #999; margin-top: 3px;">Path: ${walletInfo.path}</div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-weight: bold; color: var(--primary-color);">
                                    ${walletInfo.balance === -1 ? 'Balance Unknown' : `${(walletInfo.balance / 100000000).toFixed(8)} ALPHA`}
                                </div>
                                <div style="font-size: 11px; color: #666;">
                                    ${walletInfo.balance === -1 ? 'Offline' : 'Click to load'}
                                </div>
                            </div>
                        </div>
                    `;
                    
                    walletDiv.onclick = () => {
                        document.body.removeChild(modal);
                        // Reconstruct full wallet info from stored data
                        const fullWalletInfo = deriveAddressAtIndex(
                            lastScannedWalletData.masterKey,
                            lastScannedWalletData.masterChainCode,
                            walletInfo.index,
                            lastScannedWalletData.isAlphaWallet,
                            walletInfo.isChange
                        );
                        fullWalletInfo.balance = walletInfo.balance;
                        fullWalletInfo.utxoCount = walletInfo.utxoCount;
                        
                        // Store the extracted wallet data globally before importing
                        extractedWalletData = lastScannedWalletData;
                        
                        selectWalletForImport(fullWalletInfo);
                    };
                    
                    content.appendChild(walletDiv);
                });
                
                const footer = document.createElement('div');
                footer.style.cssText = 'padding: 20px; border-top: 1px solid #e9ecef; text-align: right;';
                footer.innerHTML = `
                    <button onclick="this.closest('div[style*=fixed]').remove()" class="button" style="background-color: #6c757d;">Close</button>
                `;
                
                dialog.appendChild(header);
                dialog.appendChild(content);
                dialog.appendChild(footer);
                modal.appendChild(dialog);
                document.body.appendChild(modal);
                
                // Close on backdrop click
                modal.onclick = (e) => {
                    if (e.target === modal) {
                        document.body.removeChild(modal);
                    }
                };
            }
            window.showScannedWalletsDialog = showScannedWalletsDialog;
            
            // Add wallet to results UI
            function addWalletToResults(walletInfo) {
                const walletDiv = document.createElement('div');
                walletDiv.style.cssText = 'padding: 15px; margin-bottom: 10px; background: #f8f9fa; border-radius: 8px; cursor: pointer; transition: background 0.2s;';
                walletDiv.onmouseover = () => walletDiv.style.background = '#e9ecef';
                walletDiv.onmouseout = () => walletDiv.style.background = '#f8f9fa';
                
                walletDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <div style="font-weight: bold; margin-bottom: 5px;">
                                ${walletInfo.isChange ? 'Change ' : ''}Address #${walletInfo.index}
                                ${walletInfo.isChange ? '<span style="background: #ffa500; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-left: 5px;">CHANGE</span>' : ''}
                            </div>
                            <div style="font-family: monospace; font-size: 12px; color: #666; word-break: break-all;">${walletInfo.address}</div>
                            <div style="font-size: 11px; color: #999; margin-top: 3px;">Path: ${walletInfo.path}</div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-weight: bold; color: var(--primary-color);">
                                ${walletInfo.balance === -1 ? 'Balance Unknown' : `${(walletInfo.balance / 100000000).toFixed(8)} ALPHA`}
                            </div>
                            <div style="font-size: 11px; color: #666;">
                                ${walletInfo.balance === -1 ? 'Offline' : 'Click to load'}
                            </div>
                        </div>
                    </div>
                `;
                
                walletDiv.onclick = () => selectWalletForImport(walletInfo);
                foundWalletsList.appendChild(walletDiv);
            }
            
            // Select a wallet for import
            function selectWalletForImport(walletInfo) {
                // Directly import without confirmation
                // Don't stop scanning - let it continue in background
                
                // Create wallet with the selected index
                // Remove utxos from walletInfo for storage
                const addressInfo = {
                    index: walletInfo.index,
                    address: walletInfo.address,
                    publicKey: walletInfo.publicKey,
                    path: walletInfo.path,
                    createdAt: new Date().toISOString()
                };
                
                wallet = {
                    masterPrivateKey: extractedWalletData.masterKey,
                    addresses: [addressInfo],
                    isEncrypted: false,
                    encryptedMasterKey: '',
                    childPrivateKey: walletInfo.privateKey,
                    isImportedAlphaWallet: extractedWalletData.isAlphaWallet,
                    masterChainCode: extractedWalletData.masterChainCode
                };
                
                // Update global reference
                window.walletGlobal = wallet;
                
                // Update UI
                updateButtonStates(true);
                addAddressToUI(walletInfo);
                saveWalletData();
                
                // Close modal
                closeRestoreModal();
                
                showInAppNotification('Wallet Imported', `Successfully imported wallet at index ${walletInfo.index}`, 'success');
                
                // Refresh balance if connected
                if (electrumConnected) {
                    refreshBalance();
                }
                
                // Update scanned wallets display
                updateScannedWalletsDisplay();
            }
            
            async function restoreWallet() {
                const file = restoreFileInput.files[0];
                if (!file) {
                    restoreStatus.className = 'info-box error';
                    restoreStatus.textContent = 'Please select a wallet backup file.';
                    restoreStatus.style.display = 'block';
                    return;
                }
                
                // Clear any existing scan cache when loading a new wallet
                const keysToRemove = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && (key.startsWith('walletScan_') || key === 'lastScannedWalletData' || key === 'lastLazyScanTime')) {
                        keysToRemove.push(key);
                    }
                }
                keysToRemove.forEach(key => {
                    localStorage.removeItem(key);
                    console.log('Cleared cached scan data on wallet load:', key);
                });
                
                // Clear in-memory scan data
                lastScannedWalletData = null;
                scannedWallets = [];
                
                try {
                    // Check if this is a wallet.dat file (SQLite)
                    if (file.name.endsWith('.dat')) {
                        await restoreFromWalletDat(file);
                        return;
                    }
                    
                    // Otherwise, read as text file (original backup format)
                    const fileContent = await file.text();
                    
                    // Parse the master key from the file
                    let masterKey = '';
                    let isEncrypted = false;
                    let encryptedMasterKey = '';
                    
                    // Check if this is an encrypted wallet
                    if (fileContent.includes('ENCRYPTED MASTER KEY')) {
                        isEncrypted = true;
                        
                        // Extract the encrypted master key
                        const encryptedKeyMatch = fileContent.match(/ENCRYPTED MASTER KEY \(password protected\):\s*([^\n]+)/);
                        if (encryptedKeyMatch && encryptedKeyMatch[1]) {
                            encryptedMasterKey = encryptedKeyMatch[1].trim();
                            
                            // Get the decryption password
                            const password = restorePasswordInput.value;
                            if (!password) {
                                restoreStatus.className = 'info-box error';
                                restoreStatus.textContent = 'This is an encrypted wallet. Please enter the decryption password.';
                                restoreStatus.style.display = 'block';
                                return;
                            }
                            
                            // Decrypt the master key
                            try {
                                const salt = "alpha_wallet_salt";
                                const passwordKey = CryptoJS.PBKDF2(password, salt, { keySize: 256/32, iterations: 100000 }).toString();
                                
                                // Try to decrypt
                                const decryptedBytes = CryptoJS.AES.decrypt(encryptedMasterKey, passwordKey);
                                masterKey = decryptedBytes.toString(CryptoJS.enc.Utf8);
                                
                                if (!masterKey) {
                                    restoreStatus.className = 'info-box error';
                                    restoreStatus.textContent = 'Failed to decrypt the wallet. The password may be incorrect.';
                                    restoreStatus.style.display = 'block';
                                    return;
                                }
                            } catch (e) {
                                restoreStatus.className = 'info-box error';
                                restoreStatus.textContent = 'Error decrypting wallet: ' + e.message;
                                restoreStatus.style.display = 'block';
                                return;
                            }
                        } else {
                            restoreStatus.className = 'info-box error';
                            restoreStatus.textContent = 'Could not find the encrypted master key in the backup file.';
                            restoreStatus.style.display = 'block';
                            return;
                        }
                    } else {
                        // Unencrypted wallet, extract the master key directly
                        const masterKeyMatch = fileContent.match(/MASTER PRIVATE KEY \(keep secret!\):\s*([^\n]+)/);
                        if (masterKeyMatch && masterKeyMatch[1]) {
                            masterKey = masterKeyMatch[1].trim();
                        } else {
                            restoreStatus.className = 'info-box error';
                            restoreStatus.textContent = 'Could not find the master private key in the backup file.';
                            restoreStatus.style.display = 'block';
                            return;
                        }
                    }
                    
                    // Check if this is an Alpha descriptor wallet with chain code
                    let masterChainCode = null;
                    let isImportedAlphaWallet = false;
                    
                    const chainCodeMatch = fileContent.match(/MASTER CHAIN CODE \(for Alpha wallet compatibility\):\s*([^\n]+)/);
                    if (chainCodeMatch && chainCodeMatch[1]) {
                        masterChainCode = chainCodeMatch[1].trim();
                        isImportedAlphaWallet = true;
                    }
                    
                    // Also check wallet type explicitly
                    if (fileContent.includes('WALLET TYPE: Alpha descriptor wallet')) {
                        isImportedAlphaWallet = true;
                    }
                    
                    // Confirmation before overwriting
                    if (wallet.masterPrivateKey) {
                        const confirmOverwrite = confirm('This will overwrite your existing wallet. Are you sure you want to proceed?');
                        if (!confirmOverwrite) {
                            return;
                        }
                    }
                    
                    // Create a new wallet with the restored master key
                    wallet = {
                        masterPrivateKey: masterKey,
                        addresses: [],
                        isEncrypted: isEncrypted,
                        encryptedMasterKey: encryptedMasterKey,
                        childPrivateKey: null, // Will be set when generating first address
                        isImportedAlphaWallet: isImportedAlphaWallet,
                        masterChainCode: masterChainCode
                    };
                    
                    // Update global reference
                    window.walletGlobal = wallet;
                    
                    // Update UI for both key displays
                    // masterKeyElement.textContent = masterKey; // Removed with Security section
                    // masterKeyElement.classList.add('masked'); // Removed with Security section
                    
                    // Convert and display WIF key
                    const wifKey = hexToWIF(masterKey);
                    // const wifKeyElement = document.getElementById('wifMasterKey'); // Removed with Security section
                    // wifKeyElement.textContent = wifKey; // Removed with Security section
                    // wifKeyElement.classList.add('masked'); // Removed with Security section
                    
                    
                    // Enable buttons
                    updateButtonStates(true);
                    
                    // Update encryption UI
                    if (isEncrypted) {
                        // encryptionStatus.style.display = 'block'; // Removed with Security section
                        // Hide password strength indicator when wallet is encrypted
                        passwordStrength.innerHTML = '';
                    } else {
                        // encryptionStatus.style.display = 'none'; // Removed with Security section
                    }
                    
                    // Generate addresses properly
                    if (wallet.isImportedAlphaWallet && wallet.masterChainCode) {
                        // For BIP32 wallets, ALWAYS regenerate addresses from master key
                        // Don't trust the addresses in the file - derive them properly
                        wallet.addresses = []; // Clear any loaded addresses
                        generateNewAddress(); // This will use BIP32 derivation
                    } else if (wallet.addresses.length === 0) {
                        // For standard wallets with no addresses, generate one
                        generateNewAddress();
                    } else {
                        // For standard wallets with addresses, use the loaded ones
                        // If there are multiple addresses from backup, just keep the first one
                        if (wallet.addresses.length > 1) {
                            wallet.addresses = [wallet.addresses[0]];
                        }
                        addAddressToUI(wallet.addresses[0]);
                    }
                    
                    // Save the restored wallet
                    saveWalletData();
                    
                    // If already connected to Fulcrum, refresh balance
                    if (electrumConnected) {
                        // Reset initial load flag when wallet is restored
                        isInitialLoad = true;
                        setTimeout(() => {
                            refreshBalance();
                            updateTransactionHistory();
                            // Allow notifications after initial load
                            setTimeout(() => {
                                isInitialLoad = false;
                            }, 2000);
                        }, 500);
                    }
                    
                    // Close any open sections to maintain a clean UI
                    // document.getElementById('keys-section').style.display = 'none'; // Removed with Security section
                    
                    // Reset section button text
                    // document.getElementById('showEncryptionBtn').innerHTML = ` // Removed with Security section
                        /* <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                            <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                            <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
                        </svg>
                        Encrypt Wallet`; */
                        
                    // document.getElementById('showRestoreBtn').innerHTML = ` // Removed with Security section
                        /* <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="17 8 12 3 7 8"></polyline>
                            <line x1="12" y1="3" x2="12" y2="15"></line>
                        </svg>
                        Restore Wallet`; */
                        
                    // document.getElementById('showAdvancedBtn').innerHTML = ` // Removed with Security section
                        /* <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                            <path d="M12 20h9"></path>
                            <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>
                        </svg>
                        Migrate Wallet`; */
                    
                    // Show success message
                    restoreStatus.className = 'info-box success';
                    restoreStatus.textContent = 'Wallet restored successfully!';
                    restoreStatus.style.display = 'block';
                    showInAppNotification('Wallet Restored', 'Your wallet has been successfully restored from backup', 'success');
                    
                    // Close modal after a delay
                    setTimeout(() => {
                        closeRestoreModal();
                    }, 2000);
                    
                } catch (e) {
                    console.error('Error restoring wallet:', e);
                    restoreStatus.className = 'info-box error';
                    restoreStatus.textContent = 'Failed to restore wallet: ' + e.message;
                    restoreStatus.style.display = 'block';
                }
            }
            
            // Toggle WIF key visibility
            /* // Removed with Security section
            async function toggleWifKey() {
                // const wifKeyElement = document.getElementById('wifMasterKey'); // Removed with Security section
                
                if (wifKeyElement.classList.contains('masked')) {
                    // Check if wallet is encrypted
                    if (wallet.isEncrypted) {
                        // Ask for password with custom modal
                        const password = await showPasswordModal(
                            "Enter Password",
                            "Your wallet is encrypted. Please enter your password to view the private key:"
                        );
                        
                        if (!password) {
                            return; // User cancelled
                        }
                        
                        try {
                            // Generate key from password
                            const salt = "alpha_wallet_salt";
                            const passwordKey = CryptoJS.PBKDF2(password, salt, { keySize: 256/32, iterations: 100000 }).toString();
                            
                            // Try to decrypt the master key
                            const decryptedKey = CryptoJS.AES.decrypt(wallet.encryptedMasterKey, passwordKey).toString(CryptoJS.enc.Utf8);
                            
                            // If decryption failed, this will be an empty string
                            if (!decryptedKey) {
                                alert("Incorrect password. Access denied.");
                                return;
                            }
                            
                            // Check if the decrypted key matches our stored key
                            if (decryptedKey !== wallet.masterPrivateKey) {
                                alert("Incorrect password. Access denied.");
                                return;
                            }
                            
                            // Password verified, proceed with normal confirmation
                        } catch (e) {
                            console.error("Error decrypting master key:", e);
                            alert("Error verifying password. Access denied.");
                            return;
                        }
                    }
                    
                    // Show a confirmation dialog
                    const shouldShow = confirm("You are about to reveal your private key. Make sure no one is looking at your screen. Continue?");
                    
                    if (shouldShow) {
                        // Generate the child key for the first address
                        const addressIndex = 0;
                        const derivationPath = `m/44'/0'/${addressIndex}'`;
                        const hmacInput = CryptoJS.enc.Hex.parse(wallet.masterPrivateKey);
                        const hmacKey = CryptoJS.enc.Utf8.parse(derivationPath);
                        const hmacOutput = CryptoJS.HmacSHA512(hmacInput, hmacKey).toString();
                        const childPrivateKey = hmacOutput.substring(0, 64);
                        
                        // Convert and display the child key as WIF
                        const wifKey = hexToWIF(childPrivateKey);
                        wifKeyElement.textContent = wifKey;
                        
                        wifKeyElement.classList.remove('masked');
                        // document.getElementById('toggleWifKeyBtn').innerHTML = ` // Removed with Security section
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 5px;">
                                <path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path>
                                <line x1="1" y1="1" x2="23" y2="23"></line>
                            </svg>
                            <span>Hide</span>
                        `;
                        
                        // Auto-hide after 30 seconds for security
                        setTimeout(() => {
                            if (!wifKeyElement.classList.contains('masked')) {
                                wifKeyElement.classList.add('masked');
                                // document.getElementById('toggleWifKeyBtn').innerHTML = ` // Removed with Security section
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 5px;">
                                        <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                        <circle cx="12" cy="12" r="3"></circle>
                                    </svg>
                                    <span>Show</span>
                                `;
                            }
                        }, 30000);
                    }
                } else {
                    wifKeyElement.classList.add('masked');
                    document.getElementById('toggleWifKeyBtn').innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 5px;">
                            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                            <circle cx="12" cy="12" r="3"></circle>
                        </svg>
                        <span>Show</span>
                    `;
                }
            }
            */ // End of removed toggleWifKey function
            
            // Toggle section functionality
            function toggleSection(sectionId, buttonId, showText, hideText, iconSvg) {
                const section = document.getElementById(sectionId);
                const button = document.getElementById(buttonId);
                
                if (section.style.display === 'none') {
                    // Hide any other open sections first
                                                            document.getElementById('keys-section').style.display = 'none';
                    
                    // Reset all button texts
                    // document.getElementById('showEncryptionBtn').innerHTML = ` // Removed with Security section
                        /* <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                            <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                            <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
                        </svg>
                        Encrypt Wallet`; */
                        
                    // document.getElementById('showRestoreBtn').innerHTML = ` // Removed with Security section
                        /* <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="17 8 12 3 7 8"></polyline>
                            <line x1="12" y1="3" x2="12" y2="15"></line>
                        </svg>
                        Restore Wallet`; */
                        
                    // document.getElementById('showAdvancedBtn').innerHTML = ` // Removed with Security section
                        /* <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                            <path d="M12 20h9"></path>
                            <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>
                        </svg>
                        Migrate Wallet`; */
                    
                    // Show this section
                    section.style.display = 'block';
                    button.innerHTML = hideText;
                    
                    // Always enable the button when it's in "hide" mode
                    button.disabled = false;
                    
                    // Smooth scroll to the section
                    setTimeout(() => {
                        section.scrollIntoView({ behavior: 'smooth' });
                    }, 100);
                } else {
                    // Hide this section
                    section.style.display = 'none';
                    button.innerHTML = iconSvg + showText;
                }
            }
            
            // Migrate section toggle
            /* // Removed with Security section
            function toggleMigrateSection() {
                toggleSection(
                    'keys-section', 
                    'showAdvancedBtn',
                    'Migrate Wallet',
                    'Hide Migration Options',
                    `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                        <path d="M12 20h9"></path>
                        <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>
                    </svg>`
                );
            }
            */
            
            
            // Set up event listeners
            initializeWalletBtn.addEventListener('click', initializeWallet);
            saveWalletBtn.addEventListener('click', showSaveModal);
            deleteWalletBtn.addEventListener('click', deleteWallet);
            restoreWalletBtn.addEventListener('click', showRestoreModal);
            // migrateWalletBtn.addEventListener('click', toggleMigrateSection); // Removed with Security section
            
            // Restore modal event listeners
            restoreModalCancelBtn.addEventListener('click', closeRestoreModal);
            restoreModalSubmitBtn.addEventListener('click', restoreWallet);
            scanWalletsBtn.addEventListener('click', startWalletScan);
            
            // File input change handler
            restoreFileInput.addEventListener('change', async function() {
                if (this.files.length > 0) {
                    const file = this.files[0];
                    
                    // Check if it's an encrypted wallet
                    let isEncryptedWallet = false;
                    if (file.name.endsWith('.txt')) {
                        try {
                            const fileContent = await file.text();
                            // Check for both new and old encrypted formats
                            if (fileContent.includes('ENCRYPTED UNICITY WALLET') || 
                                fileContent.includes('ENCRYPTED MASTER KEY')) {
                                isEncryptedWallet = true;
                            }
                        } catch (e) {
                            // Continue with normal flow if can't read
                        }
                    }
                    
                    if (isEncryptedWallet) {
                        // Show decrypt button for encrypted wallets
                        walletScanOptions.style.display = 'none';
                        restoreModalSubmitBtn.style.display = 'none';
                        scanWalletsBtn.style.display = 'inline-block';
                        scanWalletsBtn.textContent = 'Decrypt';
                        
                        restoreStatus.className = 'info-box warning';
                        restoreStatus.textContent = 'This is an encrypted wallet. Please enter the password and click Decrypt.';
                        restoreStatus.style.display = 'block';
                    } else {
                        // Normal wallet discovery flow
                        walletScanOptions.style.display = 'block';
                        restoreModalSubmitBtn.style.display = 'none';
                        scanWalletsBtn.style.display = 'inline-block';
                        scanWalletsBtn.textContent = 'Rescan Wallets';
                        restoreStatus.style.display = 'none';
                        
                        // Start scanning automatically for non-encrypted wallets
                        setTimeout(() => {
                            startWalletScan();
                        }, 500); // Small delay for UI to update
                    }
                } else {
                    walletScanOptions.style.display = 'none';
                    scanWalletsBtn.style.display = 'none';
                    restoreModalSubmitBtn.style.display = 'inline-block';
                    restoreStatus.style.display = 'none';
                }
            });
            
            // Password strength checker
            passwordModalInput.addEventListener('input', function() {
                checkPasswordStrength(this.value);
            });
            
            // Save wallet data using IndexedDB (works across tabs)
            function saveWalletData() {
                try {
                    const request = indexedDB.open("AlphaWalletDB", 1);
                    
                    request.onupgradeneeded = function(event) {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('wallet')) {
                            db.createObjectStore('wallet', { keyPath: 'id' });
                        }
                    };
                    
                    request.onerror = function(event) {
                        console.error("IndexedDB error:", event.target.error);
                        // Fallback to localStorage
                        localStorage.setItem('alphaWallet', JSON.stringify(wallet));
                    };
                    
                    request.onsuccess = function(event) {
                        const db = event.target.result;
                        const transaction = db.transaction(['wallet'], 'readwrite');
                        const store = transaction.objectStore('wallet');
                        
                        // Always use the same ID to ensure we're updating the same wallet
                        const walletData = { ...wallet, id: 'main-wallet' };
                        store.put(walletData);
                        
                        transaction.oncomplete = function() {
                            console.log("Wallet data saved to IndexedDB");
                        };
                    };
                } catch (e) {
                    console.error("Error saving wallet data", e);
                    // Fallback to localStorage
                    localStorage.setItem('alphaWallet', JSON.stringify(wallet));
                }
            }
            
            // Check wallet status on page load
            function checkWalletStatus() {
                if (wallet.masterPrivateKey) {
                    initializeWalletBtn.disabled = true;
                    initializeWalletBtn.title = "Wallet already created";
                }
            }
            
            // Check connection status (online/offline)
            function checkConnectionStatus() {
                const connectionStatus = document.getElementById('connectionStatus');
                const connectionStatusText = document.getElementById('connectionStatusText');
                
                // First, update the status based on navigator.onLine
                updateConnectionUI(navigator.onLine);
                
                // Then, try to perform a more accurate check by fetching a remote resource
                // This is a more reliable way to detect true connectivity
                if (navigator.onLine) {
                    // Create a unique URL to prevent caching
                    const testUrl = 'https://www.google.com/favicon.ico?_=' + new Date().getTime();
                    
                    // Set a short timeout to avoid blocking the UI if network is slow
                    const timeoutPromise = new Promise((_, reject) => {
                        setTimeout(() => reject(new Error('Timeout')), 3000);
                    });
                    
                    // Try to fetch a small resource
                    Promise.race([
                        fetch(testUrl, { method: 'HEAD', mode: 'no-cors', cache: 'no-store' }),
                        timeoutPromise
                    ])
                    .then(() => {
                        // If successful, we're definitely online
                        updateConnectionUI(true);
                    })
                    .catch(error => {
                        // If there's an error fetching, we might be offline or behind a firewall
                        if (error.message === 'Timeout') {
                            // Still showing as online but slow/unreliable
                            updateConnectionUI(true, 'slow');
                        } else {
                            // Probably offline or blocked - show as offline
                            updateConnectionUI(false);
                        }
                    });
                }
            }
            
            // Helper to update the connection status UI (removed - no longer showing warnings)
            function updateConnectionUI(isOnline, connectionQuality = 'normal') {
                // Function kept for compatibility but no longer displays warnings
                // Connection status is now shown only in the connection indicator
            }
            
            // Set up event listeners for online/offline status
            window.addEventListener('online', checkConnectionStatus);
            window.addEventListener('offline', checkConnectionStatus);
            
            // Check connection status immediately
            checkConnectionStatus();
            
            // Periodically check connection status (every 60 seconds)
            setInterval(checkConnectionStatus, 60000);
            
            // Load wallet data and do initial check
            loadWalletData();
            
            // Initialize broadcast queue
            initBroadcastQueue();
            
            // Check for cached scan data and start lazy rescan
            checkAndLoadCachedScanData();
            
            // ===== ELECTRUM RPC CLIENT =====
            
            // WebSocket connection for Electrum protocol
            let electrumSocket = null;
            let electrumRequestId = 1;
            let electrumCallbacks = {};
            // electrumConnected already declared at top
            let currentScriptHashSubscription = null;
            let headerSubscriptionActive = false;
            
            // Helper function to subscribe to address changes
            function subscribeToAddressChanges(address) {
                if (!electrumConnected || !address) return;
                
                const scriptHash = addressToScriptHash(address);
                if (!scriptHash) return;
                
                // Unsubscribe from previous address if any
                if (currentScriptHashSubscription && currentScriptHashSubscription !== scriptHash) {
                    electrumRequest('blockchain.scripthash.unsubscribe', [currentScriptHashSubscription], function(result) {
                        console.log('Unsubscribed from previous address:', result);
                    });
                }
                
                // Subscribe to new address
                electrumRequest('blockchain.scripthash.subscribe', [scriptHash], function(result) {
                    // Successfully subscribed to address changes
                    currentScriptHashSubscription = scriptHash;
                });
            }
            
            // Helper function to unsubscribe from current address
            function unsubscribeFromAddressChanges() {
                if (currentScriptHashSubscription && electrumConnected) {
                    electrumRequest('blockchain.scripthash.unsubscribe', [currentScriptHashSubscription], function(result) {
                        console.log('Unsubscribed from address:', result);
                        currentScriptHashSubscription = null;
                    });
                }
            }
            
            // RPC UI elements
            const connectRpcBtn = document.getElementById('connectRpcBtn');
            const disconnectRpcBtn = document.getElementById('disconnectRpcBtn');
            const rpcServerInput = document.getElementById('rpcServer');
            const connectionStatusDiv = document.getElementById('connectionStatus');
            const connectionStatusText = document.getElementById('connectionStatusText');
            // const balanceDisplay = document.getElementById('balanceDisplay'); // Removed duplicate balance display
            // const balanceAmount = document.getElementById('balanceAmount'); // Removed duplicate balance display
            // const transactionList = document.getElementById('transactionList'); // Removed duplicate transaction display
            // const refreshBalanceBtn = document.getElementById('refreshBalanceBtn'); // Removed duplicate balance display
            
            // Connect to Electrum server
            function connectToElectrum(silent = false) {
                const serverUrl = rpcServerInput.value.trim();
                
                if (!serverUrl) {
                    if (!silent) alert('Please enter a Fulcrum server URL');
                    return;
                }
                
                // Show connecting status
                connectionStatusDiv.style.display = 'block';
                connectionStatusText.textContent = 'Connecting to ' + serverUrl + '...';
                
                try {
                    electrumSocket = new WebSocket(serverUrl);
                    
                    electrumSocket.onopen = function() {
                        electrumConnected = true;
                        updateUtxoListDisplay(); // Update UTXO list display when connected
                        const infoBox = connectionStatusDiv.querySelector('.info-box');
                        if (infoBox) {
                            infoBox.style.backgroundColor = 'rgba(6, 214, 160, 0.1)';
                            infoBox.style.borderLeftColor = 'var(--success-color)';
                        }
                        connectionStatusText.textContent = 'Connected to Fulcrum server';
                        showInAppNotification('Connected', 'Successfully connected to Fulcrum server', 'success');
                        
                        // Update buttons
                        connectRpcBtn.style.display = 'none';
                        disconnectRpcBtn.style.display = 'inline-flex';
                        rpcServerInput.disabled = true;
                        
                        // Resume broadcast queue if needed
                        if (broadcastQueue.length > 0 && !isQueueProcessing) {
                            console.log('Connection established, resuming broadcast queue');
                            processQueue();
                        }
                        
                        // Show balance display
                        // balanceDisplay.style.display = 'block'; // Removed duplicate balance display
                        
                        // Subscribe to headers for new blocks
                        electrumRequest('blockchain.headers.subscribe', [], function(result) {
                            // Successfully subscribed to block headers
                            headerSubscriptionActive = true;
                            if (result && (result.height || result.block_height)) {
                                currentBlockHeight = result.height || result.block_height;
                                // Get the actual block header to extract timestamp
                                electrumRequest('blockchain.block.header', [currentBlockHeight], function(headerHex) {
                                    if (headerHex) {
                                        // Parse block header to get timestamp (bytes 68-71)
                                        // Bitcoin block header timestamp is at bytes 68-71 (little-endian)
                                        const timestampBytes = headerHex.substr(68 * 2, 8).match(/.{2}/g).reverse().join('');
                                        currentBlockTime = new Date(parseInt(timestampBytes, 16) * 1000);
                                        console.log(`Block ${currentBlockHeight} timestamp: ${currentBlockTime.toISOString()}`);
                                    }
                                    updateCommonBalance();
                                });
                            }
                        });
                        
                        // Subscribe to current address if available
                        const currentAddress = wallet.addresses && wallet.addresses.length > 0 ? 
                            wallet.addresses[0].address : watchOnlyAddressValue;
                        if (currentAddress) {
                            subscribeToAddressChanges(currentAddress);
                        }
                        
                        // Refresh balance on connect  
                        refreshBalance();
                        
                        // After initial load, allow notifications
                        setTimeout(() => {
                            isInitialLoad = false;
                        }, 2000);
                        
                        // Update import button state
                        updateCommonBalance();
                        
                        // Start polling for new blocks
                        startBlockPolling();
                        
                        // Start lazy rescan if we have scanned wallets data
                        if (lastScannedWalletData && lastScannedWalletData.wallets && lastScannedWalletData.wallets.length > 0) {
                            startLazyRescan();
                        }
                        
                        // Get server version
                        electrumRequest('server.version', ['Unicity Wallet', '1.4'], function(result) {
                            console.log('Server version:', result);
                        });
                        
                        // If we have an address, get its balance
                        if (wallet.addresses && wallet.addresses.length > 0) {
                            refreshBalance();
                        }
                    };
                    
                    electrumSocket.onmessage = function(event) {
                        try {
                            const response = JSON.parse(event.data);
                            
                            // Handle normal responses
                            if (response.id && electrumCallbacks[response.id]) {
                                const callback = electrumCallbacks[response.id];
                                delete electrumCallbacks[response.id];
                                
                                if (response.error) {
                                    console.error('Electrum error:', response.error);
                                    callback(null, response.error);
                                } else {
                                    callback(response.result);
                                }
                            }
                            
                            // Handle subscription notifications (no id field)
                            else if (response.method && response.params) {
                                if (response.method === 'blockchain.headers.subscribe') {
                                    // New block header notification
                                    const header = response.params[0];
                                    if (header) {
                                        const newHeight = header.height || header.block_height;
                                        console.log('New block detected via subscription:', newHeight);
                                        
                                        // Update block height and timestamp
                                        currentBlockHeight = newHeight;
                                        const timestampHex = header.hex.substring(136, 144);
                                        const timestamp = parseInt(timestampHex.match(/../g).reverse().join(''), 16);
                                        currentBlockTime = new Date(timestamp * 1000);
                                        
                                        // Update UI and refresh data
                                        updateCommonBalance();
                                        
                                        // Handle new block for broadcast queue
                                        onNewBlock();
                                        
                                        // Refresh appropriate balance
                                        if (watchOnlyMode && watchOnlyAddressValue) {
                                            refreshWatchOnlyBalance(watchOnlyAddressValue);
                                        } else {
                                            refreshBalance();
                                        }
                                        
                                        // Always update transaction history to refresh confirmation counts
                                        updateTransactionHistory();
                                        
                                        // Also update UTXO list to refresh confirmation counts
                                        updateUtxoListDisplay();
                                        
                                        // Don't show notification for new blocks - too frequent and redundant
                                    }
                                }
                                else if (response.method === 'blockchain.scripthash.subscribe') {
                                    // Address status changed notification
                                    const scriptHash = response.params[0];
                                    const status = response.params[1];
                                    console.log('Address status changed:', scriptHash, status);
                                    
                                    // Refresh balance and transactions immediately
                                    if (watchOnlyMode && watchOnlyAddressValue) {
                                        refreshWatchOnlyBalance(watchOnlyAddressValue);
                                    } else {
                                        refreshBalance();
                                    }
                                    
                                    // Don't show notification for address activity - too frequent
                                }
                            }
                        } catch (err) {
                            console.error('Error parsing Electrum response:', err);
                        }
                    };
                    
                    electrumSocket.onerror = function(error) {
                        console.error('WebSocket error:', error);
                        const infoBox = connectionStatusDiv.querySelector('.info-box');
                        if (infoBox) {
                            infoBox.style.backgroundColor = 'rgba(255, 0, 110, 0.1)';
                            infoBox.style.borderLeftColor = 'var(--danger-color)';
                        }
                        if (silent) {
                            connectionStatusText.textContent = 'Unable to auto-connect. Click connect to try manually.';
                            setTimeout(() => {
                                connectionStatusDiv.style.display = 'none';
                            }, 3000);
                        } else {
                            connectionStatusText.textContent = 'Connection error: Check console for details';
                            showInAppNotification('Connection Error', 'Failed to connect to Fulcrum server', 'error');
                        }
                    };
                    
                    electrumSocket.onclose = function() {
                        electrumConnected = false;
                        currentScriptHashSubscription = null;
                        headerSubscriptionActive = false;
                        isInitialLoad = true;  // Reset for next connection
                        updateUtxoListDisplay(); // Update UTXO list display when disconnected
                        updateCommonBalance(); // Update button states
                        const infoBox = connectionStatusDiv.querySelector('.info-box');
                        if (infoBox) {
                            infoBox.style.backgroundColor = 'rgba(255, 186, 8, 0.1)';
                            infoBox.style.borderLeftColor = '#ffba08';
                        }
                        
                        // Clear lazy scan interval
                        if (lazyScanInterval) {
                            clearInterval(lazyScanInterval);
                            lazyScanInterval = null;
                        }
                        connectionStatusText.textContent = 'Disconnected from server';
                        
                        // Update buttons
                        connectRpcBtn.style.display = 'inline-flex';
                        disconnectRpcBtn.style.display = 'none';
                        rpcServerInput.disabled = false;
                        
                        // Hide balance display
                        // balanceDisplay.style.display = 'none'; // Removed duplicate balance display
                    };
                    
                } catch (err) {
                    if (!silent) {
                        showInAppNotification('Connection Failed', err.message, 'error');
                    }
                    const infoBox = connectionStatusDiv.querySelector('.info-box');
                    if (infoBox) {
                        infoBox.style.backgroundColor = 'rgba(255, 0, 110, 0.1)';
                        infoBox.style.borderLeftColor = 'var(--danger-color)';
                    }
                    if (silent) {
                        connectionStatusText.textContent = 'Auto-connect unavailable';
                        setTimeout(() => {
                            connectionStatusDiv.style.display = 'none';
                        }, 3000);
                    } else {
                        connectionStatusText.textContent = 'Failed to connect: ' + err.message;
                    }
                }
            }
            
            // Disconnect from Electrum server
            function disconnectFromElectrum() {
                if (electrumSocket) {
                    electrumSocket.close();
                    electrumSocket = null;
                    showInAppNotification('Disconnected', 'Manually disconnected from Fulcrum server', 'info');
                }
                electrumConnected = false;
                electrumCallbacks = {};
                updateUtxoListDisplay(); // Update UTXO list display when disconnected
                
                // Stop polling
                stopBlockPolling();
                
                // Clear lazy scan interval
                if (lazyScanInterval) {
                    clearInterval(lazyScanInterval);
                    lazyScanInterval = null;
                }
                
                // Update UI
                updateCommonBalance();
            }
            
            // Make an Electrum RPC request
            function electrumRequest(method, params, callback) {
                if (!electrumConnected || !electrumSocket) {
                    console.error('Not connected to Electrum server');
                    if (callback) callback(null, 'Not connected');
                    return;
                }
                
                const id = electrumRequestId++;
                const request = {
                    id: id,
                    method: method,
                    params: params || []
                };
                
                if (callback) {
                    electrumCallbacks[id] = callback;
                }
                
                try {
                    electrumSocket.send(JSON.stringify(request) + '\n');
                } catch (err) {
                    console.error('Error sending request:', err);
                    if (callback) callback(null, err.message);
                }
            }
            
            // Convert Bech32 address to script hash for Electrum protocol
            function addressToScriptHash(address) {
                try {
                    // Decode the bech32 address to get the witness program
                    const decoded = decodeBech32(address);
                    if (!decoded) {
                        console.error('Failed to decode address:', address);
                        return null;
                    }
                    
                    const witnessVersion = decoded.witnessVersion;
                    const witnessProgram = decoded.data;
                    
                    // Create the scriptPubKey for P2WPKH (witness version 0, 20 bytes)
                    // Format: OP_0 (0x00) + push_20_bytes (0x14) + witness_program
                    let scriptPubKey = [];
                    
                    // Add witness version (OP_0 for version 0, or OP_1-OP_16 for versions 1-16)
                    if (witnessVersion === 0) {
                        scriptPubKey.push(0x00);
                    } else {
                        scriptPubKey.push(0x50 + witnessVersion); // OP_1 = 0x51, OP_2 = 0x52, etc.
                    }
                    
                    // Add push opcode for the witness program length
                    scriptPubKey.push(witnessProgram.length);
                    
                    // Add the witness program
                    scriptPubKey = scriptPubKey.concat(witnessProgram);
                    
                    // Convert to hex string for hashing
                    const scriptHex = scriptPubKey.map(b => b.toString(16).padStart(2, '0')).join('');
                    
                    // Hash the script with SHA256
                    const hash = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(scriptHex));
                    const hashBytes = CryptoJS.enc.Hex.stringify(hash);
                    
                    // Reverse the bytes for Electrum (little-endian)
                    let reversed = '';
                    for (let i = hashBytes.length - 2; i >= 0; i -= 2) {
                        reversed += hashBytes.substr(i, 2);
                    }
                    
                    return reversed;
                } catch (err) {
                    console.error('Error converting address to script hash:', err);
                    return null;
                }
            }
            
            // Decode Bech32 address to get witness version and program
            function decodeBech32(address) {
                try {
                    // Normalize address to lowercase for Bech32 processing
                    address = address.toLowerCase();
                    
                    // Find the separator '1'
                    const pos = address.lastIndexOf('1');
                    if (pos < 1) return null;
                    
                    const hrp = address.substring(0, pos);
                    const data = address.substring(pos + 1);
                    
                    // Decode the data part
                    const decoded = [];
                    for (let i = 0; i < data.length; i++) {
                        const d = CHARSET.indexOf(data.charAt(i));
                        if (d === -1) return null;
                        decoded.push(d);
                    }
                    
                    // Verify checksum (last 6 characters)
                    if (!verifyBech32Checksum(hrp, decoded)) {
                        console.error('Invalid bech32 checksum');
                        return null;
                    }
                    
                    // Remove checksum
                    const values = decoded.slice(0, -6);
                    
                    // First value is witness version
                    const witnessVersion = values[0];
                    
                    // Convert from 5-bit to 8-bit
                    const witnessProgram = convertBits(values.slice(1), 5, 8, false);
                    
                    return {
                        hrp: hrp,
                        witnessVersion: witnessVersion,
                        data: witnessProgram
                    };
                } catch (err) {
                    console.error('Error decoding bech32:', err);
                    return null;
                }
            }
            
            // Verify Bech32 checksum
            function verifyBech32Checksum(hrp, data) {
                const values = hrpExpand(hrp).concat(data);
                return bech32Polymod(values) === 1;
            }
            
            // Refresh balance for current address
            function refreshBalance() {
                let address = null;
                
                if (watchOnlyMode && watchOnlyAddressValue) {
                    address = watchOnlyAddressValue;
                } else if (wallet.addresses && wallet.addresses.length > 0) {
                    address = wallet.addresses[0].address;
                } else {
                    // No address available
                    return;
                }
                
                const scriptHash = addressToScriptHash(address);
                
                if (!scriptHash) {
                    // balanceAmount.textContent = 'Error: Invalid address format'; // Removed duplicate balance display
                    console.error('Failed to convert address to script hash');
                    return;
                }
                
                // balanceAmount.textContent = 'Loading...'; // Removed duplicate balance display
                // Debug logs removed
                
                // Get script hash balance (using blockchain.scripthash.get_balance)
                electrumRequest('blockchain.scripthash.get_balance', [scriptHash], function(result, error) {
                    if (error) {
                        // balanceAmount.textContent = 'Error loading balance'; // Removed duplicate balance display
                        console.error('Balance error:', error);
                        return;
                    }
                    
                    if (result) {
                        const confirmed = result.confirmed || 0;
                        const unconfirmed = result.unconfirmed || 0;
                        const total = confirmed + unconfirmed;
                        
                        // Convert from satoshis to ALPHA (1 ALPHA = 100,000,000 satoshis)
                        const alphaBalance = (total / 100000000).toFixed(8);
                        // balanceAmount.textContent = alphaBalance + ' ALPHA'; // Removed duplicate balance display
                        
                        if (unconfirmed > 0) {
                            const unconfirmedAlpha = (unconfirmed / 100000000).toFixed(8);
                            // balanceAmount.innerHTML += '<br><small style="color: #999;">(' + unconfirmedAlpha + ' unconfirmed)</small>'; // Removed duplicate balance display
                        }
                    }
                });
                
                // Get transaction history (using blockchain.scripthash.get_history)
                electrumRequest('blockchain.scripthash.get_history', [scriptHash], function(result, error) {
                    if (error) {
                        // transactionList.innerHTML = '<p style="color: #999; text-align: center;">Error loading transactions</p>'; // Removed duplicate transaction display
                        return;
                    }
                    
                    if (result && result.length > 0) {
                        // transactionList.innerHTML = ''; // Removed duplicate transaction display
                        
                        // Show last 10 transactions
                        const recentTxs = result.slice(-10).reverse();
                        
                        recentTxs.forEach(function(tx) {
                            const txDiv = document.createElement('div');
                            txDiv.style.cssText = 'padding: 10px; border-bottom: 1px solid #e9ecef; font-size: 14px;';
                            
                            const txId = tx.tx_hash || tx.txid;
                            const height = tx.height;
                            
                            txDiv.innerHTML = `
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <div style="font-family: monospace; font-size: 12px; color: #666;">
                                            ${txId.substring(0, 8)}...${txId.substring(txId.length - 8)}
                                        </div>
                                        <div style="color: #999; font-size: 12px; margin-top: 2px;">
                                            ${height > 0 ? 'Block ' + height : 'Unconfirmed'}
                                            <span class="legacy-tx-timestamp" data-height="${height}" data-txid="${txId}"></span>
                                        </div>
                                    </div>
                                    <button class="small-button" onclick="navigator.clipboard.writeText('${txId}').then(() => alert('Transaction ID copied!'));" title="Copy transaction ID">
                                        Copy
                                    </button>
                                </div>
                            `;
                            
                            // transactionList.appendChild(txDiv); // Removed duplicate transaction display
                        });
                    } else {
                        // transactionList.innerHTML = '<p style="color: #999; text-align: center;">No transactions found</p>'; // Removed duplicate transaction display
                    }
                });
            }
            
            // Event listeners for RPC buttons
            connectRpcBtn.onclick = connectToElectrum;
            disconnectRpcBtn.onclick = disconnectFromElectrum;
            // refreshBalanceBtn.onclick = refreshBalance; // Removed duplicate balance display
            
            // Auto-connect to default endpoint on page load
            function tryAutoConnect() {
                const defaultEndpoint = 'wss://fulcrum.unicity.network:50004';
                
                // Only auto-connect if we're not already connected and the input has the default value
                if (!electrumConnected && rpcServerInput.value === defaultEndpoint) {
                    // Show a subtle notification that we're attempting to connect
                    connectionStatusDiv.style.display = 'block';
                    connectionStatusText.textContent = 'Auto-connecting to Unicity network...';
                    
                    // Attempt to connect silently
                    setTimeout(() => {
                        connectToElectrum(true); // Pass true for silent mode
                    }, 500); // Small delay to ensure UI is ready
                }
            }
            
            // Call auto-connect when page loads
            setTimeout(tryAutoConnect, 1000); // Wait 1 second after page load
            
            // Auto-refresh balance when address is generated
            const originalGenerateNewAddress = window.generateNewAddress;
            window.generateNewAddress = function() {
                originalGenerateNewAddress();
                if (electrumConnected) {
                    // Clear previous address data
                    currentTransactions = [];
                    currentUtxos = [];
                    // Reset pagination
                    currentTransactionPage = 1;
                    currentUtxoPage = 1;
                    updateTransactionHistory();
                    updateUtxoListDisplay();
                    
                    setTimeout(() => {
                        refreshBalance();
                        // Subscribe to the new address
                        if (wallet.addresses && wallet.addresses.length > 0) {
                            subscribeToAddressChanges(wallet.addresses[0].address);
                            // Reset initial load flag when address changes
                            isInitialLoad = true;
                            setTimeout(() => {
                                isInitialLoad = false;
                            }, 2000);
                        }
                    }, 500);
                }
            };
            
            // ===== UTXO EXPORT/IMPORT FUNCTIONALITY =====
            
            // Store for offline UTXO data
            // offlineUtxoData already declared at top
            // currentUtxos already declared at top
            // currentTransactions already declared at top
            let transactionDetailsCache = {}; // Cache for transaction details
            let isInitialLoad = true;  // Track if this is the first load
            
            // Pagination state
            const ITEMS_PER_PAGE = 20;
            // currentTransactionPage and currentUtxoPage already declared at top
            // lastUpdateBlockHeight, currentBlockHeight and currentBlockTime already declared at top
            let blockPollInterval = null;
            
            // Export button element
            const exportUtxoBtn = document.getElementById('exportUtxoBtn');
            // importUtxoBtn is declared at the top with other elements
            // clearUtxoBtn is declared at the top with other elements
            const utxoFileInput = document.getElementById('utxoFileInput');
            // const offlineBalanceDisplay = document.getElementById('offlineBalanceDisplay'); // Removed with Cold Wallet reorganization
            // const offlineBalanceAmount = document.getElementById('offlineBalanceAmount'); // Removed with Cold Wallet reorganization
            // const offlineDataTimestamp = document.getElementById('offlineDataTimestamp'); // Removed with Cold Wallet reorganization
            // const offlineUtxoList = document.getElementById('offlineUtxoList'); // Removed with Cold Wallet reorganization
            
            // Update watch-only mode based on wallet and connection state
            function updateWatchOnlyMode() {
                const hasWallet = wallet.masterPrivateKey || (wallet.addresses && wallet.addresses.length > 0);
                const shouldShowWatchOnly = !hasWallet && electrumConnected;
                const wasInWatchOnlyMode = watchOnlyMode;
                
                if (shouldShowWatchOnly) {
                    watchOnlySection.style.display = 'block';
                    walletInfo.style.display = 'none';
                    watchOnlyMode = true;
                    // Only clear data when actually switching TO watch-only mode from wallet mode
                    if (!wasInWatchOnlyMode) {
                        currentTransactions = [];
                        currentUtxos = [];
                        // Reset pagination
                        currentTransactionPage = 1;
                        currentUtxoPage = 1;
                        updateTransactionHistory();
                        updateUtxoListDisplay();
                    }
                } else if (hasWallet) {
                    watchOnlySection.style.display = 'none';
                    walletInfo.style.display = 'block';
                    watchOnlyMode = false;
                    watchOnlyAddressValue = null;
                    
                    // Clear watch-only data when switching to wallet mode
                    if (watchOnlyMode) {
                        currentTransactions = [];
                        currentUtxos = [];
                        // Reset pagination
                        currentTransactionPage = 1;
                        currentUtxoPage = 1;
                        updateTransactionHistory();
                        updateUtxoListDisplay();
                    }
                    
                    // Subscribe to wallet address if connected
                    if (electrumConnected && wallet.addresses && wallet.addresses.length > 0) {
                        subscribeToAddressChanges(wallet.addresses[0].address);
                    }
                } else {
                    // Not connected and no wallet
                    watchOnlySection.style.display = 'none';
                    walletInfo.style.display = 'none';
                    watchOnlyMode = false;
                    watchOnlyAddressValue = null;
                    
                    // Clear data
                    currentTransactions = [];
                    currentUtxos = [];
                    // Reset pagination
                    currentTransactionPage = 1;
                    currentUtxoPage = 1;
                    
                    // Unsubscribe if connected
                    if (electrumConnected) {
                        unsubscribeFromAddressChanges();
                    }
                }
            }
            
            // Handle watch-only address input
            watchOnlyAddress.addEventListener('input', function(e) {
                const address = e.target.value.trim();
                
                // Validate Bech32 address format
                if (address.startsWith('alpha1') && address.length > 10) {
                    // Debounce the input
                    clearTimeout(watchOnlyAddress.debounceTimer);
                    watchOnlyAddress.debounceTimer = setTimeout(() => {
                        // Validate address format properly
                        try {
                            const decoded = decodeBech32(address);
                            if (decoded) {
                                const oldAddress = watchOnlyAddressValue;
                                watchOnlyAddressValue = address;
                                refreshWatchOnlyBalance(address);
                                
                                // Update subscription if connected
                                if (electrumConnected && address !== oldAddress) {
                                    // Clear transaction history when address changes
                                    currentTransactions = [];
                                    currentUtxos = [];
                                    // Reset pagination
                                    currentTransactionPage = 1;
                                    currentUtxoPage = 1;
                                    // Update UI to clear the transaction list immediately
                                    updateTransactionHistory();
                                    updateUtxoListDisplay();
                                    
                                    // Subscribe to the new address
                                    subscribeToAddressChanges(address);
                                    // Reset initial load flag when address changes
                                    isInitialLoad = true;
                                    setTimeout(() => {
                                        isInitialLoad = false;
                                    }, 2000);
                                }
                                
                                // Show notification
                                showInAppNotification('Watch-Only Address Set', `Monitoring address: ${address.substring(0, 10)}...${address.substring(address.length - 6)}`, 'info');
                            }
                        } catch (err) {
                            console.log('Invalid address format:', err);
                            watchOnlyAddressValue = null;
                            watchOnlyBalance.textContent = 'Invalid address';
                            watchOnlyUnconfirmed.textContent = '';
                            currentUtxos = [];
                            updateUtxoListDisplay();
                        }
                    }, 500);
                } else if (address === '') {
                    watchOnlyAddressValue = null;
                    watchOnlyBalance.textContent = '-';
                    watchOnlyUnconfirmed.textContent = '';
                    currentUtxos = [];
                    currentTransactions = [];
                    // Reset pagination
                    currentTransactionPage = 1;
                    currentUtxoPage = 1;
                    updateUtxoListDisplay();
                    updateTransactionHistory();
                    
                    // Unsubscribe if connected
                    if (electrumConnected) {
                        unsubscribeFromAddressChanges();
                    }
                    
                    // Show notification
                    showInAppNotification('Watch-Only Cleared', 'Watch-only address has been cleared', 'info');
                }
            });
            
            // Refresh balance for watch-only address
            function refreshWatchOnlyBalance(address) {
                if (!address || !electrumConnected) return;
                
                const scriptHash = addressToScriptHash(address);
                if (!scriptHash) {
                    watchOnlyBalance.textContent = 'Invalid address';
                    watchOnlyUnconfirmed.textContent = '';
                    return;
                }
                
                // Fetch UTXOs
                electrumRequest('blockchain.scripthash.listunspent', [scriptHash], function(result) {
                    if (result !== null && result !== undefined) {
                        // Always update if UTXOs changed OR if we cleared them OR if result is empty
                        const shouldUpdate = hasArrayChanged(currentUtxos, result) || currentUtxos.length === 0 || result.length === 0;
                        if (shouldUpdate) {
                            // Add address to each UTXO
                            currentUtxos = result.map(utxo => ({
                                ...utxo,
                                address: address
                            }));
                            
                            // Calculate balances
                            let confirmed = 0;
                            let unconfirmed = 0;
                            
                            result.forEach(utxo => {
                                if (utxo.height > 0) {
                                    confirmed += utxo.value;
                                } else {
                                    unconfirmed += utxo.value;
                                }
                            });
                            
                            // Update display
                            watchOnlyBalance.textContent = (confirmed / 100000000).toFixed(8) + ' ALPHA';
                            if (unconfirmed > 0) {
                                watchOnlyUnconfirmed.textContent = '(' + (unconfirmed / 100000000).toFixed(8) + ')';
                            } else {
                                watchOnlyUnconfirmed.textContent = '';
                            }
                            
                            updateUtxoListDisplay();
                            updateCommonBalance(); // This will update Send button state
                        }
                        
                        // Also update UTXO list display after fetching UTXOs
                        updateUtxoListDisplay();
                    }
                });
                
                // Also fetch transaction history
                electrumRequest('blockchain.scripthash.get_history', [scriptHash], function(result) {
                    if (result !== null && result !== undefined) {
                        // Transaction history fetched successfully
                        // Analyze changes
                        const changes = analyzeTransactionChanges(currentTransactions, result);
                        
                        if (changes.hasChanged || currentTransactions.length === 0 || result.length === 0) {
                            // Update if changed OR if we have no transactions (after clearing) OR if result is empty
                            // Only show notifications if not initial load
                            if (!isInitialLoad && changes.newTransactions.length > 0) {
                                // Only show notifications for truly new unconfirmed transactions
                                // When a new tx arrives, we should only notify about that one
                                const unconfirmedNewTxs = changes.newTransactions.filter(tx => tx.height === 0);
                                
                                // If we have many new transactions, it's likely a data refresh issue
                                // Only notify if we have 1-2 new unconfirmed transactions
                                if (unconfirmedNewTxs.length <= 2) {
                                    unconfirmedNewTxs.forEach(tx => {
                                const txid = tx.tx_hash || tx.txid;
                                const shortTxid = txid.substring(0, 8) + '...' + txid.substring(txid.length - 8);
                                
                                // Fetch transaction details to determine direction
                                electrumRequest('blockchain.transaction.get', [txid, true], function(txDetails) {
                                    // Cache the transaction details
                                    if (txDetails) {
                                        transactionDetailsCache[txid] = txDetails;
                                    }
                                    
                                    let notificationTitle, notificationBody;
                                    
                                    if (txDetails && watchOnlyAddressValue) {
                                        const result = calculateTransactionAmount(txDetails, watchOnlyAddressValue);
                                        const amount = (Math.abs(result.netAmount) / 100000000).toFixed(8);
                                        
                                        if (result.isIncoming) {
                                            notificationTitle = tx.height === 0 ? 
                                                '💰 Incoming to Watched Address' : 
                                                '✅ Incoming Transaction Confirmed';
                                            notificationBody = `Received ${amount} ALPHA${tx.height > 0 ? ' in block ' + tx.height : ' (unconfirmed)'}`;
                                        } else {
                                            notificationTitle = tx.height === 0 ? 
                                                '📤 Outgoing from Watched Address' : 
                                                '✅ Outgoing Transaction Confirmed';
                                            notificationBody = `Sent ${amount} ALPHA${tx.height > 0 ? ' in block ' + tx.height : ' (unconfirmed)'}`;
                                        }
                                    } else {
                                        // Fallback if we can't get details
                                        notificationTitle = tx.height === 0 ? 
                                            '⚡ New Transaction (Watched)' : 
                                            '✓ Transaction Confirmed (Watched)';
                                        notificationBody = `Transaction ${shortTxid}${tx.height > 0 ? ' in block ' + tx.height : ' detected'}`;
                                    }
                                    
                                    showNotification(notificationTitle, notificationBody);
                                });
                                    });
                                }
                            }
                            
                            // Show notifications for newly confirmed transactions (always show these)
                            if (!isInitialLoad && changes.confirmedTransactions.length > 0) {
                                changes.confirmedTransactions.forEach(tx => {
                                const txid = tx.tx_hash || tx.txid;
                                const shortTxid = txid.substring(0, 8) + '...' + txid.substring(txid.length - 8);
                                
                                showNotification(
                                    '✅ Transaction Confirmed',
                                    `Transaction ${shortTxid} confirmed in block ${tx.height}`
                                );
                                });
                            }
                            
                            currentTransactions = result;
                            updateTransactionHistory();
                        }
                    }
                });
            }
            
            // Update common balance display
            // Get list of UTXOs consumed by pending or complete transactions in queue
            function getConsumedUtxos() {
                const consumedUtxos = new Set();
                
                broadcastQueue.forEach(item => {
                    // Only consider pending, broadcasting, and complete transactions
                    if (item.status === 'pending' || item.status === 'broadcasting' || item.status === 'complete') {
                        // Add the consumed UTXO to the set
                        if (item.tx.input) {
                            consumedUtxos.add(`${item.tx.input.txid}:${item.tx.input.vout}`);
                        }
                    }
                });
                
                return consumedUtxos;
            }
            
            function updateCommonBalance() {
                let confirmedBalance = 0;
                let unconfirmedBalance = 0;
                let utxoSource = 'none';
                let blockHeight = currentBlockHeight || lastUpdateBlockHeight;
                let lastUpdate = currentBlockTime;
                
                // Get consumed UTXOs
                const consumedUtxos = getConsumedUtxos();
                
                // Calculate balances from UTXOs
                if (currentUtxos && currentUtxos.length > 0) {
                    currentUtxos.forEach(utxo => {
                        const utxoKey = `${utxo.txid}:${utxo.vout}`;
                        // Only count UTXO if it's not consumed
                        if (!consumedUtxos.has(utxoKey)) {
                            if (utxo.height > 0) {
                                confirmedBalance += utxo.value;
                            } else {
                                unconfirmedBalance += utxo.value;
                            }
                        }
                    });
                    utxoSource = 'online';
                    lastUpdateBlockHeight = currentBlockHeight;
                    // Use block time if available, otherwise current time
                    if (!lastUpdate) {
                        lastUpdate = new Date();
                    }
                } else if (offlineUtxoData && offlineUtxoData.utxos && offlineUtxoData.utxos.length > 0) {
                    offlineUtxoData.utxos.forEach(utxo => {
                        const utxoKey = `${utxo.txid}:${utxo.vout}`;
                        // Only count UTXO if it's not consumed
                        if (!consumedUtxos.has(utxoKey)) {
                            if (utxo.height > 0) {
                                confirmedBalance += utxo.value;
                            } else {
                                unconfirmedBalance += utxo.value;
                            }
                        }
                    });
                    utxoSource = 'offline';
                    if (offlineUtxoData.blockHeight) {
                        lastUpdateBlockHeight = offlineUtxoData.blockHeight;
                        blockHeight = offlineUtxoData.blockHeight;
                    }
                    if (offlineUtxoData.timestamp) {
                        lastUpdate = new Date(offlineUtxoData.timestamp);
                    }
                }
                
                // Update wallet info display if it exists
                if (walletBalance) {
                    walletBalance.textContent = `${(confirmedBalance / 100000000).toFixed(8)} ALPHA`;
                }
                if (walletUnconfirmed) {
                    if (unconfirmedBalance > 0) {
                        walletUnconfirmed.style.display = 'inline';
                        walletUnconfirmed.textContent = `(${(unconfirmedBalance / 100000000).toFixed(8)})`;
                    } else {
                        walletUnconfirmed.style.display = 'none';
                    }
                }
                
                // Update total balance in scanned wallets if current address balance changed
                if (lastScannedWalletData && lastScannedWalletData.wallets && wallet && wallet.addresses && wallet.addresses.length > 0) {
                    const currentAddress = wallet.addresses[0].address;
                    const totalBalance = confirmedBalance + unconfirmedBalance;
                    
                    // Find and update the current wallet in scanned wallets
                    let walletUpdated = false;
                    let walletIndex = -1;
                    lastScannedWalletData.wallets.forEach((w, idx) => {
                        if (w.address === currentAddress) {
                            const oldBalance = w.balance || 0;
                            if (oldBalance !== totalBalance) {
                                w.balance = totalBalance;
                                walletUpdated = true;
                                walletIndex = idx;
                            }
                        }
                    });
                    
                    if (walletUpdated) {
                        // Recalculate total balance by summing all individual balances
                        let newTotalBalance = 0;
                        lastScannedWalletData.wallets.forEach((w, idx) => {
                            if (w.balance > 0) {
                                newTotalBalance += w.balance;
                            }
                        });
                        const oldTotal = lastScannedWalletData.totalBalance || 0;
                        lastScannedWalletData.totalBalance = newTotalBalance;
                        
                        // Update cache only if we have master keys
                        if (lastScannedWalletData.masterKey) {
                            const fingerprint = generateWalletFingerprint(
                                lastScannedWalletData.masterKey,
                                lastScannedWalletData.masterChainCode
                            );
                            if (fingerprint) {
                                saveScanResultsToCache(fingerprint, lastScannedWalletData);
                            }
                        } else {
                            console.log('Cannot update cache: missing master key');
                        }
                        
                        // Update display
                        updateScannedWalletsDisplay();
                    }
                }
                
                // Update last update time
                if (lastUpdateTime) {
                    if (blockHeight && lastUpdate) {
                        lastUpdateTime.textContent = `Block #${blockHeight} at ${lastUpdate.toLocaleString()}`;
                    } else if (blockHeight) {
                        lastUpdateTime.textContent = `Block #${blockHeight}`;
                    } else if (lastUpdate) {
                        lastUpdateTime.textContent = lastUpdate.toLocaleString();
                    } else {
                        lastUpdateTime.textContent = '-';
                    }
                }
                
                // Update old balance display elements for backwards compatibility
                const totalBalanceEl = document.getElementById('totalBalance');
                if (totalBalanceEl) {
                    totalBalanceEl.textContent = ((confirmedBalance + unconfirmedBalance) / 100000000).toFixed(8);
                }
                
                const lastUpdateBlockEl = document.getElementById('lastUpdateBlock');
                if (lastUpdateBlockEl) {
                    if (lastUpdateBlockHeight) {
                        lastUpdateBlockEl.textContent = `Block ${lastUpdateBlockHeight}`;
                    } else {
                        lastUpdateBlockEl.textContent = 'Never';
                    }
                }
                
                const currentBlockHeightEl = document.getElementById('currentBlockHeight');
                if (currentBlockHeightEl && blockHeight) {
                    currentBlockHeightEl.textContent = blockHeight;
                }
                
                // Update import button state based on connection
                if (importUtxoBtn) {
                    importUtxoBtn.disabled = electrumConnected;
                    if (electrumConnected) {
                        importUtxoBtn.title = "UTXO imports are disabled while connected to Fulcrum";
                    } else {
                        importUtxoBtn.title = "Import UTXO data from file";
                    }
                }
                
                // Update import & broadcast button state based on connection
                const importBroadcastBtn = document.getElementById('importBroadcastBtn');
                if (importBroadcastBtn) {
                    importBroadcastBtn.disabled = !electrumConnected;
                    if (electrumConnected) {
                        importBroadcastBtn.title = "Import and broadcast signed transactions";
                    } else {
                        importBroadcastBtn.title = "Connect to Fulcrum to broadcast transactions";
                    }
                }
                
                // Update Send button state based on available UTXOs, wallet state, and watch-only mode
                if (sendTransactionBtn) {
                    const hasUtxos = (currentUtxos && currentUtxos.length > 0) || 
                                   (offlineUtxoData && offlineUtxoData.utxos && offlineUtxoData.utxos.length > 0);
                    
                    const hasWallet = wallet.addresses && wallet.addresses.length > 0;
                    
                    // Disable if no UTXOs, or if in watch-only mode without UTXOs, or if no wallet and not watch-only
                    sendTransactionBtn.disabled = !hasUtxos || (!hasWallet && !watchOnlyMode);
                    
                    if (!hasWallet && !watchOnlyMode) {
                        sendTransactionBtn.title = "Please load a wallet or use watch-only mode";
                    } else if (watchOnlyMode && hasUtxos) {
                        sendTransactionBtn.title = "Prepare transaction for offline signing";
                    } else if (hasUtxos) {
                        sendTransactionBtn.title = "Send Alpha to another address";
                    } else {
                        sendTransactionBtn.title = "No UTXOs available to spend";
                    }
                }
                
                // Handle watch-only mode visibility
                updateWatchOnlyMode();
            }
            
            // Format transaction for display
            function formatTransactionDisplay(tx, ourAddress, confirmations, txDetails) {
                const txid = tx.tx_hash || tx.txid || tx.id;
                const truncatedTxid = txid.substring(0, 6) + '...' + txid.substring(txid.length - 6);
                const txLink = `https://www.unicity.network/tx/${txid}`;
                
                const txDiv = document.createElement('div');
                txDiv.style.cssText = 'padding: 15px; border-bottom: 1px solid #e9ecef; font-size: 14px;';
                txDiv.setAttribute('data-txid', txid);
                
                let statusColor = confirmations > 0 ? '#34d399' : '#fbbf24';
                let statusText = confirmations > 0 ? `${confirmations} confirmations` : 'Unconfirmed';
                
                // Check if we're still loading transaction details
                const isLoading = !txDetails;
                
                // Default display while loading
                let isIncoming = true;
                let amount = '0.00000000';
                let destinations = [];
                let senderAddress = null;
                let directionText = 'Loading...';
                let directionColor = '#9ca3af'; // Gray color for loading
                let amountColor = '#9ca3af';
                let amountSign = '';
                
                if (!isLoading) {
                    // Calculate net amount and direction from full transaction details
                    const result = calculateTransactionAmount(txDetails, ourAddress);
                    isIncoming = result.isIncoming;
                    amount = (Math.abs(result.netAmount) / 100000000).toFixed(8);
                    destinations = result.destinations;
                    senderAddress = result.senderAddress;
                    
                    // Set direction text and colors based on transaction type
                    if (!ourAddress) {
                        // No wallet loaded - show neutral transaction
                        directionText = '→ Transaction';
                        directionColor = '#6b7280';
                        amountColor = '#333';
                        amountSign = '';
                    } else {
                        directionText = isIncoming ? '↓ Received' : '↑ Sent';
                        directionColor = isIncoming ? '#34d399' : '#ef4444';
                        amountColor = isIncoming ? '#34d399' : '#333';
                        amountSign = isIncoming ? '+' : '-';
                    }
                }
                
                let addressHtml = '';
                if (isLoading) {
                    // Show loading state for address
                    addressHtml = '<div style="margin-top: 5px; font-size: 12px; color: #9ca3af;">Loading...</div>';
                } else {
                    // Always show From address if available
                    let fromAddresses = txDetails._fromAddresses || [];
                    if (fromAddresses.length > 0) {
                        // Remove duplicates
                        fromAddresses = [...new Set(fromAddresses)];
                        
                        addressHtml += '<div style="margin-top: 5px; font-size: 12px; color: #666;">From: ';
                        fromAddresses.forEach((addr, idx) => {
                            if (idx > 0) addressHtml += ', ';
                            const truncAddr = addr.substring(0, 11) + '...' + addr.substring(addr.length - 6);
                            addressHtml += `<a href="https://www.unicity.network/address/${addr}" target="_blank" style="color: #3b82f6; text-decoration: none;">${truncAddr}</a>`;
                        });
                        addressHtml += '</div>';
                    }
                    
                    // For incoming transactions, show sender
                    if (isIncoming && senderAddress && fromAddresses.length === 0) {
                        const truncAddr = senderAddress.substring(0, 11) + '...' + senderAddress.substring(senderAddress.length - 6);
                        addressHtml += `<div style="margin-top: 5px; font-size: 12px; color: #666;">From: <a href="https://www.unicity.network/address/${senderAddress}" target="_blank" style="color: #3b82f6; text-decoration: none;">${truncAddr}</a></div>`;
                    }
                    
                    // Show destinations
                    if (destinations.length > 0) {
                        // If no wallet is loaded (ourAddress is null), show all destinations
                        // Otherwise, only show destinations for outgoing transactions
                        if (!ourAddress || !isIncoming) {
                            addressHtml += '<div style="margin-top: 5px; font-size: 12px; color: #666;">To: ';
                            destinations.forEach((dest, idx) => {
                                if (idx > 0) addressHtml += ', ';
                                const truncAddr = dest.address.substring(0, 11) + '...' + dest.address.substring(dest.address.length - 6);
                                addressHtml += `<a href="https://www.unicity.network/address/${dest.address}" target="_blank" style="color: #3b82f6; text-decoration: none;">${truncAddr}</a>`;
                            });
                            addressHtml += '</div>';
                        }
                    }
                }
                
                txDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: start;">
                        <div style="flex: 1;">
                            <div style="display: flex; align-items: center; margin-bottom: 5px;">
                                <span style="color: ${directionColor}; font-weight: bold; margin-right: 10px;">
                                    ${directionText}
                                </span>
                                <a href="${txLink}" target="_blank" style="font-family: monospace; font-size: 12px; color: #3b82f6; text-decoration: none;">
                                    ${truncatedTxid}
                                </a>
                            </div>
                            <div style="color: #666; font-size: 12px;">
                                <span style="color: ${statusColor};">${statusText}</span>
                                ${tx.height > 0 ? ` • Block ${tx.height}` : ''}
                                <span class="block-timestamp" data-height="${tx.height}"></span>
                            </div>
                            ${addressHtml}
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 16px; font-weight: bold; color: ${amountColor};">
                                ${amountSign}${amount} ALPHA
                            </div>
                        </div>
                    </div>
                `;
                
                return txDiv;
            }
            
            // Calculate transaction amount and determine if incoming/outgoing
            function calculateTransactionAmount(txDetails, ourAddress) {
                let inputAmount = 0;
                let outputAmount = 0;
                let isOurInput = false;
                let destinations = [];
                let ourOutputs = [];
                let senderAddress = null;
                let fromAddresses = [];
                
                // Normalize our address to lowercase for comparison
                const ourAddressLower = ourAddress ? ourAddress.toLowerCase() : null;
                
                // Get all wallet addresses for comparison (to identify change outputs)
                const allOurAddresses = new Set();
                if (ourAddressLower) {
                    allOurAddresses.add(ourAddressLower);
                }
                if (wallet && wallet.addresses) {
                    wallet.addresses.forEach(addr => {
                        if (addr.address) {
                            allOurAddresses.add(addr.address.toLowerCase());
                        }
                    });
                }
                
                // If this is an imported Alpha wallet, also check first 20 change addresses
                if (wallet && wallet.isImportedAlphaWallet && wallet.masterPrivateKey && wallet.masterChainCode) {
                    for (let i = 0; i < 20; i++) {
                        const changeAddr = deriveAddressAtIndex(
                            wallet.masterPrivateKey,
                            wallet.masterChainCode,
                            i,
                            true, // isAlphaWallet
                            true  // isChange
                        );
                        allOurAddresses.add(changeAddr.address.toLowerCase());
                    }
                }
                
                // Debug logging
                const txid = txDetails.txid || txDetails.id || 'unknown';
                
                // Check if sender address was already fetched and passed in
                if (txDetails._senderAddress) {
                    senderAddress = txDetails._senderAddress;
                }
                if (txDetails._fromAddresses) {
                    fromAddresses = txDetails._fromAddresses;
                }
                
                // First check all outputs to see what we received
                if (txDetails.vout) {
                    txDetails.vout.forEach((output, index) => {
                        const value = output.value * 100000000; // Convert to satoshis
                        
                        if (output.scriptPubKey) {
                            // Extract address from various possible fields
                            let outputAddress = null;
                            
                            // Check multiple possible locations for the address
                            if (output.scriptPubKey.addresses && output.scriptPubKey.addresses.length > 0) {
                                outputAddress = output.scriptPubKey.addresses[0];
                            } else if (output.scriptPubKey.address) {
                                outputAddress = output.scriptPubKey.address;
                            }
                            
                            // If no address found, try to decode from hex (for SegWit outputs)
                            if (!outputAddress && output.scriptPubKey.hex) {
                                // Log the scriptPubKey structure for debugging
                                
                                // Try to decode SegWit address from hex
                                // SegWit v0 P2WPKH starts with 0014 (OP_0 + 20 bytes)
                                if (output.scriptPubKey.hex.startsWith('0014') && output.scriptPubKey.hex.length === 44) {
                                    const witnessProgramHex = output.scriptPubKey.hex.substring(4);
                                    const witnessProgram = [];
                                    for (let i = 0; i < witnessProgramHex.length; i += 2) {
                                        witnessProgram.push(parseInt(witnessProgramHex.substr(i, 2), 16));
                                    }
                                    // Convert to bech32 address
                                    outputAddress = createBech32('alpha', [0].concat(convertBits(witnessProgram, 8, 5, true)));
                                }
                            }
                            
                            if (outputAddress) {
                                const isOurs = allOurAddresses.has(outputAddress.toLowerCase());
                                
                                // Debug: log only our outputs
                                if (isOurs) {
                                    console.log(`  Output ${index} is OURS: ${outputAddress}`);
                                }
                                
                                if (isOurs) {
                                    outputAmount += value;
                                    ourOutputs.push({vout: index, value: value, address: outputAddress});
                                } else {
                                    // Track destination addresses for outgoing transactions
                                    destinations.push({address: outputAddress, value: value});
                                }
                                
                                // If no wallet is loaded, all outputs are destinations
                                if (allOurAddresses.size === 0) {
                                    destinations.push({address: outputAddress, value: value});
                                }
                            } else {
                            }
                        }
                    });
                }
                
                // Check if any inputs are spending from our address
                // We need to check both current UTXOs and historical transactions
                if (txDetails.vin) {
                    txDetails.vin.forEach(input => {
                        const prevTxid = input.txid;
                        const prevVout = input.vout;
                        
                        // First check current UTXOs
                        if (currentUtxos) {
                            const matchingUtxo = currentUtxos.find(utxo => 
                                utxo.tx_hash.toLowerCase() === prevTxid.toLowerCase() && utxo.tx_pos === prevVout
                            );
                            
                            if (matchingUtxo) {
                                isOurInput = true;
                                inputAmount += matchingUtxo.value;
                                return; // Found it, continue to next input
                            }
                        }
                        
                        // Also check offline UTXO data if available
                        if (offlineUtxoData && offlineUtxoData.utxos) {
                            const matchingUtxo = offlineUtxoData.utxos.find(utxo => 
                                utxo.tx_hash.toLowerCase() === prevTxid.toLowerCase() && utxo.tx_pos === prevVout
                            );
                            
                            if (matchingUtxo) {
                                isOurInput = true;
                                inputAmount += matchingUtxo.value;
                                return; // Found it, continue to next input
                            }
                        }
                        
                        // If not in current UTXOs, we need to check if this specific output was ours
                        // by fetching the previous transaction details
                        if (transactionDetailsCache[prevTxid]) {
                            // We already have the transaction details cached
                            const prevTxDetails = transactionDetailsCache[prevTxid];
                            if (prevTxDetails && prevTxDetails.vout && prevTxDetails.vout[prevVout]) {
                                const prevOutput = prevTxDetails.vout[prevVout];
                                
                                // Extract address from the previous output
                                let prevOutputAddress = null;
                                if (prevOutput.scriptPubKey) {
                                    if (prevOutput.scriptPubKey.addresses && prevOutput.scriptPubKey.addresses.length > 0) {
                                        prevOutputAddress = prevOutput.scriptPubKey.addresses[0];
                                    } else if (prevOutput.scriptPubKey.address) {
                                        prevOutputAddress = prevOutput.scriptPubKey.address;
                                    }
                                }
                                
                                if (prevOutputAddress && allOurAddresses.has(prevOutputAddress.toLowerCase())) {
                                    isOurInput = true;
                                    inputAmount += prevOutput.value * 100000000; // Convert to satoshis
                                }
                            }
                        } else if (currentTransactions) {
                            // Check if this transaction is in our history
                            const prevTx = currentTransactions.find(tx => 
                                ((tx.tx_hash || tx.txid) || '').toLowerCase() === prevTxid.toLowerCase()
                            );
                            
                            if (prevTx) {
                                // Transaction is in our history, but we need to fetch details to check the specific output
                                // Note: We can't determine ownership without fetching the transaction
                                // This will be handled asynchronously later
                            }
                        }
                    });
                    
                    // If we identified this as our input but don't have the amount,
                    // we'll handle this case later in the logic
                    // Don't estimate input amounts as it leads to incorrect transaction classification
                }
                
                // Determine transaction type and calculate net amount
                let isIncoming = false;
                let netAmount = 0;
                
                // If no wallet is loaded (ourAddressLower is null), show all transactions as neutral
                if (!ourAddressLower) {
                    // No wallet loaded - can't determine direction
                    isIncoming = false; // Default to false for neutral display
                    // Sum all outputs as the transaction amount
                    let totalOutput = 0;
                    destinations.forEach(dest => {
                        totalOutput += dest.value;
                    });
                    netAmount = totalOutput;
                } else {
                    // Simple logic based on your rules:
                    // 1. If ANY input is from our address -> OUTBOUND transaction
                    // 2. If NO inputs are from our address -> INBOUND transaction
                    
                    if (isOurInput) {
                        // OUTBOUND transaction
                        isIncoming = false;
                        
                        // For outbound transactions, we want to show the amount sent to others
                        // (excluding change back to ourselves)
                        let sentToOthers = 0;
                        destinations.forEach(dest => {
                            sentToOthers += dest.value;
                        });
                        
                        // Debug logging
                        if (ourOutputs.length > 0) {
                            console.log(`  - Our change addresses:`, ourOutputs.map(o => o.address));
                        }
                        
                        // If we have destinations (outputs to other addresses), use that amount
                        // Otherwise, if all outputs went back to us (rare case), calculate total spent
                        if (sentToOthers > 0) {
                            netAmount = sentToOthers;
                            console.log(`  - Using sent to others as netAmount: ${netAmount} satoshis`);
                        } else if (inputAmount > 0) {
                            // Rare case: all outputs are back to us (maybe a consolidation transaction)
                            // Show the fee amount (input - output)
                            netAmount = inputAmount - outputAmount;
                            console.log(`  - All outputs back to us, showing fee: ${netAmount} satoshis`);
                        } else {
                            // Fallback: we couldn't determine the exact amount
                            netAmount = 0;
                            console.log(`  - Could not determine amount, using 0`);
                        }
                    } else {
                        // INBOUND transaction
                        isIncoming = true;
                        netAmount = outputAmount; // Sum of all outputs to our address
                    }
                }
                
                // Validation: If we found no outputs to our address and no inputs from our address,
                // this transaction shouldn't be in our history
                if (outputAmount === 0 && !isOurInput) {
                    console.error(`  ERROR: Transaction ${txid} has no relation to our address ${ourAddress}`);
                    console.error(`  This should not happen - transaction history should only contain our transactions`);
                }
                
                
                // Check if sender address was provided via _senderAddress field
                if (!senderAddress && txDetails._senderAddress) {
                    senderAddress = txDetails._senderAddress;
                }
                
                return {
                    isIncoming,
                    netAmount: Math.abs(netAmount),
                    destinations,
                    senderAddress,
                    fromAddresses
                };
            }
            
            // Update transaction history display
            // Collect all transactions that need to be fetched
            function collectRequiredTransactions(transactions) {
                const requiredTxIds = new Set();
                
                // Add all transaction IDs
                transactions.forEach(tx => {
                    const txid = tx.tx_hash || tx.txid;
                    requiredTxIds.add(txid);
                });
                
                // Also collect all input transactions we might need
                transactions.forEach(tx => {
                    const txid = tx.tx_hash || tx.txid;
                    if (transactionDetailsCache[txid] && transactionDetailsCache[txid].vin) {
                        transactionDetailsCache[txid].vin.forEach(input => {
                            if (input.txid) {
                                requiredTxIds.add(input.txid);
                            }
                        });
                    }
                });
                
                return Array.from(requiredTxIds);
            }
            
            // Fetch all required transaction details
            function fetchAllTransactionDetails(txIds, callback) {
                let pending = txIds.length;
                let completed = 0;
                
                if (pending === 0) {
                    callback();
                    return;
                }
                
                txIds.forEach(txid => {
                    if (transactionDetailsCache[txid]) {
                        // Already cached
                        completed++;
                        if (completed === pending) {
                            callback();
                        }
                    } else {
                        // Fetch transaction details
                        electrumRequest('blockchain.transaction.get', [txid, true], function(txDetails) {
                            if (txDetails) {
                                transactionDetailsCache[txid] = txDetails;
                            }
                            completed++;
                            if (completed === pending) {
                                callback();
                            }
                        });
                    }
                });
            }
            
            function updateTransactionHistory() {
                if (!electrumConnected || !currentTransactions || currentTransactions.length === 0) {
                    document.getElementById('transactionHistoryContainer').style.display = 'none';
                    return;
                }
                
                document.getElementById('transactionHistoryContainer').style.display = 'block';
                const historyList = document.getElementById('transactionHistoryList');
                historyList.innerHTML = '';
                
                // Sort by height (most recent first)
                const sortedTxs = [...currentTransactions].sort((a, b) => {
                    if (a.height === 0 && b.height === 0) return 0;
                    if (a.height === 0) return -1;
                    if (b.height === 0) return 1;
                    return b.height - a.height;
                });
                
                // Calculate pagination
                const totalPages = Math.ceil(sortedTxs.length / ITEMS_PER_PAGE);
                const startIndex = (currentTransactionPage - 1) * ITEMS_PER_PAGE;
                const endIndex = startIndex + ITEMS_PER_PAGE;
                const pageTxs = sortedTxs.slice(startIndex, endIndex);
                
                const currentHeight = currentBlockHeight || 0;
                const ourAddress = watchOnlyMode && watchOnlyAddressValue ? 
                    watchOnlyAddressValue : 
                    (wallet.addresses && wallet.addresses.length > 0 ? wallet.addresses[0].address : null);
                
                if (!ourAddress) return;
                
                // First, display all transactions with loading state
                pageTxs.forEach(tx => {
                    const confirmations = tx.height > 0 ? Math.max(0, currentHeight - tx.height + 1) : 0;
                    const txElement = formatTransactionDisplay(tx, ourAddress, confirmations, null);
                    historyList.appendChild(txElement);
                });
                
                // Add pagination controls
                if (totalPages > 1) {
                    const paginationDiv = document.createElement('div');
                    paginationDiv.style.cssText = 'display: flex; justify-content: center; align-items: center; gap: 10px; margin-top: 15px; padding-top: 15px; border-top: 1px solid #e9ecef;';
                    
                    // Previous button
                    const prevBtn = document.createElement('button');
                    prevBtn.textContent = '← Previous';
                    prevBtn.style.cssText = 'padding: 5px 10px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer; font-size: 12px;';
                    prevBtn.disabled = currentTransactionPage === 1;
                    prevBtn.onclick = () => {
                        if (currentTransactionPage > 1) {
                            currentTransactionPage--;
                            updateTransactionHistory();
                        }
                    };
                    
                    // Page info
                    const pageInfo = document.createElement('span');
                    pageInfo.textContent = `Page ${currentTransactionPage} of ${totalPages} (${sortedTxs.length} total)`;
                    pageInfo.style.cssText = 'font-size: 12px; color: #666;';
                    
                    // Next button
                    const nextBtn = document.createElement('button');
                    nextBtn.textContent = 'Next →';
                    nextBtn.style.cssText = 'padding: 5px 10px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer; font-size: 12px;';
                    nextBtn.disabled = currentTransactionPage === totalPages;
                    nextBtn.onclick = () => {
                        if (currentTransactionPage < totalPages) {
                            currentTransactionPage++;
                            updateTransactionHistory();
                        }
                    };
                    
                    paginationDiv.appendChild(prevBtn);
                    paginationDiv.appendChild(pageInfo);
                    paginationDiv.appendChild(nextBtn);
                    historyList.appendChild(paginationDiv);
                }
                
                // Collect all transaction IDs we need to fetch
                const txIdsToFetch = pageTxs.map(tx => tx.tx_hash || tx.txid);
                
                // First round: fetch all main transactions
                fetchAllTransactionDetails(txIdsToFetch, function() {
                    // Now collect all input transactions we need
                    const inputTxIds = new Set();
                    
                    pageTxs.forEach(tx => {
                        const txid = tx.tx_hash || tx.txid;
                        const txDetails = transactionDetailsCache[txid];
                        if (txDetails && txDetails.vin) {
                            txDetails.vin.forEach(input => {
                                if (input.txid) {
                                    inputTxIds.add(input.txid);
                                }
                            });
                        }
                    });
                    
                    // Second round: fetch all input transactions
                    fetchAllTransactionDetails(Array.from(inputTxIds), function() {
                        // Now update all transactions with complete details
                        pageTxs.forEach(tx => {
                            const confirmations = tx.height > 0 ? Math.max(0, currentHeight - tx.height + 1) : 0;
                            const txid = tx.tx_hash || tx.txid;
                            const txDetails = transactionDetailsCache[txid];
                            
                            if (txDetails) {
                                // Check if this is an incoming transaction and get sender address
                                const result = calculateTransactionAmount(txDetails, ourAddress);
                                
                                // Always try to get sender addresses for all transactions
                                if (txDetails.vin && txDetails.vin.length > 0) {
                                    const fromAddresses = [];
                                    
                                    // Collect all sender addresses
                                    txDetails.vin.forEach(input => {
                                        const prevTxid = input.txid;
                                        const prevVout = input.vout;
                                        const prevTxDetails = transactionDetailsCache[prevTxid];
                                        
                                        if (prevTxDetails && prevTxDetails.vout && prevTxDetails.vout[prevVout]) {
                                            const prevOutput = prevTxDetails.vout[prevVout];
                                            if (prevOutput.scriptPubKey) {
                                                let address = null;
                                                if (prevOutput.scriptPubKey.addresses && prevOutput.scriptPubKey.addresses.length > 0) {
                                                    address = prevOutput.scriptPubKey.addresses[0];
                                                } else if (prevOutput.scriptPubKey.address) {
                                                    address = prevOutput.scriptPubKey.address;
                                                }
                                                if (address) {
                                                    fromAddresses.push(address);
                                                }
                                            }
                                        }
                                    });
                                    
                                    // For incoming transactions, set the first sender as the main sender
                                    if (result.isIncoming && fromAddresses.length > 0) {
                                        result.senderAddress = fromAddresses[0];
                                    }
                                    
                                    // Update with sender info
                                    const txDetailsWithSender = Object.assign({}, txDetails, {
                                        _senderAddress: result.senderAddress,
                                        _fromAddresses: fromAddresses
                                    });
                                    const updatedElement = formatTransactionDisplay(tx, ourAddress, confirmations, txDetailsWithSender);
                                    const oldElement = historyList.querySelector(`[data-txid="${txid}"]`);
                                    if (oldElement) {
                                        oldElement.replaceWith(updatedElement);
                                    }
                                } else {
                                    // Update the element with full details
                                    const updatedElement = formatTransactionDisplay(tx, ourAddress, confirmations, txDetails);
                                    const oldElement = historyList.querySelector(`[data-txid="${txid}"]`);
                                    if (oldElement) {
                                        oldElement.replaceWith(updatedElement);
                                    }
                                }
                                
                                // Fetch and display block timestamp
                                if (tx.height > 0) {
                                    getBlockTimestamp(tx.height, function(timestamp) {
                                        const timestampElement = historyList.querySelector(`[data-txid="${txid}"] .block-timestamp`);
                                        if (timestampElement && timestamp) {
                                            timestampElement.textContent = ` • ${formatBlockTimestamp(timestamp)}`;
                                        }
                                    });
                                }
                            }
                        });
                    });
                });
            }
            
            // Cache for block timestamps
            const blockTimestampCache = {};
            
            // Get block timestamp
            function getBlockTimestamp(height, callback) {
                if (!height || height <= 0) {
                    callback(null);
                    return;
                }
                
                // Check cache first
                if (blockTimestampCache[height]) {
                    callback(blockTimestampCache[height]);
                    return;
                }
                
                // Fetch block header
                electrumRequest('blockchain.block.header', [height], function(header) {
                    if (header) {
                        // Extract timestamp from block header (at bytes 68-71, little-endian)
                        const timestampHex = header.substring(136, 144);
                        const timestamp = parseInt(timestampHex.match(/../g).reverse().join(''), 16);
                        const date = new Date(timestamp * 1000);
                        blockTimestampCache[height] = date;
                        callback(date);
                    } else {
                        callback(null);
                    }
                });
            }
            
            // Format block timestamp for display
            function formatBlockTimestamp(date) {
                if (!date) return '';
                const options = { 
                    year: 'numeric', 
                    month: 'short', 
                    day: 'numeric', 
                    hour: '2-digit', 
                    minute: '2-digit',
                    hour12: false
                };
                return date.toLocaleString(undefined, options);
            }
            
            // Start polling for new blocks (reduced frequency since we have subscriptions)
            function startBlockPolling() {
                // Clear any existing interval
                if (blockPollInterval) {
                    clearInterval(blockPollInterval);
                }
                
                // Only poll as a backup every 5 minutes since we have real-time subscriptions
                blockPollInterval = setInterval(function() {
                    if (!electrumConnected) {
                        stopBlockPolling();
                        return;
                    }
                    
                    // This is now just a fallback check since we have subscriptions
                    console.log('Performing periodic connection health check...');
                    
                    // Simple ping to keep connection alive
                    electrumRequest('server.ping', [], function(result) {
                        console.log('Connection health check:', result !== null ? 'OK' : 'Failed');
                    });
                }, 300000); // 5 minutes - just for connection health
            }
            
            // Stop polling for blocks
            function stopBlockPolling() {
                if (blockPollInterval) {
                    clearInterval(blockPollInterval);
                    blockPollInterval = null;
                }
            }
            
            // Export UTXO data
            function exportUtxoData() {
                // Get address from either watch-only mode or regular wallet
                const address = watchOnlyMode && watchOnlyAddressValue ? 
                    watchOnlyAddressValue : 
                    (wallet.addresses && wallet.addresses.length > 0 ? wallet.addresses[0].address : null);
                
                if (!address) {
                    alert('No wallet address available');
                    return;
                }
                
                if (!electrumConnected) {
                    alert('Please connect to Fulcrum server first to fetch UTXO data');
                    return;
                }
                
                const scriptHash = addressToScriptHash(address);
                
                if (!scriptHash) {
                    alert('Failed to convert address to script hash');
                    return;
                }
                
                // First get the current block height
                electrumRequest('blockchain.headers.subscribe', [], function(headerInfo, error) {
                    if (error) {
                        console.error('Failed to get block height:', error);
                        // Continue without block height
                        fetchAndExportUtxos(null);
                        return;
                    }
                    
                    const blockHeight = headerInfo ? (headerInfo.height || headerInfo.block_height) : null;
                    fetchAndExportUtxos(blockHeight);
                });
                
                function fetchAndExportUtxos(blockHeight) {
                    // Fetch UTXOs
                    electrumRequest('blockchain.scripthash.listunspent', [scriptHash], function(utxos, error) {
                        if (error) {
                            showInAppNotification('Export Failed', 'Failed to fetch UTXOs: ' + error.message, 'error');
                            return;
                        }
                        
                        // Create export data with blockchain state info
                        const exportData = {
                            version: '1.1',
                            network: 'alpha',
                            address: address,
                            scriptHash: scriptHash,
                            blockchain: {
                                height: blockHeight,
                                timestamp: new Date().toISOString(),
                                exportDate: new Date().toLocaleDateString() + ' ' + new Date().toLocaleTimeString()
                            },
                            utxos: (utxos || []).map(utxo => ({
                                ...utxo,
                                address: address
                            })),
                            transactions: currentTransactions.slice(0, 20), // Last 20 transactions
                            metadata: {
                                walletVersion: '1.0.0',
                                exportedFrom: window.location.hostname || 'offline-wallet',
                                utxoCount: (utxos || []).length,
                                totalValue: (utxos || []).reduce((sum, utxo) => sum + (utxo.value || 0), 0)
                            }
                        };
                        
                        // Convert to JSON with nice formatting
                        const jsonData = JSON.stringify(exportData, null, 2);
                        
                        // Create download with block height in filename
                        const blob = new Blob([jsonData], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        const blockStr = blockHeight ? `_block${blockHeight}` : '';
                        a.download = `utxo_${address.substring(0, 10)}${blockStr}_${Date.now()}.json`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        
                        const blockInfo = blockHeight ? ` at block ${blockHeight}` : '';
                        showInAppNotification('Export Successful', `UTXO data exported${blockInfo}`, 'success');
                    });
                }
            }
            
            // Export transaction template for watch-only mode
            function exportTransactionTemplate(transactions, recipientAddress, totalAmount, senderAddress) {
                // Get current block height if connected
                if (electrumConnected) {
                    electrumRequest('blockchain.headers.subscribe', [], function(headerInfo, error) {
                        const blockHeight = headerInfo ? (headerInfo.height || headerInfo.block_height) : null;
                        createAndExportTemplate(blockHeight);
                    });
                } else {
                    createAndExportTemplate(null);
                }
                
                function createAndExportTemplate(blockHeight) {
                    // Collect only the UTXOs that will be spent
                    const spentUtxos = transactions.map(tx => tx.input);
                    
                    // Create export data with transaction templates
                    const exportData = {
                        version: '1.2',
                        network: 'alpha',
                        address: senderAddress,
                        scriptHash: addressToScriptHash(senderAddress),
                        blockchain: {
                            height: blockHeight,
                            timestamp: new Date().toISOString(),
                            exportDate: new Date().toLocaleDateString() + ' ' + new Date().toLocaleTimeString()
                        },
                        utxos: spentUtxos,
                        transactionTemplates: transactions.map((tx, index) => ({
                            index: index,
                            inputs: [tx.input],
                            outputs: tx.outputs,
                            fee: tx.fee,
                            changeAmount: tx.changeAmount,
                            changeAddress: tx.changeAddress
                        })),
                        metadata: {
                            walletVersion: '1.0.0',
                            exportedFrom: window.location.hostname || 'offline-wallet',
                            utxoCount: spentUtxos.length,
                            totalValue: spentUtxos.reduce((sum, utxo) => sum + (utxo.value || 0), 0),
                            recipientAddress: recipientAddress,
                            sendAmount: totalAmount,
                            exportType: 'transaction_template'
                        }
                    };
                    
                    // Convert to JSON with nice formatting
                    const jsonData = JSON.stringify(exportData, null, 2);
                    
                    // Create download with descriptive filename
                    const blob = new Blob([jsonData], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                    a.download = `alpha_tx_template_${totalAmount}ALPHA_${timestamp}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    showInAppNotification('Transaction Template Exported', `Exported template to send ${totalAmount} ALPHA to ${recipientAddress.substring(0, 10)}...`, 'success');
                }
            }
            
            // Import UTXO data
            function importUtxoData() {
                if (electrumConnected) {
                    alert('UTXO imports are disabled while connected to Fulcrum server');
                    return;
                }
                utxoFileInput.click();
            }
            
            // Handle file selection for import
            utxoFileInput.onchange = function(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = JSON.parse(e.target.result);
                        
                        // Validate data structure (require new format)
                        if (!data.version || !data.address || !data.utxos || !data.blockchain) {
                            throw new Error('Invalid UTXO data format. Please export fresh data from an online session.');
                        }
                        
                        // Check if address matches current wallet
                        if (wallet.addresses && wallet.addresses.length > 0) {
                            if (data.address.toLowerCase() !== wallet.addresses[0].address.toLowerCase()) {
                                const confirmImport = confirm(
                                    'Warning: The imported data is for a different address.\n\n' +
                                    'Imported: ' + data.address + '\n' +
                                    'Current: ' + wallet.addresses[0].address + '\n\n' +
                                    'Do you want to continue?'
                                );
                                if (!confirmImport) return;
                            }
                        }
                        
                        // Check block height freshness
                        if (lastUpdateBlockHeight && data.blockchain && data.blockchain.height && 
                            data.blockchain.height < lastUpdateBlockHeight) {
                            const confirmImport = confirm(
                                `Warning: This UTXO data is from block ${data.blockchain.height}, but you have more recent data from block ${lastUpdateBlockHeight}.\n\n` +
                                `Importing this will overwrite your newer data. Continue?`
                            );
                            if (!confirmImport) {
                                utxoFileInput.value = '';
                                return;
                            }
                        }
                        
                        // Check data freshness
                        const exportDate = new Date(data.blockchain.timestamp);
                        const now = new Date();
                        const hoursDiff = Math.abs(now - exportDate) / 36e5; // Convert to hours
                        
                        if (hoursDiff > 24) {
                            const daysDiff = Math.floor(hoursDiff / 24);
                            const confirmStale = confirm(
                                `Warning: This UTXO data is ${daysDiff} day${daysDiff > 1 ? 's' : ''} old (block ${data.blockchain.height}).\n\n` +
                                `Exported: ${data.blockchain.exportDate}\n\n` +
                                'The balance information may be outdated. Continue?'
                            );
                            if (!confirmStale) return;
                        }
                        
                        // Check if this is a transaction template
                        if (data.transactionTemplates && data.metadata && data.metadata.exportType === 'transaction_template') {
                            // This is a transaction template - handle differently
                            offlineUtxoData = data;
                            localStorage.setItem('offlineUtxoData', JSON.stringify(data));
                            
                            // Update displays
                            updateCommonBalance();
                            updateUtxoListDisplay();
                            
                            showInAppNotification('Transaction Template Imported', 
                                `Template to send ${data.metadata.sendAmount} ALPHA to ${data.metadata.recipientAddress.substring(0, 10)}...`, 
                                'success');
                            
                            // Auto-open transaction confirmation modal with the template data
                            setTimeout(() => {
                                showTransactionTemplateConfirmation(data.transactionTemplates, data.metadata.recipientAddress, data.metadata.sendAmount);
                            }, 500);
                        } else {
                            // Regular UTXO import
                            offlineUtxoData = data;
                            localStorage.setItem('offlineUtxoData', JSON.stringify(data));
                            
                            // Update displays
                            // displayOfflineBalance(); // Removed with Cold Wallet reorganization
                            updateCommonBalance();
                            updateUtxoListDisplay();
                            
                            showInAppNotification('Import Successful', `UTXO data imported (block ${data.blockchain.height})`, 'success');
                        }
                    } catch (err) {
                        showInAppNotification('Import Failed', err.message, 'error');
                    }
                };
                reader.readAsText(file);
                
                // Reset the input
                event.target.value = '';
            };
            
            /* // Display offline balance - Removed with Cold Wallet reorganization
            function displayOfflineBalance() {
                if (!offlineUtxoData) {
                    offlineBalanceDisplay.style.display = 'none';
                    clearUtxoBtn.style.display = 'none';
                    return;
                }
                
                offlineBalanceDisplay.style.display = 'block';
                clearUtxoBtn.style.display = 'inline-flex';
                
                // Calculate total balance from UTXOs
                let totalBalance = 0;
                const utxos = offlineUtxoData.utxos || [];
                
                // Always calculate from UTXOs (single source of truth)
                utxos.forEach(utxo => {
                    totalBalance += utxo.value || 0;
                });
                
                // Display balance
                const alphaBalance = (totalBalance / 100000000).toFixed(8);
                offlineBalanceAmount.textContent = alphaBalance + ' ALPHA';
                
                // Display timestamp and block height
                const timestamp = new Date(offlineUtxoData.blockchain.timestamp);
                const blockHeight = offlineUtxoData.blockchain.height;
                offlineDataTimestamp.textContent = `Last updated: ${timestamp.toLocaleString()} • Block #${blockHeight}`;
                
                // Display UTXOs
                offlineUtxoList.innerHTML = '';
                
                if (utxos.length === 0) {
                    offlineUtxoList.innerHTML = '<p style="color: #999; text-align: center;">No UTXOs available</p>';
                } else {
                    const utxoHeader = document.createElement('div');
                    utxoHeader.style.cssText = 'font-weight: bold; margin-bottom: 10px; padding-bottom: 5px; border-bottom: 1px solid #e9ecef;';
                    utxoHeader.innerHTML = `${utxos.length} UTXO${utxos.length > 1 ? 's' : ''} available`;
                    offlineUtxoList.appendChild(utxoHeader);
                    
                    utxos.forEach((utxo, index) => {
                        const utxoDiv = document.createElement('div');
                        utxoDiv.style.cssText = 'padding: 8px; border-bottom: 1px solid #f0f0f0; font-size: 13px;';
                        
                        const txId = utxo.tx_hash || utxo.txid || 'Unknown';
                        const vout = utxo.tx_pos !== undefined ? utxo.tx_pos : (utxo.vout || 0);
                        const value = (utxo.value / 100000000).toFixed(8);
                        const height = utxo.height;
                        
                        utxoDiv.innerHTML = `
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <div style="font-family: monospace; font-size: 11px; color: #666;">
                                        ${txId.substring(0, 8)}...${txId.substring(txId.length - 8)}:${vout}
                                    </div>
                                    <div style="color: #333; font-weight: bold; margin-top: 2px;">
                                        ${value} ALPHA
                                    </div>
                                    <div style="color: #999; font-size: 11px;">
                                        ${height > 0 ? 'Block ' + height : 'Unconfirmed'}
                                    </div>
                                </div>
                            </div>
                        `;
                        
                        offlineUtxoList.appendChild(utxoDiv);
                    });
                }
            }
            */ // End of displayOfflineBalance - Removed with Cold Wallet reorganization
            
            // Update UTXO list display
            function updateUtxoListDisplay() {
                const utxoListElement = document.getElementById('currentUtxoList');
                if (!utxoListElement) {
                    return;
                }
                
                // Determine which UTXOs to display
                let allUtxos = [];
                let isOfflineData = false;
                
                if (currentUtxos && currentUtxos.length > 0) {
                    // Online UTXOs from Fulcrum
                    allUtxos = currentUtxos.map(utxo => ({
                        ...utxo,
                        source: 'online'
                    }));
                } else if (offlineUtxoData && offlineUtxoData.utxos && offlineUtxoData.utxos.length > 0) {
                    // Offline imported UTXOs
                    allUtxos = offlineUtxoData.utxos.map(utxo => ({
                        ...utxo,
                        source: 'offline'
                    }));
                    isOfflineData = true;
                }
                
                // Show/hide clear button based on offline data and connection status
                if (clearUtxoBtn) {
                    clearUtxoBtn.style.display = (isOfflineData && !electrumConnected) ? 'inline-flex' : 'none';
                }
                
                // Clear current display
                utxoListElement.innerHTML = '';
                
                if (allUtxos.length === 0) {
                    utxoListElement.innerHTML = '<div style="color: #666; font-style: italic; font-size: 11px;">No UTXOs available</div>';
                    return;
                }
                
                // Calculate pagination
                const totalPages = Math.ceil(allUtxos.length / ITEMS_PER_PAGE);
                const startIndex = (currentUtxoPage - 1) * ITEMS_PER_PAGE;
                const endIndex = startIndex + ITEMS_PER_PAGE;
                const pageUtxos = allUtxos.slice(startIndex, endIndex);
                
                // Get consumed UTXOs
                const consumedUtxos = getConsumedUtxos();
                
                // Display each UTXO on the current page
                pageUtxos.forEach((utxo, pageIndex) => {
                    const globalIndex = startIndex + pageIndex;
                    const utxoDiv = document.createElement('div');
                    
                    const amount = (utxo.value / 100000000).toFixed(8);
                    const txid = utxo.tx_hash || utxo.txid;
                    const vout = utxo.tx_pos !== undefined ? utxo.tx_pos : utxo.vout;
                    const height = utxo.height || 0;
                    const source = utxo.source === 'offline' ? ' (imported)' : '';
                    
                    // Check if this UTXO is consumed
                    const utxoKey = `${txid}:${vout}`;
                    const isConsumed = consumedUtxos.has(utxoKey);
                    
                    // Style based on consumption status
                    if (isConsumed) {
                        utxoDiv.style.cssText = 'padding: 8px; background-color: #e5e7eb; border-radius: 4px; margin-bottom: 6px; font-size: 11px; opacity: 0.6;';
                    } else {
                        utxoDiv.style.cssText = 'padding: 8px; background-color: #f8f9fa; border-radius: 4px; margin-bottom: 6px; font-size: 11px;';
                    }
                    
                    utxoDiv.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div style="flex: 1;">
                                <div style="font-weight: 600; color: ${isConsumed ? '#6b7280' : '#06d6a0'};">${amount} ALPHA${source}${isConsumed ? ' (pending)' : ''}</div>
                                <div style="font-family: monospace; color: #666; word-break: break-all;">
                                    ${txid}:${vout}
                                </div>
                                <div style="color: #888; margin-top: 2px;">
                                    ${height > 0 ? 
                                        (currentBlockHeight ? 
                                            `${Math.max(0, currentBlockHeight - height + 1)} confirmations` : 
                                            `Block: ${height}`) : 
                                        'Unconfirmed'}
                                    <span class="utxo-timestamp" data-height="${height}" data-index="${globalIndex}"></span>
                                </div>
                            </div>
                        </div>
                    `;
                    
                    utxoListElement.appendChild(utxoDiv);
                });
                
                // Add pagination controls if needed
                if (totalPages > 1) {
                    const paginationDiv = document.createElement('div');
                    paginationDiv.style.cssText = 'display: flex; justify-content: center; align-items: center; gap: 10px; margin-top: 15px; padding-top: 15px; border-top: 1px solid #e9ecef;';
                    
                    // Previous button
                    const prevBtn = document.createElement('button');
                    prevBtn.textContent = '← Previous';
                    prevBtn.style.cssText = 'padding: 5px 10px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer; font-size: 12px;';
                    prevBtn.disabled = currentUtxoPage === 1;
                    prevBtn.onclick = () => {
                        if (currentUtxoPage > 1) {
                            currentUtxoPage--;
                            updateUtxoListDisplay();
                        }
                    };
                    
                    // Page info
                    const pageInfo = document.createElement('span');
                    pageInfo.textContent = `Page ${currentUtxoPage} of ${totalPages} (${allUtxos.length} total)`;
                    pageInfo.style.cssText = 'font-size: 12px; color: #666;';
                    
                    // Next button
                    const nextBtn = document.createElement('button');
                    nextBtn.textContent = 'Next →';
                    nextBtn.style.cssText = 'padding: 5px 10px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer; font-size: 12px;';
                    nextBtn.disabled = currentUtxoPage === totalPages;
                    nextBtn.onclick = () => {
                        if (currentUtxoPage < totalPages) {
                            currentUtxoPage++;
                            updateUtxoListDisplay();
                        }
                    };
                    
                    paginationDiv.appendChild(prevBtn);
                    paginationDiv.appendChild(pageInfo);
                    paginationDiv.appendChild(nextBtn);
                    utxoListElement.appendChild(paginationDiv);
                }
                
                // Fetch and display timestamps for all UTXOs with block heights (only when connected)
                if (electrumConnected) {
                    pageUtxos.forEach((utxo, pageIndex) => {
                        const globalIndex = startIndex + pageIndex;
                        const height = utxo.height || 0;
                        if (height > 0) {
                            getBlockTimestamp(height, function(timestamp) {
                                const timestampElement = utxoListElement.querySelector(`.utxo-timestamp[data-index="${globalIndex}"]`);
                                if (timestampElement && timestamp) {
                                    timestampElement.textContent = ` • ${formatBlockTimestamp(timestamp)}`;
                                }
                            });
                        }
                    });
                }
            }
            
            // Clear offline UTXO data
            function clearOfflineUtxoData() {
                if (confirm('Are you sure you want to clear the offline UTXO data?')) {
                    offlineUtxoData = null;
                    localStorage.removeItem('offlineUtxoData');
                    // displayOfflineBalance(); // Removed with Cold Wallet reorganization
                    updateCommonBalance();
                    updateUtxoListDisplay();
                    showInAppNotification('Data Cleared', 'Offline UTXO data has been cleared', 'info');
                }
            }
            
            // Load offline UTXO data from localStorage on startup
            function loadOfflineUtxoData() {
                const stored = localStorage.getItem('offlineUtxoData');
                if (stored) {
                    try {
                        offlineUtxoData = JSON.parse(stored);
                        // displayOfflineBalance(); // Removed with Cold Wallet reorganization
                        updateCommonBalance();
                        updateUtxoListDisplay();
                    } catch (err) {
                        console.error('Failed to load offline UTXO data:', err);
                    }
                }
            }
            
            // Request notification permission on page load
            async function requestNotificationPermission() {
                if ('Notification' in window && Notification.permission === 'default') {
                    try {
                        const permission = await Notification.requestPermission();
                        console.log('Notification permission:', permission);
                    } catch (err) {
                        console.error('Error requesting notification permission:', err);
                    }
                }
            }
            
            // Copy address to clipboard
            window.copyAddress = function(type) {
                let address = '';
                if (type === 'wallet') {
                    address = document.getElementById('walletAddress').textContent;
                } else if (type === 'watchonly') {
                    address = document.getElementById('watchOnlyAddress').value;
                }
                
                if (address && address !== '-') {
                    // Check if clipboard API is available (requires HTTPS)
                    if (navigator.clipboard && navigator.clipboard.writeText) {
                        navigator.clipboard.writeText(address).then(function() {
                            showInAppNotification('Copied', 'Address copied to clipboard', 'success');
                        }).catch(function(err) {
                            // If clipboard API fails, use fallback
                            copyUsingFallback(address);
                        });
                    } else {
                        // Use fallback method for HTTP or older browsers
                        copyUsingFallback(address);
                    }
                }
            }
            
            function copyUsingFallback(text) {
                const textArea = document.createElement("textarea");
                textArea.value = text;
                textArea.style.position = "fixed";
                textArea.style.left = "-999999px";
                textArea.style.top = "-999999px";
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    document.execCommand('copy');
                    showInAppNotification('Copied', 'Address copied to clipboard', 'success');
                } catch (err) {
                    showInAppNotification('Failed', 'Failed to copy address', 'error');
                }
                document.body.removeChild(textArea);
            }
            
            // Show help modal
            window.showHelpModal = function() {
                document.getElementById('helpModal').style.display = 'block';
            }
            
            // Close help modal
            window.closeHelpModal = function() {
                document.getElementById('helpModal').style.display = 'none';
            }
            
            // Open disclaimer modal
            window.openDisclaimerModal = function() {
                document.getElementById('disclaimerModal').style.display = 'block';
            }
            
            // Close disclaimer modal
            window.closeDisclaimerModal = function() {
                document.getElementById('disclaimerModal').style.display = 'none';
            }
            
            // Open security notes modal
            window.openSecurityNotesModal = function() {
                document.getElementById('securityNotesModal').style.display = 'block';
            }
            
            // Close security notes modal
            window.closeSecurityNotesModal = function() {
                document.getElementById('securityNotesModal').style.display = 'none';
            }
            
            // Close modal when clicking outside
            window.onclick = function(event) {
                const helpModal = document.getElementById('helpModal');
                const disclaimerModal = document.getElementById('disclaimerModal');
                const securityNotesModal = document.getElementById('securityNotesModal');
                
                if (event.target == helpModal) {
                    helpModal.style.display = 'none';
                } else if (event.target == disclaimerModal) {
                    disclaimerModal.style.display = 'none';
                } else if (event.target == securityNotesModal) {
                    securityNotesModal.style.display = 'none';
                }
            }
            
            // Download the wallet page for offline use
            window.downloadWalletPage = function() {
                showInAppNotification('Preparing Download', 'Creating clean wallet file...', 'info');
                
                // Clone the current document
                const clonedDoc = document.documentElement.cloneNode(true);
                
                // Remove any dynamic content that shouldn't be saved
                // Remove any wallet data from displayed elements
                const elementsToClean = clonedDoc.querySelectorAll([
                    '#walletAddress',
                    '#walletBalance', 
                    '#walletUnconfirmed',
                    '#watchOnlyAddress',
                    '#watchOnlyBalance',
                    '#watchOnlyUnconfirmed',
                    '#transactionHistoryList',
                    '#currentUtxoList',
                    '#recipientAddress',
                    '#sendAmount'
                ].join(','));
                
                elementsToClean.forEach(el => {
                    if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') {
                        el.value = '';
                    } else {
                        if (el.id === 'walletAddress') {
                            el.textContent = '-';
                        } else if (el.id === 'walletBalance' || el.id === 'watchOnlyBalance') {
                            el.textContent = '0.00000000 ALPHA';
                        } else if (el.id === 'transactionHistoryList') {
                            el.innerHTML = '<p style="color: #999; text-align: center;">No transactions yet</p>';
                        } else if (el.id === 'currentUtxoList') {
                            el.innerHTML = '<p style="color: #999; text-align: center;">No UTXOs loaded</p>';
                        } else {
                            el.textContent = '';
                        }
                    }
                });
                
                // Reset any inline styles that might have been set dynamically
                const dynamicElements = clonedDoc.querySelectorAll('[style*="display: block"], [style*="display: none"]');
                dynamicElements.forEach(el => {
                    // Reset to original display states
                    if (el.id === 'watchOnlySection' || el.id === 'transactionHistoryContainer') {
                        el.style.display = 'none';
                    }
                });
                
                // Clear any script-injected content
                const notificationContainer = clonedDoc.querySelector('#notificationContainer');
                if (notificationContainer) {
                    notificationContainer.innerHTML = '';
                }
                
                // Get the cleaned HTML
                const cleanHtml = '<!DOCTYPE html>\n' + clonedDoc.outerHTML;
                
                // Create blob and download
                const blob = new Blob([cleanHtml], { type: 'text/html;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'unicity-wallet.html';
                a.style.display = 'none';
                
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showInAppNotification('Download Complete', 'Clean wallet saved as unicity-wallet.html', 'success');
            }
            
            // Show in-browser notification
            function showInAppNotification(title, message, type = 'info') {
                const container = document.getElementById('notificationContainer');
                
                // Limit to 3 visible notifications
                const visibleNotifications = container.querySelectorAll('.notification:not(.removing)');
                if (visibleNotifications.length >= 3) {
                    // Remove the oldest notification
                    removeNotification(visibleNotifications[0]);
                }
                
                // Create notification element
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                
                // Choose icon based on type
                let icon = '';
                switch(type) {
                    case 'success':
                        icon = '✅';
                        break;
                    case 'error':
                        icon = '❌';
                        break;
                    case 'warning':
                        icon = '⚠️';
                        break;
                    case 'info':
                    default:
                        icon = 'ℹ️';
                        break;
                }
                
                notification.innerHTML = `
                    <div class="notification-icon">${icon}</div>
                    <div class="notification-content">
                        <div class="notification-title">${title}</div>
                        <div class="notification-message">${message}</div>
                    </div>
                    <button class="notification-close">&times;</button>
                `;
                
                // Add close functionality
                const closeBtn = notification.querySelector('.notification-close');
                closeBtn.onclick = () => removeNotification(notification);
                
                // Add to container
                container.appendChild(notification);
                
                // Auto-remove after 8 seconds
                setTimeout(() => removeNotification(notification), 8000);
            }
            
            // Remove notification with animation
            function removeNotification(notification) {
                if (!notification || notification.classList.contains('removing')) return;
                
                notification.classList.add('removing');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }
            
            // Make showInAppNotification globally accessible
            window.showInAppNotification = showInAppNotification;
            
            // Show system notification (only for transactions)
            function showNotification(title, body, icon = null) {
                // Determine if this is a transaction notification
                const isTransaction = title.includes('Transaction') || title.includes('Incoming') || 
                                    title.includes('Outgoing') || title.includes('Confirmed');
                
                // Always show in-app notification
                let type = 'info';
                if (title.includes('✅') || title.includes('Confirmed')) type = 'success';
                else if (title.includes('💰') || title.includes('Incoming')) type = 'success';
                else if (title.includes('📤') || title.includes('Outgoing')) type = 'info';
                else if (title.includes('🔗') || title.includes('Block')) type = 'info';
                else if (title.includes('Error') || title.includes('Failed')) type = 'error';
                
                showInAppNotification(title, body, type);
                
                // Only show system notification for transactions
                if (!isTransaction) return;
                
                // Show system notification if supported
                if (!('Notification' in window)) {
                    console.log('This browser does not support system notifications');
                    return;
                }
                
                if (Notification.permission === 'granted') {
                    const notification = new Notification(title, {
                        body: body,
                        icon: icon || 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiMzNGQzOTkiIHN0cm9rZS13aWR0aD0iMiI+PHJlY3QgeD0iMyIgeT0iMTEiIHdpZHRoPSIxOCIgaGVpZ2h0PSIxMSIgcng9IjIiIHJ5PSIyIi8+PHBhdGggZD0iTTcgMTFWN2E1IDUgMCAwIDEgMTAgMHY0Ii8+PC9zdmc+',
                        tag: 'alpha-wallet-' + Date.now(),
                        requireInteraction: false,
                        silent: false
                    });
                    
                    setTimeout(() => notification.close(), 5000);
                    
                    notification.onclick = function() {
                        window.focus();
                        notification.close();
                    };
                }
            }
            
            // Helper to compare arrays for changes and detect specific changes
            function analyzeTransactionChanges(oldArray, newArray) {
                const changes = {
                    hasChanged: false,
                    newTransactions: [],
                    confirmedTransactions: []
                };
                
                if (!oldArray || !newArray) {
                    changes.hasChanged = true;
                    return changes;
                }
                
                if (oldArray.length !== newArray.length) {
                    changes.hasChanged = true;
                }
                
                // Create maps for comparison (using lowercase txids)
                const oldMap = new Map();
                oldArray.forEach(item => {
                    const txid = (item.tx_hash || item.txid || '').toLowerCase();
                    oldMap.set(txid, item);
                });
                
                const newMap = new Map();
                newArray.forEach(item => {
                    const txid = (item.tx_hash || item.txid || '').toLowerCase();
                    newMap.set(txid, item);
                });
                
                // Check for new transactions
                newMap.forEach((newItem, txid) => {
                    if (!oldMap.has(txid)) {
                        changes.newTransactions.push(newItem);
                        changes.hasChanged = true;
                    }
                });
                
                // Check for confirmed transactions (height changed from 0 to positive)
                newMap.forEach((newItem, txid) => {
                    const oldItem = oldMap.get(txid);
                    if (oldItem && oldItem.height === 0 && newItem.height > 0) {
                        changes.confirmedTransactions.push(newItem);
                        changes.hasChanged = true;
                    }
                });
                
                return changes;
            }
            
            // Helper to compare arrays for changes
            function hasArrayChanged(oldArray, newArray) {
                return analyzeTransactionChanges(oldArray, newArray).hasChanged;
            }
            
            // Update refreshBalance to store current data
            const originalRefreshBalance = refreshBalance;
            refreshBalance = function() {
                originalRefreshBalance();
                
                // Also fetch and store current transactions for export
                if (wallet.addresses && wallet.addresses.length > 0) {
                    const scriptHash = addressToScriptHash(wallet.addresses[0].address);
                    if (scriptHash) {
                        // Store transactions
                        electrumRequest('blockchain.scripthash.get_history', [scriptHash], function(result) {
                            if (result) {
                                // Regular wallet transaction history fetched successfully
                                // Analyze changes
                                const changes = analyzeTransactionChanges(currentTransactions, result);
                                
                                if (changes.hasChanged) {
                                    // Only show notifications if not initial load
                                    if (!isInitialLoad && changes.newTransactions.length > 0) {
                                        // Only show notifications for truly new unconfirmed transactions
                                        // When a new tx arrives, we should only notify about that one
                                        const unconfirmedNewTxs = changes.newTransactions.filter(tx => tx.height === 0);
                                        
                                        // If we have many new transactions, it's likely a data refresh issue
                                        // Only notify if we have 1-2 new unconfirmed transactions
                                        if (unconfirmedNewTxs.length <= 2) {
                                            unconfirmedNewTxs.forEach(tx => {
                                        const txid = tx.tx_hash || tx.txid;
                                        const shortTxid = txid.substring(0, 8) + '...' + txid.substring(txid.length - 8);
                                        
                                        // Fetch transaction details to determine direction
                                        electrumRequest('blockchain.transaction.get', [txid, true], function(txDetails) {
                                            // Cache the transaction details
                                            if (txDetails) {
                                                transactionDetailsCache[txid] = txDetails;
                                            }
                                            
                                            let notificationTitle, notificationBody;
                                            
                                            if (txDetails) {
                                                const address = wallet.addresses && wallet.addresses.length > 0 ? 
                                                    wallet.addresses[0].address : watchOnlyAddressValue;
                                                const result = calculateTransactionAmount(txDetails, address);
                                                const amount = (Math.abs(result.netAmount) / 100000000).toFixed(8);
                                                
                                                if (result.isIncoming) {
                                                    notificationTitle = tx.height === 0 ? 
                                                        '💰 Incoming Transaction' : 
                                                        '✅ Incoming Transaction Confirmed';
                                                    notificationBody = `Received ${amount} ALPHA${tx.height > 0 ? ' in block ' + tx.height : ' (unconfirmed)'}`;
                                                } else {
                                                    notificationTitle = tx.height === 0 ? 
                                                        '📤 Outgoing Transaction' : 
                                                        '✅ Outgoing Transaction Confirmed';
                                                    notificationBody = `Sent ${amount} ALPHA${tx.height > 0 ? ' in block ' + tx.height : ' (unconfirmed)'}`;
                                                }
                                            } else {
                                                // Fallback if we can't get details
                                                notificationTitle = tx.height === 0 ? 
                                                    '⚡ New Transaction' : 
                                                    '✓ Transaction Confirmed';
                                                notificationBody = `Transaction ${shortTxid}${tx.height > 0 ? ' in block ' + tx.height : ' detected'}`;
                                            }
                                            
                                            showNotification(notificationTitle, notificationBody);
                                        });
                                            });
                                        }
                                    }
                                    
                                    // Show notifications for newly confirmed transactions (always show these)
                                    if (!isInitialLoad && changes.confirmedTransactions.length > 0) {
                                        changes.confirmedTransactions.forEach(tx => {
                                        const txid = tx.tx_hash || tx.txid;
                                        const shortTxid = txid.substring(0, 8) + '...' + txid.substring(txid.length - 8);
                                        
                                        showNotification(
                                            '✅ Transaction Confirmed',
                                            `Transaction ${shortTxid} confirmed in block ${tx.height}`
                                        );
                                        });
                                    }
                                    
                                    currentTransactions = result;
                                    updateTransactionHistory();
                                }
                            }
                        });
                        
                        // Store UTXOs
                        electrumRequest('blockchain.scripthash.listunspent', [scriptHash], function(result) {
                            if (result) {
                                // Only update if UTXOs changed
                                if (hasArrayChanged(currentUtxos, result)) {
                                    // Add address to each UTXO
                                    currentUtxos = result.map(utxo => ({
                                        ...utxo,
                                        address: wallet.addresses[0].address
                                    }));
                                    updateCommonBalance();
                                    updateUtxoListDisplay();
                                }
                            }
                        });
                    }
                }
            };
            
            // Event listeners for UTXO buttons
            exportUtxoBtn.onclick = exportUtxoData;
            importUtxoBtn.onclick = importUtxoData;
            clearUtxoBtn.onclick = clearOfflineUtxoData;
            
            // Load offline data on startup
            loadOfflineUtxoData();
            
            // Initial button state update
            updateCommonBalance();
            
            // Request notification permission
            requestNotificationPermission();
            
            // Transaction functionality
            let pendingTransactions = [];
            
            // Calculate maximum sendable amount
            window.calculateMaxAmount = function() {
                // Check if we have UTXOs
                let availableUtxos = [];
                const consumedUtxos = getConsumedUtxos();
                
                if (currentUtxos && currentUtxos.length > 0) {
                    availableUtxos = currentUtxos.filter(utxo => {
                        const utxoKey = `${utxo.txid}:${utxo.vout}`;
                        return !consumedUtxos.has(utxoKey);
                    });
                } else if (offlineUtxoData && offlineUtxoData.utxos && offlineUtxoData.utxos.length > 0) {
                    availableUtxos = offlineUtxoData.utxos.filter(utxo => {
                        const utxoKey = `${utxo.txid}:${utxo.vout}`;
                        return !consumedUtxos.has(utxoKey);
                    });
                }
                
                if (availableUtxos.length === 0) {
                    showInAppNotification('No UTXOs', 'No UTXOs available to calculate maximum amount', 'warning');
                    return;
                }
                
                // Calculate total available
                const totalAvailable = availableUtxos.reduce((sum, utxo) => sum + utxo.value, 0);
                
                // Calculate fees - we need one transaction per UTXO in Alpha
                const feePerTx = 10000; // 0.0001 ALPHA fee per transaction
                const totalFees = availableUtxos.length * feePerTx;
                
                // Calculate maximum sendable amount
                const maxSendable = totalAvailable - totalFees;
                
                if (maxSendable <= 0) {
                    showInAppNotification('Insufficient Balance', 'Total balance is too low to cover transaction fees', 'error');
                    return;
                }
                
                // Convert to ALPHA and set the amount field
                const maxAlpha = maxSendable / 100000000;
                document.getElementById('sendAmount').value = maxAlpha.toFixed(8);
                
                // Show notification
                showInAppNotification('Max Amount', `Maximum sendable: ${maxAlpha.toFixed(8)} ALPHA (${availableUtxos.length} UTXOs, ${(totalFees / 100000000).toFixed(8)} ALPHA in fees)`, 'info');
            };
            
            // Prepare send transaction
            window.prepareSendTransaction = function() {
                const recipientAddress = document.getElementById('recipientAddress').value.trim();
                const sendAmount = parseFloat(document.getElementById('sendAmount').value);
                
                // Validate inputs
                if (!recipientAddress) {
                    alert('Please enter a recipient address');
                    return;
                }
                
                if (!recipientAddress.startsWith('alpha1')) {
                    alert('Invalid address format. Address must start with "alpha1"');
                    return;
                }
                
                if (!sendAmount || sendAmount <= 0) {
                    alert('Please enter a valid amount');
                    return;
                }
                
                // Check if wallet is loaded - but allow watch-only mode
                if (!watchOnlyMode && !wallet.masterPrivateKey && !wallet.childPrivateKey) {
                    alert('No wallet loaded. Please create or import a wallet first.');
                    return;
                }
                
                // Check if we have a wallet address (or watch-only address)
                if (!watchOnlyMode && (!wallet.addresses || wallet.addresses.length === 0)) {
                    alert('No wallet address available. Please generate an address first.');
                    return;
                }
                
                // In watch-only mode, check if we have an address
                if (watchOnlyMode && !watchOnlyAddressValue) {
                    alert('No watch-only address set. Please enter an address to monitor.');
                    return;
                }
                
                // Check if we have UTXOs
                // Use currentUtxos (from online query) or offlineUtxoData if available
                let availableUtxos = [];
                const consumedUtxos = getConsumedUtxos();
                
                if (currentUtxos && currentUtxos.length > 0) {
                    availableUtxos = currentUtxos.filter(utxo => {
                        const utxoKey = `${utxo.txid}:${utxo.vout}`;
                        return !consumedUtxos.has(utxoKey);
                    });
                } else if (offlineUtxoData && offlineUtxoData.utxos && offlineUtxoData.utxos.length > 0) {
                    availableUtxos = offlineUtxoData.utxos.filter(utxo => {
                        const utxoKey = `${utxo.txid}:${utxo.vout}`;
                        return !consumedUtxos.has(utxoKey);
                    });
                }
                
                if (availableUtxos.length === 0) {
                    alert('No UTXOs available. Please load UTXO data first (either connect online or import UTXO file).');
                    return;
                }
                
                // Convert amount to satoshis (1 ALPHA = 100000000 satoshis)
                const amountSatoshis = Math.floor(sendAmount * 100000000);
                
                // Get the sender address (wallet address or watch-only address)
                const senderAddress = watchOnlyMode ? watchOnlyAddressValue : wallet.addresses[0].address;
                
                // Collect UTXOs for the required amount
                const txPlan = collectUtxosForAmount(availableUtxos, amountSatoshis, recipientAddress, senderAddress);
                
                if (!txPlan.success) {
                    alert(txPlan.error);
                    return;
                }
                
                // In watch-only mode, export transaction template instead of showing confirmation
                if (watchOnlyMode) {
                    exportTransactionTemplate(txPlan.transactions, recipientAddress, sendAmount, senderAddress);
                } else {
                    // Show confirmation modal for normal flow
                    showTransactionConfirmation(txPlan.transactions, recipientAddress, sendAmount);
                }
            };
            
            // Collect UTXOs for required amount
            function collectUtxosForAmount(utxoList, amountSatoshis, recipientAddress, senderAddress) {
                // Sort UTXOs by value (ascending) to minimize number of transactions
                const sortedUtxos = [...utxoList].sort((a, b) => a.value - b.value);
                
                // Calculate total available
                const totalAvailable = sortedUtxos.reduce((sum, utxo) => sum + utxo.value, 0);
                
                if (totalAvailable < amountSatoshis) {
                    return {
                        success: false,
                        error: `Insufficient funds. Available: ${(totalAvailable / 100000000).toFixed(8)} ALPHA, Required: ${(amountSatoshis / 100000000).toFixed(8)} ALPHA`
                    };
                }
                
                const transactions = [];
                let remainingAmount = amountSatoshis;
                const feePerTx = 10000; // 0.0001 ALPHA fee per transaction
                
                // Since Alpha requires one input per transaction, we need to create multiple transactions
                for (const utxo of sortedUtxos) {
                    if (remainingAmount <= 0) break;
                    
                    const utxoValue = utxo.value;
                    let txAmount;
                    let changeAmount = 0;
                    
                    if (utxoValue >= remainingAmount + feePerTx) {
                        // This UTXO covers the remaining amount plus fee
                        txAmount = remainingAmount;
                        changeAmount = utxoValue - remainingAmount - feePerTx;
                        remainingAmount = 0;
                    } else {
                        // Use entire UTXO minus fee
                        txAmount = utxoValue - feePerTx;
                        remainingAmount -= txAmount;
                        
                        if (txAmount <= 0) {
                            // UTXO too small to cover fee
                            continue;
                        }
                    }
                    
                    transactions.push({
                        input: utxo,
                        outputs: [
                            { address: recipientAddress, value: txAmount }
                        ],
                        fee: feePerTx,
                        changeAmount: changeAmount,
                        changeAddress: senderAddress // Send change back to sender address
                    });
                    
                    // Add change output if needed (but avoid dust outputs)
                    // Dust threshold: 546 satoshis is typical for P2WPKH
                    const DUST_THRESHOLD = 546;
                    if (changeAmount > DUST_THRESHOLD) {
                        transactions[transactions.length - 1].outputs.push({
                            address: senderAddress,
                            value: changeAmount
                        });
                    } else if (changeAmount > 0) {
                        // If change is dust, add it to the fee instead
                        console.log(`Change amount ${changeAmount} is below dust threshold, adding to fee`);
                    }
                }
                
                if (remainingAmount > 0) {
                    return {
                        success: false,
                        error: `Unable to collect enough UTXOs. Short by ${(remainingAmount / 100000000).toFixed(8)} ALPHA after fees.`
                    };
                }
                
                // Apply dust rebalancing
                const rebalancedTransactions = rebalanceDustOutputs(transactions, recipientAddress, senderAddress, sortedUtxos, feePerTx);
                
                return {
                    success: true,
                    transactions: rebalancedTransactions
                };
            }
            
            // Rebalance transactions to avoid dust outputs
            function rebalanceDustOutputs(transactions, recipientAddress, senderAddress, availableUtxos, feePerTx) {
                const DUST_THRESHOLD = 546;
                
                // First pass: rebalance recipient dust outputs across transactions
                for (let i = 0; i < transactions.length; i++) {
                    const tx = transactions[i];
                    const recipientOutput = tx.outputs.find(o => o.address === recipientAddress);
                    
                    if (recipientOutput && recipientOutput.value < DUST_THRESHOLD && transactions.length > 1) {
                        // Find another transaction to rebalance with
                        for (let j = 0; j < transactions.length; j++) {
                            if (i === j) continue;
                            
                            const otherTx = transactions[j];
                            const otherRecipientOutput = otherTx.outputs.find(o => o.address === recipientAddress);
                            
                            if (otherRecipientOutput) {
                                // Calculate how much we need to move to make both outputs non-dust
                                const totalAmount = recipientOutput.value + otherRecipientOutput.value;
                                const halfAmount = Math.floor(totalAmount / 2);
                                
                                if (halfAmount > DUST_THRESHOLD) {
                                    // Rebalance the outputs
                                    recipientOutput.value = halfAmount;
                                    otherRecipientOutput.value = totalAmount - halfAmount;
                                    break;
                                }
                            }
                        }
                    }
                }
                
                // Second pass: handle dust change outputs
                const finalTransactions = [];
                const usedUtxos = new Set(transactions.map(tx => `${tx.input.txid}:${tx.input.vout}`));
                
                for (const tx of transactions) {
                    finalTransactions.push(tx);
                    
                    // Check if we have dust change that needs to be handled
                    if (tx.changeAmount > 0 && tx.changeAmount <= DUST_THRESHOLD) {
                        const recipientOutput = tx.outputs.find(o => o.address === recipientAddress);
                        
                        if (recipientOutput && recipientOutput.value > DUST_THRESHOLD * 2) {
                            // Split the recipient output to create non-dust change
                            const halfRecipientAmount = Math.floor(recipientOutput.value / 2);
                            recipientOutput.value = halfRecipientAmount;
                            
                            // Create proper change output
                            const newChangeAmount = tx.input.value - halfRecipientAmount - tx.fee;
                            if (newChangeAmount > DUST_THRESHOLD) {
                                tx.outputs.push({
                                    address: senderAddress,
                                    value: newChangeAmount
                                });
                                tx.changeAmount = newChangeAmount;
                                
                                // Now we need to create a follow-up transaction for the remaining recipient amount
                                // Find an unused UTXO
                                const nextUtxo = availableUtxos.find(utxo => 
                                    !usedUtxos.has(`${utxo.txid}:${utxo.vout}`)
                                );
                                
                                if (nextUtxo) {
                                    // Create follow-up transaction
                                    const remainingRecipientAmount = recipientOutput.value;
                                    const followUpTx = {
                                        input: nextUtxo,
                                        outputs: [
                                            { address: recipientAddress, value: remainingRecipientAmount }
                                        ],
                                        fee: feePerTx,
                                        changeAmount: nextUtxo.value - remainingRecipientAmount - feePerTx,
                                        changeAddress: senderAddress
                                    };
                                    
                                    // Add change output if non-dust
                                    if (followUpTx.changeAmount > DUST_THRESHOLD) {
                                        followUpTx.outputs.push({
                                            address: senderAddress,
                                            value: followUpTx.changeAmount
                                        });
                                    }
                                    
                                    finalTransactions.push(followUpTx);
                                    usedUtxos.add(`${nextUtxo.txid}:${nextUtxo.vout}`);
                                    console.log(`Created follow-up transaction to handle dust change rebalancing`);
                                }
                            }
                        }
                    }
                }
                
                return finalTransactions;
            }
            
            // Show transaction confirmation modal
            function showTransactionConfirmation(transactions, recipientAddress, totalAmount) {
                pendingTransactions = transactions;
                
                let detailsHtml = `
                    <div style="margin-bottom: 20px;">
                        <strong>Recipient:</strong> <span style="font-family: monospace; word-break: break-all;">${recipientAddress}</span>
                    </div>
                    <div style="margin-bottom: 20px;">
                        <strong>Total Amount:</strong> ${totalAmount.toFixed(8)} ALPHA
                    </div>
                    <div style="margin-bottom: 20px;">
                        <strong>Number of Transactions:</strong> ${transactions.length}
                    </div>
                    <div style="border-top: 1px solid #e5e7eb; padding-top: 15px;">
                        <h4>Transaction Details:</h4>
                `;
                
                let totalFees = 0;
                transactions.forEach((tx, index) => {
                    totalFees += tx.fee;
                    detailsHtml += `
                        <div style="margin-top: 15px; padding: 10px; background: #f9fafb; border-radius: 8px;">
                            <div><strong>Transaction ${index + 1}:</strong></div>
                            <div style="margin-top: 5px; font-size: 0.9em;">
                                <div>Input UTXO: ${(tx.input.value / 100000000).toFixed(8)} ALPHA</div>
                                <div>Send to recipient: ${(tx.outputs[0].value / 100000000).toFixed(8)} ALPHA</div>
                                ${tx.changeAmount > 0 ? `<div>Change to wallet: ${(tx.changeAmount / 100000000).toFixed(8)} ALPHA</div>` : ''}
                                <div>Fee: ${(tx.fee / 100000000).toFixed(8)} ALPHA</div>
                            </div>
                        </div>
                    `;
                });
                
                detailsHtml += `
                    </div>
                    <div style="margin-top: 20px; padding: 10px; background: #fef3c7; border-radius: 8px;">
                        <strong>Total Fees:</strong> ${(totalFees / 100000000).toFixed(8)} ALPHA
                    </div>
                `;
                
                document.getElementById('txConfirmDetails').innerHTML = detailsHtml;
                document.getElementById('txConfirmModal').style.display = 'block';
            }
            
            // Show transaction confirmation for imported templates
            function showTransactionTemplateConfirmation(transactionTemplates, recipientAddress, totalAmount) {
                // Convert templates back to transaction format
                const transactions = transactionTemplates.map(template => ({
                    input: template.inputs[0],
                    outputs: template.outputs,
                    fee: template.fee,
                    changeAmount: template.changeAmount,
                    changeAddress: template.changeAddress
                }));
                
                // Use the regular confirmation modal
                showTransactionConfirmation(transactions, recipientAddress, totalAmount);
            }
            
            // Cancel transaction
            window.cancelTransaction = function() {
                pendingTransactions = [];
                document.getElementById('txConfirmModal').style.display = 'none';
            };
            
            // Confirm and sign transactions
            window.confirmAndSignTransactions = function() {
                if (pendingTransactions.length === 0) return;
                
                try {
                    const signedTransactions = [];
                    
                    // Sign each transaction
                    for (const txPlan of pendingTransactions) {
                        try {
                            const signedTx = createAndSignTransaction(txPlan);
                            signedTransactions.push(signedTx);
                        } catch (txError) {
                            console.error('Error signing individual transaction:', txError);
                            throw txError;
                        }
                    }
                    
                    
                    // Check if we're online (electrumSocket is defined in the connection scope)
                    // For now, we'll check if we can access the Electrum connection
                    const isOnline = (typeof electrumSocket !== 'undefined' && electrumSocket && electrumSocket.readyState === WebSocket.OPEN);
                    
                    if (isOnline) {
                        // Broadcast transactions
                        broadcastTransactions(signedTransactions);
                    } else {
                        // Save transactions for offline broadcast
                        saveTransactionsOffline(signedTransactions);
                    }
                    
                    // Clear form and close modal
                    document.getElementById('recipientAddress').value = '';
                    document.getElementById('sendAmount').value = '';
                    document.getElementById('txConfirmModal').style.display = 'none';
                    pendingTransactions = [];
                    
                } catch (error) {
                    showInAppNotification('Signing Failed', 'Error signing transactions: ' + error.message, 'error');
                    console.error('Signing error:', error);
                }
            };
            
            // Create and sign a transaction
            function createAndSignTransaction(txPlan) {
                
                // Get the private key
                const privateKeyHex = wallet.childPrivateKey || wallet.masterPrivateKey;
                if (!privateKeyHex) {
                    throw new Error('No private key available');
                }
                
                
                const ec = new elliptic.ec('secp256k1');
                const keyPair = ec.keyFromPrivate(privateKeyHex, 'hex');
                const publicKey = keyPair.getPublic(true, 'hex'); // compressed
                
                // Verify the public key matches our wallet address
                const pubKeyHash = CryptoJS.RIPEMD160(CryptoJS.SHA256(CryptoJS.enc.Hex.parse(publicKey))).toString();
                
                // Check if this pubkey hash matches the wallet address
                const decoded = decodeBech32(wallet.addresses[0].address);
                if (decoded) {
                    const addressPubKeyHash = decoded.data.map(b => b.toString(16).padStart(2, '0')).join('');
                    if (pubKeyHash !== addressPubKeyHash) {
                        console.error('WARNING: Public key does not match wallet address!');
                    }
                }
                
                // Build the transaction for SegWit (P2WPKH)
                const tx = buildSegWitTransaction(txPlan, keyPair, publicKey);
                
                
                const result = {
                    raw: tx.hex,
                    txid: tx.txid,
                    details: txPlan
                };
                
                console.log('createAndSignTransaction returning:', result);
                
                return result;
            }
            
            // Build a proper SegWit transaction
            function buildSegWitTransaction(txPlan, keyPair, publicKey) {
                
                // Transaction components
                let txHex = '';
                
                // Version (4 bytes, little-endian)
                txHex += '02000000'; // version 2
                
                // Marker and flag for SegWit
                txHex += '00'; // marker
                txHex += '01'; // flag
                
                // Number of inputs (varint)
                txHex += '01'; // 1 input
                
                // Input
                // Previous tx hash (32 bytes, reversed for little-endian)
                const prevTxHash = txPlan.input.tx_hash;
                
                // Log the UTXO we're trying to spend to verify it belongs to us
                
                // Verify the UTXO scriptPubKey matches our address
                const ourScriptPubKey = createScriptPubKey(wallet.addresses[0].address);
                
                const reversedHash = prevTxHash.match(/../g).reverse().join('');
                txHex += reversedHash;
                
                // Previous output index (4 bytes, little-endian)
                const vout = txPlan.input.tx_pos;
                txHex += ('00000000' + vout.toString(16)).slice(-8).match(/../g).reverse().join('');
                
                // Script length (varint) - 0 for witness transactions
                txHex += '00';
                
                // Sequence (4 bytes)
                txHex += 'feffffff';
                
                // Number of outputs (varint)
                const outputCount = txPlan.outputs.length;
                txHex += ('0' + outputCount.toString(16)).slice(-2);
                
                // Outputs
                for (const output of txPlan.outputs) {
                    // Amount (8 bytes, little-endian)
                    const amountHex = output.value.toString(16).padStart(16, '0');
                    txHex += amountHex.match(/../g).reverse().join('');
                    
                    // Script pubkey
                    const scriptPubKey = createScriptPubKey(output.address);
                    const scriptLength = (scriptPubKey.length / 2).toString(16).padStart(2, '0');
                    txHex += scriptLength;
                    txHex += scriptPubKey;
                }
                
                // Witness data
                const witnessData = createWitnessData(txPlan, txHex, keyPair, publicKey);
                txHex += witnessData;
                
                // Locktime (4 bytes)
                txHex += '00000000';
                
                // Calculate transaction ID (double SHA256 of tx without witness data)
                const txForId = txHex.replace(/^02000000000101/, '02000000').replace(witnessData, '');
                const hash1 = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(txForId));
                const hash2 = CryptoJS.SHA256(hash1);
                const txid = hash2.toString();
                
                
                return {
                    hex: txHex,
                    txid: txid
                };
            }
            
            // Create witness data for the transaction
            function createWitnessData(txPlan, partialTx, keyPair, publicKey) {
                // For P2WPKH, witness contains: signature and public key
                
                // Create signature hash for witness
                const sigHash = createSignatureHash(txPlan, partialTx, publicKey);
                
                
                // Sign the hash
                const signature = keyPair.sign(sigHash);
                
                // Ensure low-S canonical signature (BIP62)
                const ec = new elliptic.ec('secp256k1');
                const halfOrder = ec.curve.n.shrn(1);
                if (signature.s.cmp(halfOrder) > 0) {
                    signature.s = ec.curve.n.sub(signature.s);
                }
                
                const derSig = signature.toDER('hex') + '01'; // SIGHASH_ALL
                
                // Verify our own signature to ensure it's valid
                const verifyResult = keyPair.verify(sigHash, signature);
                if (!verifyResult) {
                    console.error('ERROR: Our own signature verification failed!');
                }
                
                // Build witness
                let witness = '';
                witness += '02'; // 2 stack items
                
                // Signature
                const sigLen = (derSig.length / 2).toString(16).padStart(2, '0');
                witness += sigLen;
                witness += derSig;
                
                // Public key
                const pubKeyLen = (publicKey.length / 2).toString(16).padStart(2, '0');
                witness += pubKeyLen;
                witness += publicKey;
                
                return witness;
            }
            
            // Create signature hash for SegWit
            function createSignatureHash(txPlan, partialTx, publicKey) {
                // BIP143 signature hash for P2WPKH
                let preimage = '';
                
                // 1. nVersion (4 bytes, little-endian)
                preimage += '02000000';
                
                // 2. hashPrevouts (32 bytes)
                let prevouts = '';
                // For BIP143, prevout is txid (little-endian) + vout (little-endian)
                const txidBytes = txPlan.input.tx_hash.match(/../g).reverse().join('');
                const voutBytes = ('00000000' + txPlan.input.tx_pos.toString(16)).slice(-8).match(/../g).reverse().join('');
                prevouts = txidBytes + voutBytes;
                console.log('Prevout for hashing:', prevouts);
                const hashPrevouts = CryptoJS.SHA256(CryptoJS.SHA256(CryptoJS.enc.Hex.parse(prevouts))).toString();
                console.log('hashPrevouts:', hashPrevouts);
                preimage += hashPrevouts;
                
                // 3. hashSequence (32 bytes) 
                const sequence = 'feffffff';
                const hashSequence = CryptoJS.SHA256(CryptoJS.SHA256(CryptoJS.enc.Hex.parse(sequence))).toString();
                preimage += hashSequence;
                
                // 4. outpoint (36 bytes)
                preimage += txPlan.input.tx_hash.match(/../g).reverse().join('');
                preimage += ('00000000' + txPlan.input.tx_pos.toString(16)).slice(-8).match(/../g).reverse().join('');
                
                // 5. scriptCode for P2WPKH (includes length prefix)
                const pubKeyHash = CryptoJS.RIPEMD160(CryptoJS.SHA256(CryptoJS.enc.Hex.parse(publicKey))).toString();
                const scriptCode = '1976a914' + pubKeyHash + '88ac'; // Length + OP_DUP OP_HASH160 <20-byte-hash> OP_EQUALVERIFY OP_CHECKSIG
                console.log('ScriptCode:', scriptCode);
                console.log('PubKeyHash in scriptCode:', pubKeyHash);
                preimage += scriptCode;
                
                // 6. amount (8 bytes, little-endian)
                const amountHex = txPlan.input.value.toString(16).padStart(16, '0');
                preimage += amountHex.match(/../g).reverse().join('');
                
                // 7. nSequence (4 bytes, little-endian)
                preimage += sequence;
                
                // 8. hashOutputs (32 bytes)
                let outputs = '';
                for (const output of txPlan.outputs) {
                    // Amount (8 bytes, little-endian)
                    const outAmountHex = output.value.toString(16).padStart(16, '0');
                    outputs += outAmountHex.match(/../g).reverse().join('');
                    // Script pubkey with length
                    const scriptPubKey = createScriptPubKey(output.address);
                    const scriptLength = (scriptPubKey.length / 2).toString(16).padStart(2, '0');
                    outputs += scriptLength;
                    outputs += scriptPubKey;
                }
                const hashOutputs = CryptoJS.SHA256(CryptoJS.SHA256(CryptoJS.enc.Hex.parse(outputs))).toString();
                preimage += hashOutputs;
                
                // 9. nLocktime (4 bytes, little-endian)
                preimage += '00000000';
                
                // 10. sighash type (4 bytes, little-endian)
                preimage += '01000000'; // SIGHASH_ALL
                
                
                // Double SHA256
                const hash1 = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(preimage));
                const hash2 = CryptoJS.SHA256(hash1);
                const sigHash = hash2.toString();
                
                
                return sigHash;
            }
            
            // Create scriptPubKey for address (P2WPKH for bech32)
            function createScriptPubKey(address) {
                if (!address || typeof address !== 'string') {
                    console.error('Invalid address provided to createScriptPubKey:', address);
                    throw new Error('Invalid address: must be a string');
                }
                
                const decoded = decodeBech32(address);
                if (!decoded) {
                    throw new Error('Invalid bech32 address: ' + address);
                }
                
                // Convert data array to hex string
                const dataHex = decoded.data.map(byte => byte.toString(16).padStart(2, '0')).join('');
                
                // P2WPKH scriptPubKey: OP_0 <20-byte-key-hash>
                return '0014' + dataHex;
            }
            
            
            // Transaction Broadcasting Queue System
            // Variables already declared at top of DOMContentLoaded
            
            // Initialize broadcast queue from localStorage
            function initBroadcastQueue() {
                try {
                    const savedQueue = localStorage.getItem('broadcastQueue');
                    if (savedQueue) {
                        broadcastQueue = JSON.parse(savedQueue);
                        // Validate queue items
                        broadcastQueue = broadcastQueue.filter(item => 
                            item && item.tx && item.tx.raw && item.tx.txid
                        );
                    }
                    
                    // Load broadcast state
                    const savedState = localStorage.getItem('broadcastState');
                    if (savedState) {
                        const state = JSON.parse(savedState);
                        lastBroadcastBlock = state.lastBroadcastBlock || null;
                        transactionsInCurrentBlock = state.transactionsInCurrentBlock || 0;
                    }
                } catch (e) {
                    console.error('Error loading broadcast queue:', e);
                    broadcastQueue = [];
                }
                
                // Update queue status display
                updateQueueDisplay();
                
                // Start processing if there are items in queue
                if (broadcastQueue.length > 0 && electrumConnected) {
                    processQueue();
                }
            }
            
            // Save queue to localStorage
            function saveQueue() {
                try {
                    localStorage.setItem('broadcastQueue', JSON.stringify(broadcastQueue));
                    
                    // Save broadcast state
                    localStorage.setItem('broadcastState', JSON.stringify({
                        lastBroadcastBlock: lastBroadcastBlock,
                        transactionsInCurrentBlock: transactionsInCurrentBlock
                    }));
                } catch (e) {
                    console.error('Error saving broadcast queue:', e);
                }
            }
            
            // Add transactions to queue
            function broadcastTransactions(signedTransactions) {
                // Validate and add to queue
                let addedCount = 0;
                let skippedCount = 0;
                
                for (const signedTx of signedTransactions) {
                    // Ensure we have a hex string, not JSON
                    if (typeof signedTx.raw === 'object') {
                        console.error('ERROR: Transaction is JSON object, not hex string:', signedTx.raw);
                        showInAppNotification('Invalid Transaction', 'Transaction format is invalid. Must be a hex string.', 'error');
                        continue;
                    }
                    
                    // Check for duplicate transactions
                    const existingTx = broadcastQueue.find(item => item.tx.txid === signedTx.txid);
                    
                    if (existingTx) {
                        if (existingTx.status === 'cancelled') {
                            // Remove from cancelled and add as pending
                            broadcastQueue = broadcastQueue.filter(item => item.tx.txid !== signedTx.txid);
                            console.log(`Removed cancelled transaction ${signedTx.txid} from queue`);
                        } else if (existingTx.status === 'pending' || existingTx.status === 'complete' || existingTx.status === 'broadcasting') {
                            // Skip if already pending, broadcasting, or complete
                            console.log(`Skipping duplicate transaction ${signedTx.txid} (status: ${existingTx.status})`);
                            skippedCount++;
                            continue;
                        } else if (existingTx.status === 'failed') {
                            // Reset failed transaction for retry
                            existingTx.status = 'pending';
                            existingTx.attempts = 0;
                            existingTx.error = null;
                            existingTx.failedAt = null;
                            console.log(`Resetting failed transaction ${signedTx.txid} for retry`);
                            addedCount++;
                            continue;
                        }
                    }
                    
                    // Add to queue with metadata
                    broadcastQueue.push({
                        tx: signedTx,
                        addedAt: new Date().toISOString(),
                        attempts: 0,
                        status: 'pending'
                    });
                    addedCount++;
                }
                
                saveQueue();
                updateQueueDisplay();
                
                // Show notification about import results
                if (addedCount > 0 && skippedCount > 0) {
                    showInAppNotification('Import Complete', `Added ${addedCount} transaction(s), skipped ${skippedCount} duplicate(s)`, 'info');
                } else if (skippedCount > 0) {
                    showInAppNotification('No New Transactions', `All ${skippedCount} transaction(s) already in queue`, 'warning');
                } else if (addedCount > 0) {
                    showInAppNotification('Queued for Broadcast', 
                        `Added ${addedCount} transaction(s) to broadcast queue`, 
                        'info');
                }
                
                // Start processing if not already running
                if (!isQueueProcessing && electrumConnected && addedCount > 0) {
                    processQueue();
                }
            }
            
            // Process the broadcast queue
            function processQueue() {
                if (isQueueProcessing || !electrumConnected || broadcastQueue.length === 0) {
                    return;
                }
                
                isQueueProcessing = true;
                
                // Check if block has changed since last broadcast
                if (lastBroadcastBlock !== currentBlockHeight) {
                    // New block, reset counter
                    transactionsInCurrentBlock = 0;
                    lastBroadcastBlock = currentBlockHeight;
                }
                
                // Check if we've reached the limit for this block
                if (transactionsInCurrentBlock >= MAX_TRANSACTIONS_PER_BLOCK) {
                    // Wait for next block
                    console.log(`Reached limit of ${MAX_TRANSACTIONS_PER_BLOCK} transactions for block ${currentBlockHeight}. Waiting for next block.`);
                    isQueueProcessing = false;
                    updateQueueDisplay();
                    return;
                }
                
                // Get next pending transaction
                const nextItem = broadcastQueue.find(item => item.status === 'pending');
                if (!nextItem) {
                    isQueueProcessing = false;
                    updateQueueDisplay();
                    return;
                }
                
                // Broadcast the transaction
                nextItem.status = 'broadcasting';
                nextItem.attempts++;
                updateQueueDisplay();
                
                electrumRequest('blockchain.transaction.broadcast', [nextItem.tx.raw], function(result, error) {
                    if (error) {
                        console.error('Broadcast error:', error);
                        
                        // Handle specific errors
                        if (error.message && error.message.includes('already in mempool')) {
                            // Transaction already broadcast, mark as complete
                            nextItem.status = 'complete';
                            nextItem.result = 'Already in mempool';
                            nextItem.completedAt = new Date().toISOString();
                        } else if (nextItem.attempts >= 3) {
                            // Max retries reached
                            nextItem.status = 'failed';
                            nextItem.error = error.message || error;
                            nextItem.failedAt = new Date().toISOString();
                            showInAppNotification('Broadcast Failed', 
                                `Failed to broadcast transaction after 3 attempts: ${error.message || error}`, 
                                'error');
                        } else {
                            // Retry later
                            nextItem.status = 'pending';
                        }
                    } else {
                        // Success
                        nextItem.status = 'complete';
                        nextItem.result = result;
                        nextItem.broadcastBlock = currentBlockHeight;
                        nextItem.completedAt = new Date().toISOString();
                        lastBroadcastBlock = currentBlockHeight;
                        transactionsInCurrentBlock++;
                        
                        console.log(`Transaction broadcast (${transactionsInCurrentBlock}/${MAX_TRANSACTIONS_PER_BLOCK} this block):`, result);
                        showInAppNotification('Transaction Sent', 
                            `Successfully broadcast transaction: ${nextItem.tx.txid.substring(0, 16)}...`, 
                            'success');
                        
                        // Refresh balance
                        refreshBalance();
                    }
                    
                    saveQueue();
                    updateQueueDisplay();
                    
                    // Clean up completed/failed items periodically
                    cleanupQueue();
                    
                    // Continue processing
                    isQueueProcessing = false;
                    
                    // Continue processing based on status
                    if (nextItem.status === 'complete') {
                        // Check if we can broadcast more in this block
                        if (transactionsInCurrentBlock < MAX_TRANSACTIONS_PER_BLOCK && 
                            broadcastQueue.some(item => item.status === 'pending')) {
                            // Continue with next transaction
                            setTimeout(() => processQueue(), 1000);
                        }
                        // Otherwise will resume on next block
                    } else {
                        // Try next item immediately if this one failed
                        setTimeout(() => processQueue(), 1000);
                    }
                });
            }
            
            // Clean up old completed/failed items
            function cleanupQueue() {
                const cutoffTime = new Date(Date.now() - 24 * 60 * 60 * 1000); // 24 hours
                broadcastQueue = broadcastQueue.filter(item => {
                    if (item.status === 'pending' || item.status === 'broadcasting') {
                        return true; // Keep pending items
                    }
                    const itemTime = new Date(item.addedAt);
                    return itemTime > cutoffTime; // Keep recent completed/failed items
                });
                
                // If queue is now empty, clear from localStorage
                if (broadcastQueue.length === 0) {
                    localStorage.removeItem('broadcastQueue');
                    localStorage.removeItem('broadcastState');
                } else {
                    saveQueue();
                }
            }
            
            // Update queue display
            function updateQueueDisplay() {
                if (!queueStatusElement) {
                    // Create queue status element if it doesn't exist
                    createQueueStatusElement();
                }
                
                const pendingCount = broadcastQueue.filter(item => item.status === 'pending').length;
                const broadcastingCount = broadcastQueue.filter(item => item.status === 'broadcasting').length;
                const completeCount = broadcastQueue.filter(item => item.status === 'complete').length;
                const failedCount = broadcastQueue.filter(item => item.status === 'failed').length;
                const cancelledCount = broadcastQueue.filter(item => item.status === 'cancelled').length;
                
                if (broadcastQueue.length === 0) {
                    queueStatusElement.style.display = 'none';
                    // Clear any pending auto-clear timeout
                    if (autoClearTimeout) {
                        clearTimeout(autoClearTimeout);
                        autoClearTimeout = null;
                    }
                    return;
                }
                
                queueStatusElement.style.display = 'block';
                
                // Check if all transactions are complete (no pending, no broadcasting, no failed)
                if (pendingCount === 0 && broadcastingCount === 0 && failedCount === 0 && completeCount > 0) {
                    // Schedule auto-clear after 10 seconds
                    if (!autoClearTimeout) {
                        autoClearTimeout = setTimeout(() => {
                            clearCompletedQueue();
                            showInAppNotification('Queue Cleared', 'All completed transactions have been cleared from the queue', 'info');
                            autoClearTimeout = null;
                        }, 10000);
                    }
                } else {
                    // Cancel auto-clear if there are pending, broadcasting, or failed transactions
                    if (autoClearTimeout) {
                        clearTimeout(autoClearTimeout);
                        autoClearTimeout = null;
                    }
                }
                
                let statusHTML = '<div style="padding: 10px; background: #f8f9fa; border-radius: 4px; margin-bottom: 10px;">';
                statusHTML += '<h4 style="margin: 0 0 10px 0;">Broadcast Queue</h4>';
                
                // Calculate amounts for each status
                const pendingAmount = broadcastQueue
                    .filter(item => item.status === 'pending')
                    .reduce((sum, item) => sum + (item.tx.details?.outputs?.[0]?.value || 0), 0);
                const broadcastingAmount = broadcastQueue
                    .filter(item => item.status === 'broadcasting')
                    .reduce((sum, item) => sum + (item.tx.details?.outputs?.[0]?.value || 0), 0);
                const completeAmount = broadcastQueue
                    .filter(item => item.status === 'complete')
                    .reduce((sum, item) => sum + (item.tx.details?.outputs?.[0]?.value || 0), 0);
                const failedAmount = broadcastQueue
                    .filter(item => item.status === 'failed')
                    .reduce((sum, item) => sum + (item.tx.details?.outputs?.[0]?.value || 0), 0);
                const cancelledAmount = broadcastQueue
                    .filter(item => item.status === 'cancelled')
                    .reduce((sum, item) => sum + (item.tx.details?.outputs?.[0]?.value || 0), 0);
                
                const totalAmount = pendingAmount + broadcastingAmount + completeAmount + failedAmount + cancelledAmount;
                
                // Summary with clickable items
                statusHTML += '<div style="margin-bottom: 10px; font-size: 12px;">';
                if (broadcastingCount > 0) {
                    statusHTML += `<span style="color: #0066cc;">● Broadcasting now... (${(broadcastingAmount / 100000000).toFixed(8)} ALPHA)</span><br>`;
                }
                if (pendingCount > 0) {
                    statusHTML += `<a href="#" onclick="showQueueDetails('pending'); return false;" style="color: #666; text-decoration: none; cursor: pointer;">◯ ${pendingCount} pending (${(pendingAmount / 100000000).toFixed(8)} ALPHA)</a><br>`;
                }
                if (completeCount > 0) {
                    statusHTML += `<a href="#" onclick="showQueueDetails('complete'); return false;" style="color: #00a000; text-decoration: none; cursor: pointer;">✓ ${completeCount} complete (${(completeAmount / 100000000).toFixed(8)} ALPHA)</a><br>`;
                }
                if (failedCount > 0) {
                    statusHTML += `<a href="#" onclick="showQueueDetails('failed'); return false;" style="color: #cc0000; text-decoration: none; cursor: pointer;">✗ ${failedCount} failed (${(failedAmount / 100000000).toFixed(8)} ALPHA)</a><br>`;
                }
                if (cancelledCount > 0) {
                    statusHTML += `<a href="#" onclick="showQueueDetails('cancelled'); return false;" style="color: #f59e0b; text-decoration: none; cursor: pointer;">⊘ ${cancelledCount} cancelled (${(cancelledAmount / 100000000).toFixed(8)} ALPHA)</a><br>`;
                }
                
                statusHTML += `<br><strong>Total queued: ${(totalAmount / 100000000).toFixed(8)} ALPHA</strong>`;
                
                // Progress bar
                if (totalAmount > 0) {
                    const progressPercent = (completeAmount / totalAmount) * 100;
                    statusHTML += `
                        <div style="margin-top: 10px;">
                            <div style="background: #e0e0e0; height: 20px; border-radius: 10px; overflow: hidden; position: relative;">
                                <div style="background: #10b981; height: 100%; width: ${progressPercent}%; transition: width 0.3s ease;"></div>
                                <div style="position: absolute; top: 0; left: 0; right: 0; height: 100%; display: flex; align-items: center; justify-content: center; font-size: 11px; font-weight: 600;">
                                    ${(completeAmount / 100000000).toFixed(8)} / ${(totalAmount / 100000000).toFixed(8)} ALPHA (${progressPercent.toFixed(1)}%)
                                </div>
                            </div>
                        </div>
                    `;
                }
                
                if (lastBroadcastBlock === currentBlockHeight && transactionsInCurrentBlock >= MAX_TRANSACTIONS_PER_BLOCK && pendingCount > 0) {
                    const nextBlock = currentBlockHeight ? currentBlockHeight + 1 : 'next';
                    const transactionText = pendingCount === 1 ? 'transaction' : 'transactions';
                    statusHTML += `<br><em style="color: #666;">Limit reached (${MAX_TRANSACTIONS_PER_BLOCK} per block). ${pendingCount} more ${transactionText} to go, waiting for block ${nextBlock}...</em>`;
                } else if (pendingCount > 0 && transactionsInCurrentBlock > 0) {
                    const remaining = MAX_TRANSACTIONS_PER_BLOCK - transactionsInCurrentBlock;
                    const canBroadcast = Math.min(remaining, pendingCount);
                    if (canBroadcast > 0) {
                        statusHTML += `<br><em style="color: #666;">Can broadcast ${canBroadcast} more transaction${canBroadcast > 1 ? 's' : ''} in current block</em>`;
                    }
                }
                
                statusHTML += '</div>';
                
                // Queue control buttons
                statusHTML += '<div style="margin-top: 10px;">';
                
                // Cancel pending button
                if (pendingCount > 0 || broadcastingCount > 0) {
                    statusHTML += `<button onclick="cancelPendingTransactions()" style="padding: 4px 8px; font-size: 11px; background: #ef4444; color: white; border: none; border-radius: 3px; cursor: pointer; margin-right: 5px;">Cancel Pending</button>`;
                }
                
                // Clear queue button
                if (completeCount > 0 || failedCount > 0 || cancelledCount > 0) {
                    statusHTML += `<button onclick="clearQueue()" style="padding: 4px 8px; font-size: 11px; background: #6b7280; color: white; border: none; border-radius: 3px; cursor: pointer;">Clear History</button>`;
                }
                
                statusHTML += '</div>';
                
                statusHTML += '</div>';
                
                queueStatusElement.innerHTML = statusHTML;
                
                // Update balance and UTXO display when queue changes
                updateCommonBalance();
                updateUtxoListDisplay();
            }
            
            // Create queue status element
            function createQueueStatusElement() {
                queueStatusElement = document.createElement('div');
                queueStatusElement.id = 'broadcastQueueStatus';
                queueStatusElement.style.display = 'none';
                
                // Insert after the wallet info section
                if (walletInfo && walletInfo.nextSibling) {
                    walletInfo.parentNode.insertBefore(queueStatusElement, walletInfo.nextSibling);
                } else {
                    // Fallback: insert at the beginning of the main content
                    const mainContent = document.querySelector('.container');
                    if (mainContent) {
                        mainContent.insertBefore(queueStatusElement, mainContent.firstChild);
                    }
                }
            }
            
            // Clear all items from queue except pending
            window.clearQueue = function() {
                broadcastQueue = broadcastQueue.filter(item => 
                    item.status === 'pending' || item.status === 'broadcasting'
                );
                
                // If queue is now empty, clear from localStorage
                if (broadcastQueue.length === 0) {
                    localStorage.removeItem('broadcastQueue');
                    localStorage.removeItem('broadcastState');
                } else {
                    saveQueue();
                }
                
                updateQueueDisplay();
            };
            
            // Cancel all pending transactions
            window.cancelPendingTransactions = function() {
                // Mark all pending and broadcasting transactions as cancelled
                broadcastQueue = broadcastQueue.map(item => {
                    if (item.status === 'pending' || item.status === 'broadcasting') {
                        return {
                            ...item,
                            status: 'cancelled',
                            cancelledAt: new Date().toISOString()
                        };
                    }
                    return item;
                });
                
                // Stop queue processing
                isQueueProcessing = false;
                
                // Save and update display
                saveQueue();
                updateQueueDisplay();
                
                showInAppNotification('Queue Cancelled', 'All pending transactions have been cancelled', 'warning');
            };
            
            // Clear completed items from queue (used by auto-clear)
            window.clearCompletedQueue = function() {
                broadcastQueue = broadcastQueue.filter(item => 
                    item.status !== 'complete'
                );
                
                // If queue is now empty, clear from localStorage
                if (broadcastQueue.length === 0) {
                    localStorage.removeItem('broadcastQueue');
                    localStorage.removeItem('broadcastState');
                } else {
                    saveQueue();
                }
                
                updateQueueDisplay();
            };
            
            // Handle new blocks
            function onNewBlock() {
                console.log(`New block ${currentBlockHeight} detected`);
                updateQueueDisplay();
                
                // Resume queue processing if we were waiting
                if (broadcastQueue.some(item => item.status === 'pending') && !isQueueProcessing) {
                    console.log('Resuming queue processing for new block');
                    processQueue();
                }
            }
            
            // Helper function to display modal
            function showModal(content) {
                const modal = document.createElement('div');
                modal.style.cssText = 'display: block; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;';
                modal.id = 'queueDetailsModal';
                
                const modalInner = document.createElement('div');
                modalInner.style.cssText = 'position: relative; margin: 50px auto; max-width: 600px; max-height: 80vh; overflow-y: auto; background: white; border-radius: 12px; padding: 30px;';
                modalInner.innerHTML = content;
                
                modal.appendChild(modalInner);
                document.body.appendChild(modal);
                
                // Add close function to window
                window.closeQueueModal = function() {
                    modal.remove();
                };
                
                // Close on background click
                modal.addEventListener('click', function(e) {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
                
                // Close on Escape key
                document.addEventListener('keydown', function escHandler(e) {
                    if (e.key === 'Escape') {
                        modal.remove();
                        document.removeEventListener('keydown', escHandler);
                    }
                });
            }
            
            // Show queue details modal
            window.showQueueDetails = function(status) {
                const filteredItems = broadcastQueue.filter(item => item.status === status);
                if (filteredItems.length === 0) return;
                
                let modalContent = '';
                let modalTitle = '';
                
                switch(status) {
                    case 'pending':
                        modalTitle = 'Pending Transactions';
                        break;
                    case 'complete':
                        modalTitle = 'Completed Transactions';
                        break;
                    case 'failed':
                        modalTitle = 'Failed Transactions';
                        break;
                    case 'cancelled':
                        modalTitle = 'Cancelled Transactions';
                        break;
                }
                
                modalContent = `
                    <h2 style="margin-bottom: 20px; color: #111827;">${modalTitle}</h2>
                    <div style="max-height: 400px; overflow-y: auto;">`;
                
                filteredItems.forEach((item, index) => {
                    const details = item.tx.details;
                    const txid = item.tx.txid;
                    
                    // Calculate total amount from all outputs (excluding change)
                    let totalAmount = 0;
                    const outputs = details?.outputs || [];
                    let destinations = [];
                    
                    outputs.forEach(output => {
                        if (output.address && output.address !== details?.changeAddress) {
                            totalAmount += output.value || 0;
                            destinations.push(output.address);
                        }
                    });
                    
                    // If no non-change outputs, show all outputs
                    if (destinations.length === 0) {
                        destinations = outputs.map(output => output.address).filter(addr => addr);
                        totalAmount = outputs.reduce((sum, output) => sum + (output.value || 0), 0);
                    }
                    
                    const amount = totalAmount > 0 ? (totalAmount / 100000000).toFixed(8) : 'Unknown';
                    const recipient = destinations.length > 0 ? destinations.join(', ') : 'Unknown';
                    
                    // Get from address - the input is a UTXO that should have an address field
                    // or we can use the changeAddress which is the sender's address
                    const fromAddress = details?.changeAddress || details?.input?.address || 'Unknown';
                    
                    modalContent += `
                        <div style="margin-top: 15px; padding: 15px; background: #f9fafb; border-radius: 8px; border: 1px solid #e5e7eb;">
                            <div style="color: #111827; font-weight: 600; margin-bottom: 10px;">Transaction ${index + 1}</div>
                            <div style="font-size: 14px; color: #374151;">
                                <div style="margin-bottom: 5px;"><strong>From:</strong> <span style="font-family: monospace; word-break: break-all; color: #6b7280;">${fromAddress}</span></div>
                                <div style="margin-bottom: 5px;"><strong>To:</strong> <span style="font-family: monospace; word-break: break-all; color: #6b7280;">${recipient}</span></div>
                                <div style="margin-bottom: 5px;"><strong>Amount:</strong> ${amount} ALPHA</div>
                                <div style="margin-bottom: 5px;"><strong>TxID:</strong> <span style="font-family: monospace; word-break: break-all; color: #6b7280;">${txid}</span></div>
                                <div style="margin-bottom: 5px;"><strong>Added:</strong> ${new Date(item.addedAt).toLocaleString()}</div>
                    `;
                    
                    if (status === 'complete') {
                        modalContent += `<div style="margin-top: 10px;"><a href="https://www.unicity.network/tx/${txid}" target="_blank" style="color: #0066cc; text-decoration: none; font-weight: 500;">View on Explorer →</a></div>`;
                    } else if (status === 'failed') {
                        modalContent += `<div style="color: #dc2626; margin-top: 10px; padding: 10px; background: #fee2e2; border-radius: 4px;">
                            <strong>Error:</strong> ${item.error || 'Unknown error'}<br>
                            <strong>Attempts:</strong> ${item.attempts}
                        </div>`;
                    } else if (status === 'cancelled') {
                        modalContent += `<div style="color: #d97706; margin-top: 10px; padding: 10px; background: #fef3c7; border-radius: 4px;">
                            <strong>Status:</strong> Cancelled by user<br>
                            <strong>Cancelled at:</strong> ${new Date(item.cancelledAt).toLocaleString()}
                        </div>`;
                        
                        // Add action buttons for cancelled transactions
                        modalContent += `
                            <div style="margin-top: 10px; display: flex; gap: 10px;">
                                <button onclick="resendTransaction('${txid}')" style="padding: 6px 12px; background: #10b981; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Resend</button>
                                <button onclick="saveSingleTransaction('${txid}')" style="padding: 6px 12px; background: #3b82f6; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Save</button>
                                <button onclick="deleteTransaction('${txid}')" style="padding: 6px 12px; background: #ef4444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Delete</button>
                            </div>
                        `;
                    }
                    
                    modalContent += '</div></div>';
                });
                
                modalContent += '</div>';
                
                // Add export button for failed or cancelled transactions
                if (status === 'failed' || status === 'cancelled') {
                    const buttonText = status === 'failed' ? 'Export Failed Transactions' : 'Export Cancelled Transactions';
                    const exportStatus = status === 'failed' ? "['failed']" : "['cancelled']";
                    modalContent += `
                        <div style="margin-top: 20px; padding: 15px; background: #fef3c7; border: 1px solid #f59e0b; border-radius: 4px;">
                            <button onclick="exportFailedTransactions(${exportStatus})" style="padding: 8px 16px; background: #f59e0b; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">${buttonText}</button>
                            <p style="margin: 10px 0 0 0; font-size: 12px; color: #92400e;">
                                ${status === 'failed' ? 
                                    'Please email the exported file to <strong>vladimir@unicity-labs.com</strong> for investigation.' :
                                    'You can re-import and broadcast these transactions later.'}
                            </p>
                        </div>
                    `;
                }
                
                // Add bulk action buttons for cancelled transactions
                if (status === 'cancelled' && filteredItems.length > 0) {
                    modalContent += `
                        <div style="margin-top: 20px; padding: 15px; background: #f3f4f6; border: 1px solid #e5e7eb; border-radius: 4px; text-align: center;">
                            <button onclick="resendAllCancelled()" style="padding: 8px 16px; background: #10b981; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; margin-right: 10px;">Resend All</button>
                            <button onclick="deleteAllCancelled()" style="padding: 8px 16px; background: #ef4444; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">Delete All</button>
                        </div>
                    `;
                }
                
                // Add close button
                modalContent += `
                    <div style="margin-top: 20px; text-align: center;">
                        <button onclick="closeQueueModal()" style="padding: 10px 30px; background: #6b7280; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500;">Close</button>
                    </div>
                `;
                
                showModal(modalContent);
            };
            
            // Resend a single cancelled transaction
            window.resendTransaction = function(txid) {
                // Check if connected
                if (!electrumConnected) {
                    showInAppNotification('Not Connected', 'Please connect to Fulcrum server first', 'warning');
                    return;
                }
                
                // Find the transaction
                const item = broadcastQueue.find(item => item.tx.txid === txid);
                if (!item || item.status !== 'cancelled') {
                    showInAppNotification('Error', 'Transaction not found or not cancelled', 'error');
                    return;
                }
                
                // Update status to pending
                item.status = 'pending';
                item.attempts = 0;
                item.cancelledAt = null;
                
                saveQueue();
                updateQueueDisplay();
                closeQueueModal();
                
                showInAppNotification('Transaction Requeued', 'Transaction has been queued for broadcast', 'success');
                
                // Start processing if not already running
                if (!isQueueProcessing) {
                    processQueue();
                }
            };
            
            // Save a single transaction
            window.saveSingleTransaction = function(txid) {
                const item = broadcastQueue.find(item => item.tx.txid === txid);
                if (!item) {
                    showInAppNotification('Error', 'Transaction not found', 'error');
                    return;
                }
                
                const exportData = {
                    version: '1.0',
                    timestamp: new Date().toISOString(),
                    network: 'alpha',
                    transactions: [{
                        raw: item.tx.raw,
                        txid: item.tx.txid,
                        details: item.tx.details || null,
                        status: item.status,
                        error: item.error || null,
                        attempts: item.attempts || 0,
                        cancelledAt: item.cancelledAt || null,
                        failedAt: item.failedAt || null
                    }]
                };
                
                const dataStr = JSON.stringify(exportData, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `transaction_${txid.substring(0, 8)}_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                URL.revokeObjectURL(url);
                
                showInAppNotification('Saved', 'Transaction saved to file', 'info');
            };
            
            // Delete a transaction from the queue
            window.deleteTransaction = function(txid) {
                if (confirm('Are you sure you want to delete this transaction?')) {
                    broadcastQueue = broadcastQueue.filter(item => item.tx.txid !== txid);
                    
                    // Update localStorage
                    if (broadcastQueue.length === 0) {
                        localStorage.removeItem('broadcastQueue');
                    } else {
                        saveQueue();
                    }
                    
                    updateQueueDisplay();
                    
                    // Refresh the modal to show updated list
                    const remainingCancelled = broadcastQueue.filter(item => item.status === 'cancelled').length;
                    if (remainingCancelled > 0) {
                        closeQueueModal();
                        showQueueDetails('cancelled');
                    } else {
                        closeQueueModal();
                    }
                    
                    showInAppNotification('Deleted', 'Transaction removed from queue', 'info');
                }
            };
            
            // Resend all cancelled transactions
            window.resendAllCancelled = function() {
                // Check if connected
                if (!electrumConnected) {
                    showInAppNotification('Not Connected', 'Please connect to Fulcrum server first', 'warning');
                    return;
                }
                
                const cancelledItems = broadcastQueue.filter(item => item.status === 'cancelled');
                if (cancelledItems.length === 0) {
                    showInAppNotification('No Cancelled Transactions', 'No cancelled transactions to resend', 'info');
                    return;
                }
                
                // Update all cancelled transactions to pending
                cancelledItems.forEach(item => {
                    item.status = 'pending';
                    item.attempts = 0;
                    item.cancelledAt = null;
                });
                
                saveQueue();
                updateQueueDisplay();
                closeQueueModal();
                
                showInAppNotification('Transactions Requeued', `${cancelledItems.length} transaction(s) have been queued for broadcast`, 'success');
                
                // Start processing if not already running
                if (!isQueueProcessing) {
                    processQueue();
                }
            };
            
            // Delete all cancelled transactions
            window.deleteAllCancelled = function() {
                const cancelledCount = broadcastQueue.filter(item => item.status === 'cancelled').length;
                
                if (cancelledCount === 0) {
                    showInAppNotification('No Cancelled Transactions', 'No cancelled transactions to delete', 'info');
                    return;
                }
                
                if (confirm(`Are you sure you want to delete all ${cancelledCount} cancelled transaction(s)?`)) {
                    broadcastQueue = broadcastQueue.filter(item => item.status !== 'cancelled');
                    
                    // Update localStorage
                    if (broadcastQueue.length === 0) {
                        localStorage.removeItem('broadcastQueue');
                    } else {
                        saveQueue();
                    }
                    
                    updateQueueDisplay();
                    closeQueueModal();
                    
                    showInAppNotification('Deleted', `${cancelledCount} cancelled transaction(s) removed from queue`, 'info');
                }
            };
            
            // Export failed or cancelled transactions
            window.exportFailedTransactions = function(includeStatus = ['failed', 'cancelled']) {
                const exportItems = broadcastQueue.filter(item => 
                    includeStatus.includes(item.status)
                );
                if (exportItems.length === 0) return;
                
                const exportData = {
                    version: '1.0',
                    timestamp: new Date().toISOString(),
                    network: 'alpha',
                    transactions: exportItems.map(item => ({
                        raw: item.tx.raw,
                        txid: item.tx.txid,
                        details: item.tx.details || null,
                        status: item.status,
                        error: item.error || null,
                        attempts: item.attempts || 0,
                        cancelledAt: item.cancelledAt || null,
                        failedAt: item.failedAt || null
                    }))
                };
                
                const dataStr = JSON.stringify(exportData, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const link = document.createElement('a');
                link.href = url;
                const filePrefix = includeStatus.includes('cancelled') && !includeStatus.includes('failed') ? 
                    'cancelled_transactions' : 'failed_transactions';
                link.download = `${filePrefix}_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                URL.revokeObjectURL(url);
                
                // Show appropriate notification based on transaction type
                if (includeStatus.includes('cancelled') && !includeStatus.includes('failed')) {
                    showInAppNotification('Exported', 'Cancelled transactions exported. You can re-import and broadcast them later.', 'info');
                } else {
                    showInAppNotification('Exported', 'Failed transactions exported. Please email to vladimir@unicity-labs.com', 'info');
                }
            };
            
            // Save transactions for offline broadcast
            function saveTransactionsOffline(signedTransactions) {
                const exportData = {
                    version: '1.0',
                    timestamp: new Date().toISOString(),
                    network: 'alpha',
                    transactions: signedTransactions.map(tx => ({
                        raw: tx.raw,
                        txid: tx.txid,
                        details: tx.details || null
                    }))
                };
                
                const dataStr = JSON.stringify(exportData, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `alpha-transactions-${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showInAppNotification('Transactions Saved', `Saved ${signedTransactions.length} signed transaction(s) to file`, 'success');
            }
            
            // Import and broadcast transactions from file
            document.getElementById('txFileInput').addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const importedData = JSON.parse(event.target.result);
                        
                        if (!importedData.transactions || !Array.isArray(importedData.transactions)) {
                            showInAppNotification('Import Failed', 'Invalid transaction file format', 'error');
                            return;
                        }
                        
                        // Check if we're online
                        if (!electrumSocket || electrumSocket.readyState !== WebSocket.OPEN) {
                            showInAppNotification('Not Connected', 'Please connect to Fulcrum server first', 'warning');
                            return;
                        }
                        
                        // Show confirmation
                        const txCount = importedData.transactions.length;
                        showInAppNotification('Transactions Loaded', `Loaded ${txCount} transaction(s) from file`, 'info');
                        
                        if (confirm(`Import and broadcast ${txCount} transaction(s)?`)) {
                            const rawTransactions = importedData.transactions.map(tx => {
                                // Check if raw is a JSON object (old format) or hex string (new format)
                                if (typeof tx.raw === 'object') {
                                    alert('Error: This transaction file contains an old format that cannot be broadcast. Please create new transactions.');
                                    throw new Error('Old transaction format detected');
                                }
                                
                                // Check if it's a JSON string (also old format)
                                if (typeof tx.raw === 'string' && tx.raw.startsWith('{')) {
                                    alert('Error: This transaction file contains JSON-formatted transactions from an old version. Please create new transactions with the updated wallet.');
                                    throw new Error('JSON transaction format detected - need hex format');
                                }
                                
                                // Check if it looks like a hex string
                                if (typeof tx.raw === 'string' && !tx.raw.match(/^[0-9a-fA-F]+$/)) {
                                    alert('Error: Transaction is not in valid hexadecimal format.');
                                    throw new Error('Invalid transaction hex format');
                                }
                                
                                return {
                                    raw: tx.raw,
                                    txid: tx.txid,
                                    details: tx.details || null
                                };
                            });
                            broadcastTransactions(rawTransactions);
                        }
                        
                    } catch (error) {
                        showInAppNotification('Read Error', 'Error reading transaction file: ' + error.message, 'error');
                        console.error('Import error:', error);
                    }
                };
                
                reader.readAsText(file);
                e.target.value = ''; // Clear input for re-use
            });
            
        });
    </script>

    <!-- Transaction Confirmation Modal -->
    <div id="txConfirmModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;">
        <div style="position: relative; margin: 50px auto; max-width: 600px; max-height: 80vh; overflow-y: auto; background: white; border-radius: 12px; padding: 30px;">
            <h2 style="margin-bottom: 20px;">Confirm Transaction</h2>
            <div id="txConfirmDetails" style="margin-bottom: 20px;">
                <!-- Transaction details will be inserted here -->
            </div>
            <div class="button-container" style="justify-content: space-between;">
                <button onclick="cancelTransaction()" class="button" style="background-color: #ef4444;">
                    Cancel
                </button>
                <button onclick="confirmAndSignTransactions()" class="button" style="background-color: #10b981;">
                    Confirm & Sign
                </button>
            </div>
        </div>
    </div>

    <!-- Help Modal -->
    <div id="helpModal" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeHelpModal()">&times;</span>
            <h2>How to use this wallet</h2>
            
            <h3 style="margin-top: 20px; margin-bottom: 15px; color: #333;">Getting Started</h3>
            <ul style="margin-bottom: 20px;">
                <li><strong>Create New Wallet:</strong> Click the "Create" button to generate a new wallet with a secure private key</li>
                <li><strong>Load Existing Wallet:</strong> Click the "Load" button to import from:
                    <ul style="margin-top: 5px;">
                        <li><strong>Text Files (.txt):</strong> Import wallets from WIF private keys or previously saved BIP32 keys</li>
                        <li><strong>BIP32 Wallet Database (.dat):</strong> Import BIP32 hierarchical deterministic wallets from wallet.dat files</li>
                        <li><strong>Encrypted Backup:</strong> Restore from password-protected wallet backups (click "Decrypt" button after selecting file)</li>
                    </ul>
                </li>
                <li><strong>Wallet Scanning (BIP32):</strong>
                    <ul style="margin-top: 5px;">
                        <li>When opening a BIP32 wallet file, the wallet automatically scans for addresses with balances</li>
                        <li>The scanner will check up to 100 addresses (configurable) for funds</li>
                        <li>Found addresses are displayed with their balances and derivation paths</li>
                        <li>Select any discovered wallet to use for transactions</li>
                        <li>After initial scan, a "Rescan Wallets" button appears to force a fresh scan and clear cache</li>
                    </ul>
                </li>
                <li><strong>Network Connection:</strong> The wallet automatically connects to the Unicity network when online. You can also manually connect/disconnect using the endpoint controls</li>
            </ul>
            
            <h3 style="margin-top: 20px; margin-bottom: 15px; color: #333;">Importing Wallets</h3>
            <ul style="margin-bottom: 20px;">
                <li><strong>Standard Backup Import:</strong> Use the "Load" button to import wallet files. If the backup is encrypted, you'll need to enter the password.</li>
                <li><strong>BIP32 wallet.dat Import (EXPERIMENTAL):</strong>
                    <div style="margin-top: 10px; padding: 10px; background-color: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px;">
                        <strong>⚠️ Important Notes:</strong>
                        <ul style="margin-top: 5px;">
                            <li>Only <strong>unencrypted</strong> wallet.dat files are currently supported</li>
                            <li>No backup copy of wallet.dat is needed - the file is only read, not modified</li>
                            <li><strong>Verify imported addresses:</strong> We cannot guarantee correct address restoration. Always compare with alpha-qt or alpha-cli to ensure the right addresses were loaded</li>
                            <li>The scanner checks 100 regular addresses and 100 change addresses by default</li>
                            <li>You can select any non-empty address found during the scan</li>
                            <li>To decrypt wallet.dat: use <code>alpha-cli walletpassphrase "yourpassword" 600</code> then copy the wallet.dat</li>
                        </ul>
                    </div>
                </li>
            </ul>
            
            <h3 style="margin-top: 20px; margin-bottom: 15px; color: #333;">Exporting from Alpha Core (alpha-cli/alpha-qt)</h3>
            <ul style="margin-bottom: 20px;">
                <li><strong>Method 1: Direct wallet.dat Copy (Recommended for BIP32 wallets):</strong>
                    <ol style="margin-top: 5px; margin-left: 20px;">
                        <li>Stop alpha-qt or alpha daemon: <code>alpha-cli stop</code></li>
                        <li>Locate your wallet.dat file (usually in ~/.alpha/ or datadir)</li>
                        <li>If wallet is encrypted, temporarily decrypt it:
                            <ul style="margin-top: 5px;">
                                <li>Start alpha daemon/qt again</li>
                                <li>Run: <code>alpha-cli walletpassphrase "yourpassword" 600</code></li>
                                <li>Stop the daemon and copy wallet.dat while it's decrypted</li>
                            </ul>
                        </li>
                        <li>Copy the wallet.dat file to a safe location</li>
                        <li>Use the "Load" button in this wallet to import the wallet.dat file</li>
                    </ol>
                </li>
                <li><strong>Method 2: Export with dumpwallet (Alternative):</strong>
                    <ol style="margin-top: 5px; margin-left: 20px;">
                        <li>If wallet is encrypted, unlock it: <code>alpha-cli walletpassphrase "yourpassword" 600</code></li>
                        <li>Export wallet keys: <code>alpha-cli dumpwallet "wallet_export.txt"</code></li>
                        <li>The exported file contains all private keys in WIF format</li>
                        <li>You can import individual WIF keys using the "Load" button</li>
                        <li>Lock wallet after export: <code>alpha-cli walletlock</code></li>
                    </ol>
                </li>
                <li><strong>Method 3: Backup wallet (For safekeeping):</strong>
                    <ol style="margin-top: 5px; margin-left: 20px;">
                        <li>Create a backup: <code>alpha-cli backupwallet "wallet_backup.dat"</code></li>
                        <li>This creates a copy of your wallet.dat that can be imported the same way</li>
                    </ol>
                </li>
            </ul>
            
            <h3 style="margin-top: 20px; margin-bottom: 15px; color: #333;">Security</h3>
            <ul style="margin-bottom: 20px;">
                <li><strong>Save Your Wallet:</strong> Click the "Save" button to export your wallet with optional password protection. Write down the password - there's no recovery if forgotten!</li>
                <li><strong>Backup Regularly:</strong> Use the "Save" button to create wallet backups. Store backups in multiple secure locations</li>
                <li><strong>Offline Mode:</strong> For maximum security, <a href="#" onclick="downloadWalletPage(); return false;">download this page</a> and use it on an offline computer</li>
            </ul>
            
            <h3 style="margin-top: 20px; margin-bottom: 15px; color: #333;">Receiving Funds</h3>
            <ul style="margin-bottom: 20px;">
                <li>Your address is displayed in the wallet section</li>
                <li>Click the QR code icon to show a scannable code</li>
                <li>Share your address or QR code with the sender</li>
                <li>When connected, balance updates automatically</li>
            </ul>
            
            <h3 style="margin-top: 20px; margin-bottom: 15px; color: #333;">Sending Funds</h3>
            <ul style="margin-bottom: 20px;">
                <li><strong>Online Mode:</strong> Enter recipient address and amount, review fees, then click Send and broadcast directly</li>
                <li><strong>Offline Mode (Cold Wallet) - Two Options:</strong>
                    <div style="margin-top: 10px; padding: 10px; background-color: #e6f7ff; border-radius: 4px;">
                        <strong>Option A: Prepare Transaction Online (Recommended)</strong>
                        <ol style="margin-top: 5px;">
                            <li>In watch-only mode, enter recipient address and amount, then click Send</li>
                            <li>Export the transaction template (includes only required UTXOs)</li>
                            <li>Transfer the template file to your offline computer</li>
                            <li>Import the template - transaction details will auto-fill</li>
                            <li>Review and sign the transaction offline</li>
                            <li>Transfer back to online computer and broadcast using "Import & Broadcast"</li>
                        </ol>
                    </div>
                    <div style="margin-top: 10px; padding: 10px; background-color: #f0f0f0; border-radius: 4px;">
                        <strong>Option B: Prepare Transaction Offline</strong>
                        <ol style="margin-top: 5px;">
                            <li>Export UTXOs as JSON file at online computer using "Export UTXOs"</li>
                            <li>Transfer the UTXO file to your offline computer</li>
                            <li>Import UTXOs and create the transaction offline by setting the recipient address, amount, review fees</li>
                            <li>At the offline computer, sign and export the transaction by clicking Send</li>
                            <li>Transfer back to online computer and broadcast using "Import & Broadcast"</li>
                        </ol>
                    </div>
                    <p style="margin-top: 10px; padding: 10px; background-color: #f3f4f6; border-radius: 4px; font-size: 13px;">
                        <strong>Note on Cold Wallets:</strong> The wallet used to create and sign transactions should be stored only at an offline machine (cold wallet). The wallet state (UTXOs into the wallet's address) is read at the online machine in watch-only mode (we provide only public address at the online machine). The full wallet is at the isolated offline machine only. This is a very secure way of storing large funds, since it is not possible to access the offline machine, and thus hack it and spend the owner's funds. On the other hand, it takes more effort to follow this flow every time the owner needs to spend funds. That is why it is called a "Cold wallet". Note however, that we do not need the offline machine in order to receive funds to the cold wallet - it is just enough to inform the sender about the cold wallet's public address. This is absolutely safe to do.
                    </p>
                </li>
            </ul>
            
            <h3 style="margin-top: 20px; margin-bottom: 15px; color: #333;">Transaction Broadcast Queue</h3>
            <ul style="margin-bottom: 20px;">
                <li><strong>Automatic Queue Management:</strong> All transactions are added to a broadcast queue for reliable delivery</li>
                <li><strong>Rate Limiting:</strong> Up to 30 transactions can be broadcast per block to prevent network congestion</li>
                <li><strong>Queue Features:</strong>
                    <ul style="margin-top: 5px;">
                        <li><strong>Visual Progress:</strong> See pending, broadcasting, complete, failed, and cancelled transactions</li>
                        <li><strong>Persistence:</strong> Queue survives page refreshes and connection drops</li>
                        <li><strong>Automatic Retry:</strong> Failed transactions retry up to 3 times</li>
                        <li><strong>UTXO Protection:</strong> Prevents double-spending by tracking consumed UTXOs</li>
                    </ul>
                </li>
                <li><strong>Queue Actions:</strong>
                    <ul style="margin-top: 5px;">
                        <li>Click transaction counts to see detailed information</li>
                        <li>Export failed/cancelled transactions for troubleshooting</li>
                        <li>Cancel pending transactions if needed</li>
                        <li>Resend, save, or delete individual cancelled transactions</li>
                        <li>Clear completed transactions manually or wait for auto-cleanup after 24 hours</li>
                    </ul>
                </li>
                <li><strong>Import & Broadcast:</strong> Import signed transactions from files and they'll be added to the queue</li>
                <li><strong>Max Available Button:</strong> Quickly calculate the maximum sendable amount accounting for fees</li>
            </ul>
            
            <h3 style="margin-top: 20px; margin-bottom: 15px; color: #333;">Additional Features</h3>
            <ul style="margin-bottom: 20px;">
                <li><strong>Reset Wallet:</strong> Click the "Reset" button to clear the current wallet data and start fresh</li>
            </ul>
            
            <h3 style="margin-top: 20px; margin-bottom: 15px; color: #333;">Watch-Only Mode</h3>
            <ul style="margin-bottom: 20px;">
                <li>Enter any Alpha address in the watch-only field</li>
                <li>Monitor balance and transactions without private keys</li>
                <li>Perfect for cold storage monitoring</li>
            </ul>
            
            <p style="margin-top: 20px; padding: 15px; background-color: #f0f9ff; border-radius: 4px;">
                <em>All wallet data is stored locally on your device. We never have access to your private keys.</em>
            </p>
        </div>
    </div>

    <!-- Disclaimer Modal -->
    <div id="disclaimerModal" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeDisclaimerModal()">&times;</span>
            <h2>Disclaimer</h2>
            
            <div style="margin-top: 20px; line-height: 1.6;">
                <h3 style="margin-bottom: 15px; color: #333;">Use at Your Own Risk</h3>
                <p style="margin-bottom: 15px;">
                    This wallet software is provided "as is", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose, and non-infringement.
                </p>
                
                <h3 style="margin-bottom: 15px; color: #333;">No Liability</h3>
                <p style="margin-bottom: 15px;">
                    In no event shall the authors, developers, or copyright holders be liable for any claim, damages, or other liability, whether in an action of contract, tort, or otherwise, arising from, out of, or in connection with the software or the use or other dealings in the software.
                </p>
                
                <h3 style="margin-bottom: 15px; color: #333;">Your Responsibility</h3>
                <ul style="margin-bottom: 15px;">
                    <li><strong>Backup your keys:</strong> You are solely responsible for backing up your private keys and seed phrases</li>
                    <li><strong>Secure your device:</strong> Ensure your computer is free from malware and unauthorized access</li>
                    <li><strong>Verify transactions:</strong> Always double-check addresses and amounts before sending</li>
                    <li><strong>Test first:</strong> Consider testing with small amounts before large transactions</li>
                </ul>
                
                <h3 style="margin-bottom: 15px; color: #333;">No Recovery Service</h3>
                <p style="margin-bottom: 15px;">
                    Lost private keys cannot be recovered. If you lose access to your private keys, you will permanently lose access to your funds. There is no password recovery or account recovery service.
                </p>
                
                <h3 style="margin-bottom: 15px; color: #333;">Experimental Features</h3>
                <p style="margin-bottom: 15px;">
                    Some features, particularly BIP32 wallet.dat import, are experimental and may not work with all wallet configurations. Always maintain backups before using experimental features.
                </p>
                
                <div style="padding: 15px; background-color: #fef2f2; border: 1px solid #fecaca; border-radius: 4px; margin-top: 20px;">
                    <strong style="color: #dc2626;">By using this wallet, you acknowledge that you understand and accept these terms.</strong>
                </div>
            </div>
        </div>
    </div>

    <!-- Security Notes Modal -->
    <div id="securityNotesModal" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeSecurityNotesModal()">&times;</span>
            <h2>Security Notes</h2>
            
            <div style="margin-top: 20px; line-height: 1.6;">
                <h3 style="margin-bottom: 15px; color: #333;">🔒 Private Key Security</h3>
                <ul style="margin-bottom: 20px;">
                    <li><strong>Never shared:</strong> Your private keys are never transmitted outside of your computer</li>
                    <li><strong>Local generation:</strong> All keys are generated locally using secure cryptographic functions</li>
                    <li><strong>Browser storage:</strong> Keys are stored within your browser's local storage (IndexedDB/localStorage)</li>
                    <li><strong>No server access:</strong> This wallet runs entirely in your browser - no server has access to your keys</li>
                </ul>
                
                <h3 style="margin-bottom: 15px; color: #333;">💾 Wallet Storage</h3>
                <ul style="margin-bottom: 20px;">
                    <li><strong>Browser-based:</strong> Wallet data is stored in your browser's local storage</li>
                    <li><strong>Encryption available:</strong> You can encrypt your wallet with a password for additional security</li>
                    <li><strong>Export formats:</strong> 
                        <ul style="margin-top: 5px;">
                            <li><strong>WIF format:</strong> Export private keys in Wallet Import Format for compatibility</li>
                            <li><strong>BIP32 format:</strong> Support for hierarchical deterministic wallets</li>
                            <li><strong>Text backup:</strong> Human-readable backup files with all wallet information</li>
                        </ul>
                    </li>
                </ul>
                
                <h3 style="margin-bottom: 15px; color: #333;">🛡️ Best Security Practices</h3>
                <ul style="margin-bottom: 20px;">
                    <li><strong>Offline usage:</strong> For maximum security, save this HTML file and use it on an air-gapped computer</li>
                    <li><strong>Regular backups:</strong> Export and securely store wallet backups in multiple locations</li>
                    <li><strong>Password protection:</strong> Always use a strong password when encrypting your wallet</li>
                    <li><strong>Verify source:</strong> Only use this wallet from trusted sources</li>
                    <li><strong>Clear browser data:</strong> Clear browser cache/storage when using on shared computers</li>
                </ul>
                
                <h3 style="margin-bottom: 15px; color: #333;">⚠️ Security Warnings</h3>
                <ul style="margin-bottom: 20px;">
                    <li><strong>Phishing:</strong> Always verify you're using the correct wallet URL/file</li>
                    <li><strong>Malware:</strong> Keep your computer free from viruses and keyloggers</li>
                    <li><strong>Browser extensions:</strong> Be cautious of browser extensions that might access page data</li>
                    <li><strong>Public computers:</strong> Never use this wallet on public or shared computers</li>
                </ul>
                
                <h3 style="margin-bottom: 15px; color: #333;">🔑 Supported Formats</h3>
                <ul style="margin-bottom: 20px;">
                    <li><strong>WIF (Wallet Import Format):</strong> Standard format for importing/exporting private keys</li>
                    <li><strong>BIP32/BIP44:</strong> Hierarchical deterministic wallet with multiple address derivation</li>
                    <li><strong>BIP32 wallet.dat:</strong> Import support for BIP32 hierarchical deterministic wallet files (experimental)</li>
                    <li><strong>Encrypted backups:</strong> AES-encrypted wallet files with PBKDF2 key derivation</li>
                </ul>
                
                <div style="padding: 15px; background-color: #f0f9ff; border: 1px solid #bfdbfe; border-radius: 4px; margin-top: 20px;">
                    <strong style="color: #1e40af;">Remember:</strong> You are your own bank. With great power comes great responsibility. Always prioritize security and never share your private keys with anyone.
                </div>
            </div>
        </div>
    </div>

</body>
</html>